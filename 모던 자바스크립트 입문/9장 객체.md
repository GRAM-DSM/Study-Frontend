# 9장 객체

## 9.1 객체 생성하기

### 9.1.1 객체의 생성

1. **객체 리터럴로 생성하는 방법**

   ```js
   var card = {suit: "하트", rank: "A"};
   ```

2. **생성자로 생성하는 방법**

   ```js
   function Card(suit, rank) {
   	this.suit = suit;
   	this.rank = rank;
   }
   var card = new Card("하트", "A");
   ```

3. **Object.create로 생성하는 방법**

   ```js
   var card = Object.create(Object.prototype,{...});
   ```



### 9.1.2 프로토타입

##### 생성자 안에서 메서드를 정의하는 방식의 문제점

- 생성자로 생성한 모든 인스턴스는 생성자의 메서드를 각각 가지게 되므로 똑같은 내용의 메서드를 메모리에 저장함으로써 메모리를 낭비한다는 단점이 있다.



##### 프로토타입 객체

- ```js
  function F() {};
  console.log(F.prototype);
  ```

  함수 객체는 기본적으로 prototype 프로퍼티를 지니고 있다. 이 prototype 프로퍼티가 가리키는 객체를 prototype 객체라고 한다.

- 여기서 프로토타입은 '인스턴스에 아무것도 정의하지 않아도 처음부터 사용할 수 있는 것'이라는 의미를 지닌다.

- 프로토타입 객체의 프로퍼티는 수정이 불가능하다. 인스턴스의 프로토타입 프로퍼티에 값을 대입하면 그 이름의 프로퍼티를 새로이 생성한다.

- 프로토타입 객체의 프로퍼티를 인스턴스에서 참조할 수 있을 때를 '인스턴스가 프로토타입 객체를 상속하고 있다'고 한다.

- 위에서 언급한 메모리 문제를 생성자의 프로토타입 객체에 메서드를 추가하는 방식으로 해결할 수 있다.



## 9.2 프로토타입 상속

### 9.2.1 상속

- **상속**이란 일반적으로 특정 객체가 타 객체로부터 기능을 이어받는 것을 말한다.
- JS의 상속은 프로토타입 체인이라고 부르는 객체의 자료 구조로 구현되어 있다. 이를 프로토타입 상속이라고 부른다.



### 9.2.2 상속을 하는 이유

- 상속을 이용하면 이미 정의된 프로퍼티와 메서드의 코드를 재정의 없이 재사용할 수 있으며, 이에 새로운 기능을 추가하여 확장된 객체를 만들 수도 있다.



### 9.2.3 프로토타입 체인

##### 내부 프로퍼티 [[Prototype]]

- 모든 객체가 내부에 가지고 있는 프로퍼티로 _ _ proto _ _ 프로퍼티에 이 값이 저장된다.

##### 프로토타입 체인

- 객체의 _ _ proto _ _ 프로퍼티는 그 객체에게 상속을 해준 부모 객체를 가리킨다. 이 때문에 자식 객체가 부모 객체의 프로퍼티를 사용할 수 있는 것이다.
- 객체는 값을 찾을 때 내부를 먼저 검색한 뒤 프로토타입을 타고 올라가 검색한다.
- 위처럼 _ _ proto _ _ 프로퍼티가 가리키는 객체를 차례대로 거슬러 올라가며 검색하는 연결고리를 

- 프로토타입 객체의 내부 프로퍼티인 [[Prototype]]은 기본적으로 Object.prototype을 가리킨다. 즉, 프로토타입 객체의 프로토타입은 Object.prototype이다.
- Object.prototype의 프로토타입은 null을 가리킨다.



##### 프로토타입 객체의 교체 및 constructor 프로퍼티

- 생성자의 prototype 프로퍼티 값에 값을 교체하기 위해 새로운 객체를 대입하면 인스턴스와 생성자 사이의 연결 고리가 끊기기 때문에 주의해야 한다.
- 위와 같은 현상이 일어나는 이유는 새로운 객체에는 constructor 프로퍼티가 없기 때문이다.
- 새로운 객체에 constructor 프로퍼티를 정의하고 생성자의 참조를 대입하면 위의 현상을 막을 수 있다.



##### 인스턴스 생성 후에 생성자의 프로토타입을 수정하거나 교체한 경우

- 인스턴스의 프로토타입은 생성자가 인스턴스를 생성할 때 가지고 있던 프로토타입 객체이다.
- 생성자의 프로토타입 값을 다른 값(객체)로 교체해도 이미 생성된 인스턴스의 프로토타입 값은 바뀌지 않는다.
- 단, 이미 생성자에 있는 프로토타입 값에 프로퍼티를 추가한 경우에는 바뀐 내용이 적용된다.



### 9.2.6 프로토타입의 확인

- 특정 프로토타입 객체가 그 객체의 프로토타입 체인에 포함되어 있는지 확인하는 방법에는 2가지 방법이 있다.

##### instanceof 연산자

- instanceof 연산자는 지정한 객체의 프로토타입 체인에 지정한 생성자의 프로토타입 객체가 포함되어 있는지를 판정한다.

  ```js
  객체 instanceof 생성자
  ```

  반환값은 논리값이다.

- 즉, 객체가 생성자의 프로토타입 객체를 상속받았는지를 확인하는 것이다.



##### isPrototypeOf 메서드

- 특정 객체가 다른 객체의 프로토타입 체인에 포함되어 있는지를 판단하는 메서드

  ```js
  프로토타입객체.isPrototypeOf(객체)
  ```



### 9.2.7 Object.prototype

##### Object 생성자

- 내장 생성자로 일반적인 객체를 생성한다.

  ```js
  var obj = new Object();
  ```

- 인수가 없으면 빈 객체를, 인수가 있으면 그 값을 Object 객체로 변환한 인스턴스를 생성한다.

- new 연산자 없이도 동일하게 작동한다.

- Object 생성자는 일반적인 객체를 조작하기 위한 메서드와 프로퍼티를 제공하고, Object.prototype으로 모든 내장 생성자 인스턴스에서 사용할 수 있는 메서드를 제공한다.



##### Object 생성자의 프로퍼티와 메서드

- 이 생성자는 prototype 프로퍼티와 여러 메서드를 갖는다.



##### Object.prototype의 메서드

- Object.prototype은 모든 내장 생성자의 프로토타입이며 때문에 Object.prototype의 메서드를 모든 생성자의 인스턴스에서 쓸 수 있다.



### 9.2.8 Object.create로 객체 생성하기

- 이 메서드를 사용하면 명시적으로 프로토타입을 지정하여 객체를 생성할 수 있다.

- Object.create 메서드는 생성할 객체의 프로토타입을 인수로 받는다. 또한 두번째 인수 작성을 통해 추가적으로 생성할 객체의 프로퍼티를 지정할 수도 있다.

  ```js
  var person1 = {
  	name: "Tom",
  	sayHello: function() { console.log("Hello! " + this.name);}
  };
  var person2 = Object.create(person1);
  person2.name = "Huck";
  person2.sayHello(); // -> Hello! Huck
  ```

  person2의 프로토타입은 person1의 프로토타입 객체를 가리킨다.

- 인수에 null을 넘기면 프로토타입이 없는 객체를 생성할 수 있다. 이렇게 생성한 객체는 Object.prototype조차 상속받지 않았다.

- 만약 객체 리터럴로 생성한 빈 객체(Object.prototype을 상속받음)를 만들고 싶다면 인수로 Object.prototype을 넘기면 된다.



## 9.3 접근자 프로퍼티

### 9.3.1 프로퍼티의 종류

**데이터 프로퍼티**: 값을 저장하기 위한 프로퍼티

**접근자 프로퍼티**: 값이 없음. 프로퍼티를 읽거나 쓸 때 호출하는 함수를 값 대신에 지정할 수 있는 프로퍼티.



### 9.3.2 접근자 프로퍼티

- **접근자**: 객체 지향 프로그래밍에서 객체가 가진 프로퍼티 값을 객체 외부에서 읽거나 쓸 수 있도록 제공하는 메서드.
- 접근자 프로퍼티를 사용하면 데이터를 부적절하게 변경하는 것(객체의 프로퍼티를 객체 외부에서 직접 조종했을 경우 발생할 수 있음)을 막고 특정 데이터를 외부로부터 숨길 수 있으며 외부에서 데이터를 읽으려고 시도할 때 적절한 값으로 가공해서 넘길 수 있다
- **게터 함수**: 접근자 프로퍼티를 읽을 때의 처리를 담당한다.
- **세터 함수**: 접근자 프로퍼티를 쓸 때의 처리를 담당한다.
- 접근자 프로퍼티는 게터와 세터 중 하나만 정의할 수도 있다.

- 게터는 인수가 없고 세터는 인수를 한 개 받는다
- 접근자 프로퍼티의 값을 읽으려고 시도하면 getter가 호출되고 값을 쓰려고 시도하면 setter가 호출된다.
- 이 때 getter가 없으면 반환값은 undefined이며 setter가 없으면 아무것도 실행되지 않는다.



### 9.3.3 데이터의 캡슐화

- 일반 생성자를 데이터 프로퍼티와 접근자 프로퍼티로 구분하면 접근자 프로퍼티로 데이터 프로퍼티에 접근할 수도 있고 데이터 프로퍼티에 직접 접근할 수도 있다.
- 이 직접 접근을 막기 위해 즉시 실행 함수로 클로저를 만들면 데이터 프로퍼티에 직접적으로 접근할 방법이 사라진다.



## 9.4 프로퍼티의 속성

### 9.4.1 프로퍼티의 속성

- 프로퍼티는 논리값의 형태로 세 가지의 내부 속성을 가진다.
  - **쓰기 가능(writable)**: 프로퍼티에 쓰기가 가능한지를 뜻하는 속성
  - **열거 가능(enumerable)**: 프로퍼티가 열거 가능(반복 가능)한 대상인지를 뜻하는 속성
  - **재정의 가능(configurable)**: 프로퍼티의 내부 속성을 수정할 수 있는지를 뜻하는 속성으로 삭제 및 수정이 가능한지를 나타낸다.
- 새로이 추가한 프로퍼티의 기본 내부 속성 설정은 쓰기 가능/열거 가능/재정의 가능이다.
- 내장 생성자가 가지고 있는 프로토타입 객체의 프로퍼티 대부분의 내부 속성 설정은 쓰기 가능/열거 불가능/재정의 가능이다.
- 데이터 프로퍼티의 값(value)와 접근자 프로퍼티의 getter/setter를 속성으로 간주하면 데이터 프로퍼티는 '값/쓰기 가능/열거 가능/재정의 가능'의 속성의 띄고 있고 접근자 프로퍼티는 '읽기(get)/쓰기(set)/열거 가능/재정의 가능'의 속성을 띄고 있다.



### 9.4.2 프로퍼티 디스크럽터와 프로퍼티를 읽고 쓰는 메서드

##### 프로퍼티 디스크립터

- 프로퍼티의 속성 값을 뜻하는 객체로 이 객체의 프로퍼티 이름은 속성 이름과 같다.

- 데이터 프로퍼티의 프로퍼티 디스크립터

  ```js
  {
  	value: 프로퍼티의 값,
  	writable: 논리값,
  	enumerable: 논리값,
  	configurable: 논리값
  }
  ```

- 접근자 프로퍼티의 프로퍼티 디스크립터

  ```js
  {
  	get: getter함수값,
  	set: setter함수값,
  	enumerable: 논리값,
  	configurable: 논리값
  }
  ```



##### 프로퍼티 디스크립터 가져오기 : Object.getOwnPropertyDescriptor

- 위 메서드는 객체 프로퍼티의 프로퍼티 디스크립터를 가져온다.
- 2개의 인수로 각각 객체의 참조와 프로퍼티의 이름을 뜻하는 문자열을 받는다.
- 프로토타입으로 상속받은 프로퍼티나 없는 프로퍼티를 지정하면 undefined를 반환한다. 즉, 그 객체의 프로퍼티 디스크립터만 가져올 수 있다.



##### 객체의 프로퍼티 설정하기 : Object.defineProperty

- 위 메서드는 객체의 프로퍼티에 프로퍼티 디스크립터를 설정한다.
- 3개의 인수로 각각 객체의 참조, 프로퍼티 이름을 뜻하는 문자열, 프로퍼티 디스크립터의 참조를 받는다.
- 실행 후에는 수정한 객체의 참조를 반환한다.
- 이 메서드를 사용할 때 프로퍼티 디스크립터의 각 프로퍼티를 생략할 수 있다. 이렇게 설정한 객체에 프로퍼티를 새로이 생성하면 새로운 프로퍼티의 속성 값 중 생략한 프로퍼티에 대응하는 속성값은 false나 undefined로 설정된다.  이미 생성되어 있는 프로퍼티를 이렇게 수정하면 생략된 속성 값은 수정되지 않는다.



##### 객체의 프로퍼티 속성 여러 개를 한꺼번에 설정하기 :  Object.defineProperties

- 위 메서드는 객체가 가진 프로퍼티 여러 개에 각각의 프로퍼티 디스크립터를 설정한다.
- 2개의 인수로 각각 객체의 참조와 새롭게 설정 또는 변경하고자 하는 프로퍼티 이름이 키로 지정된 프로퍼티 여러 개가 모인 객체를 받는다. 이 객체의 프로퍼티는 프로퍼티 디스크립터이다.



### 9.4.3 Object.create의 두 번째 인수

- 9.2.8 절의 Object.create 메서드의 두 번째 인수로 새로이 생성할 객체가 포함할 프로퍼티 목록을 넘겨서 새로운 객체를 생성할 수 있다.
- 이 프로퍼티의 목록을 넘기는 방식은 Object.defineProperties 메서드와 같다. 프로퍼티의 이름과 그 프로퍼티의 프로퍼티 디스크립터를 넘기면 첫 번째 인수를 프로토타입으로 하는 두 번째 인수의 객체를 지닌 객체가 생성된다.



## 9.5 프로퍼티가 있는지 확인하기

### 9.5.1 in 연산자

- 4.1.4 절 참조
- 검색 대상은 객체가 소유한 프로퍼티 + 상속받은 프로퍼티이다.



### 9.5.2 hasOwnProperty 메서드

- 위 메서드는 지명한 프로퍼티가 그 객체가 소유한 프로퍼티면 true를 반환하고 상속 받은 프로퍼티면 false를 반환한다.



### 9.5.3 propertyIsEnumerable 메서드

- 위 메서드는 지정한 프로퍼티가 그 객체가 소유한 프로퍼티이며 열거할 수 있을 때 true를 반환한다.



## 9.6 프로퍼티의 열거

### 9.6.1 for/in 문

- 7.3.4 절 참조
- 객체와 객체의 프로토타입 체인이 검색 범위이다.



### 9.6.2 Object.keys 메서드

- 위 메서드는 객체가 소유한 프로퍼티 중 열거할 수 있는 프로퍼티 이름만 배열로 만들어서 반환한다.
- 검색 범위는 객체가 소유한 프로퍼티이다.(상속 x)



### 9.6.3 Object.getOwnPropertyNames 메서드

- 위 메서드도 인수로 지정한 객체가 소유한 프로퍼티 이름을 배열로 만들어 반환한다. 단, 열거할 수 없는 프로퍼티까지 배열로 만들어 반환한다.



## 9.7 객체 잠그기

### 9.7.1 확장 가능 속성

- 객체에 새로운 프로퍼티를 추가할 수 있는지를 결정하는 속성이다.



### 9.7.2 확장 방지 : Object.preventExtensions 메서드

- 위 메서드는 인수로 받은 객체를 확장할 수 없도록 만든다.
- 이 메서드로 확장할 수 없게 만든 객체는 두 번 다시 프로퍼티를 추가할 수 없게 된다.
- Object.isExtensible



### 9.7.3 밀봉 : Object.seal 메서드

- 위 메서드는 인수로 받은 객체를 밀봉한다.  
- **밀봉** : 객체에 프로퍼티를 추가하는 것을 금지하고 기존의 모든 프로퍼티를 재정의할 수 없게 만드는 것을 말한다.
- Object.isSealed 메서드를 사용하면 인수로 받은 객체가 밀봉된 상태인지 확인할 수 있다.



### 9.7.4 동결 : Object.freeze 메서드

- 이 메서드는 인수로 받은 객체를 동결한다. 
- **동결**: 객체에 프로퍼티를 추가하는 것을 금지하고 기존의 모든 프로퍼티를 재정의할 수 없게 만들며 데이터 프로퍼티를 쓸(작성) 수 없게 만든다.
- 단, 객체에 접근자 프로퍼티가 정의되어 있다면 게터 함수와 세터 함수 모두를 호출할 수 있다.
- Objcet.isFrozen 메서드를 사용하면 인수로 받은 객체가 동결된 상태인지 확인할 수 있다.



## 9.8 Mixin

### 9.8.1 Mixin 함수

- **믹스인(Mixin)**: 특정 객체에 다른 객체가 가지고 있는 프로퍼티를 붙여 넣어 뒤섞는 기법.

- 믹스인은 상속을 사용하지 않는 대신에 특정 객체의 프로퍼티를 동적으로 다른 객체에 추가한다.

  ```js
  function mixin(target, source) {
  	for(var property in source) {
  		if(source,hasOwnProperty(property)) {
  			target[property] = source[property];
  		}
  	}
  	return target;
  }
  ```

- 위 코드에서 함수 mixin은 원복 객체가 소유하면서 열거할 수 있는 프로퍼티 모두를 타깃 객체에 복사한 후 타깃 객체를 반환한다.

  ```js
  var obj1 = {a:1, b:2};
  var obh2 = {b:3, c:4};
  var obj = mixin(obj1, obj2); // -> Object {a: 1, b:3, c:4}
  ```



### 9.8.2 좀 더 완전한 Mixin 함수

- 위의 예제 코드에는  원본 객체가 접근자 프로퍼티를 가지고 있을 때 접근자 프로퍼티도 데이터 프로퍼티로 바뀌어 반환(복사)되는 문제가 있다.

- 예를 들어 getter 함수만 있어 값을 대입할 수 없는 객체를 빈 객체와 믹스인하면 값을 대입할 수 있게 된다. 이는 객체의 복사 과정에서 빈 객체에 프로퍼티를 추가하고 단순히 원본 객체의 값만 할당하기 때문이다.

- 객체의 접근자 프로퍼티를 다른 객체에 믹스인하려면 mixin 함수에서 프로퍼티를 생성할 때 Object.defineProperty 메서드를 사용해야 한다.

  ```js
  function mixin(target, source) {
  	var keys = Object.keys(source);
  	for(var i=0; i<keys.length; i++){
  		var descriptor = Object.getOwnPropertyDescriptor(source, keys[i]);
  		Object.defineProperty(target, keys[i], descriptor);
  	}
  	return target;
  }
  
  ```



## 9.9 JSON

### 9.9.1 JSON

- **JSON**: 자바스크립트 객체를 문자열로 표현하는 데이터 포맷. 객체를 **직렬화**할 수 있다.
- **직렬화**: 컴퓨터의 메모리 속에 있는 객체를 똑같은 객체로 환원할 수 있는 문자열로 변환하는 과정



### 9.9.2 표기 방법

- JSON은 리터럴 표기법에 기반을 두고 있다. 즉, 리터럴 표기법의 부분 집합이다.

  ```js
  {name: "Tom", age: 17, marriage: false, data: [2, 5, null]};
  
  '{"name": "Tom", "age": 17, "marriage":false, "data":[2,5,null]}' // JSON 데이터 포맷
  ```

  데이터 전체는 작은 따옴표로 묶고 키를 큰따옴표로 묶은 문자열로 표기한다.

### 9.9.3 JSON의 변환과 환원

##### 자바스크립트 객체를 JSON 문자열로 변환하기 : JSON.stringify

- 위 메서드는 인수로 받은 객체를 JSON 문자열로 바꾸어 반환한다.

  ```js
  JSON.stringify(value[, replacer[, space]])
  ```

  value에는 JSON으로 변환할 객체를, 두 번째 인수 replacer에는 함수나 배열을, 세 번째 인수 space에는 출력하는 문자열을 구분할 때 사용할 공백 문자를 지정한다. 이 때 두 번째 인수로 함수를 지정하면 문자열로 만드는 프로퍼티의 키와 값을 함수로 받아 프로퍼티 값을 표현하는 문자열을 반환한다.

  ```js
  JSON.stringify({}); // '{}' // 인수가 하나일 때
  JSON.stringify({x:1, y:2, z:3}, ["x", "z"]); // '{"x":1, "z":3}' // 인수가 2개일 때
  JSON.stringigy({x:1, y:2, z:3}, ["x", "z"], '\t');
  //
  '{
  	"x":1,
      "y":2
  }'
  // 세번째 인수에 탭 문자를 넣었을 때
  ```



##### JSON 문자열을 자바스크립트 객체로 환원하기 : JSON.parse

- 위 메서드는 인수로 받은 문자열을 자바스크립트 객체로 환원해서 반환한다.

  ```js
  JSON.parse(text[, reviver])
  ```

  첫 번째 인수에는 JS 객체로 환원하고자 하는 JSON 문자열을 지정한다. 두 번째 인수로는 프로퍼티의 키와 값을 인수로 받는 함수를 지정할 수 있다. 이 때 함수는 환원될 객체의 프로퍼티 값을 반환한다.

  ```js
  JSON.parse('{}'); // {}
  ```



## 9.10 ECMAScript 6부터 추가된 객체의 기능

### 9.10.1 프로퍼티 이름으로 심벌 사용하기

- ECMAScript6부터는 심벌을 프로퍼티 이름으로 사용할 수 있게 되었다.

  ```js
  var obj = {};
  var s = Symbol("heart");
  obj[s] = 3;
  console.log(obj); // Object {Symbol(heart):3}
  ```

- 심벌을 프로퍼티 이름으로 사용하면 함수 바깥에서 프로퍼티 값을 읽거나 쓸 수 없다. 단, Object.getOwnPropertySymbols 메서드로는 프로퍼티 이름 목록을 가져올 수 있다.



##### 내장 생성자 prototype의 안전한 확장

- 심벌을 사용하면 메서드 이름이 겹치는 걸 피할 수 있기 때문에 기본 생성자의 prototype을 확장할 수 있다.



### 9.10.2 객체 리터럴에 추가된 기능

- 객체 리터럴에 새로운 표기법이 생겼다.

  1. ##### 계산된 프로퍼티 이름 : { [계산식]: value}

     - 계산식이 평가된 값을 프로퍼티 이름으로 사용한다.

     - 평가 값이 Symbol 타입이면 그대로 사용하고 아니면 문자열 타입으로 변환한다.

       ```js
       var prop = "name", i = 1;
       var obj = { [ prop+i ]: "Tom"};
       ```

  2. ##### 프로퍼티 정의의 약식 표기 : {prop}

     - 변수 prop가 선언되어 있을 때 {prop}을 {prop: prop}으로 사용할 수 있게 되었다. 즉, 프로퍼티 이름이 변수와 같은 때 {prop}으로 줄여 쓸 수 있다는 것이다. 이 때 프로퍼티 값은 그 변수의 값이 된다.

  3. ##### 메서드 정의의 약식 표기 : {method() {} }

     - 프로퍼티 값으로 함수를 지정할 때 사용하는 약식 표기법이다.

  4. ##### 제너레이터 정의의 약식 표기 : {*generator () {}}

     -  프로퍼티의 값이 제너레이터 함수일 때 사용할 수 있는 약식 표기법이다.