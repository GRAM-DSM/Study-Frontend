# 4장 객체와 배열, 함수의 기초

## 4.1 객체의 기초 1번 객체 리터럴

### 4.1.1 객체

- **객체**: 객체는 이름과 값을 한 쌍으로 묶은 데이터를 여러 개 모은 것이다. 즉, 복합 데이터로 **연관 배열** 또는 **사전**이라고도 부른다.
- 객체에 포함된 데이터 하나(이름과 값의 쌍)를 가리켜 객체의 **프로퍼티**라고 한다. 이 프로퍼티의 이름을 프로퍼티 이름 또는 키라고 부른다.
- 객체는 객체 리터럴을 사용하거나 생성자라는 함수를 사용하여 생성할 수 있다.

### 4.1.2 객체 리터럴로 객체 생성하기

- ```js
  var card = { suit: "하트", rank: "A"};
  ```

  위의 예시에서 {...} 부분이 객체 리터럴이다.

- 키와 프로퍼티 값은 콜론(:)을 사용하여 구분하고 프로퍼티들은 쉼표로 구분한다.

- 키로는 모든 식별자와 문자열 리터럴을 사용할 수 있다. 따라서 아래의 경우도 가능하다.

  ```js
  var card = { "suit": "하트", rank: "A"};
  ```

- 변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 마침표(.) 연산자 또는 대괄호 연산자를 사용한다.

  ``` js
  card.suit	// -> 하트
  card["rank"] 	// -> A
  ```

  마침표로 프로퍼티를 호출할 때는 키값만 사용할 수 있다. 허나 대괄호로 프로퍼티를 호출할 땐 키값 또는 문자열을 반환하는 표현식을 사용할 수 있다.

- 객체에 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환한다.

- 객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면 빈 객체가 생성된다.

  ```js
  var obj = {};
  console.log(obj);	// -> Object{}
  ```



### 4.1.3 프로퍼티 추가와 삭제

- 존재하지 않는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가된다.

  ```js
  var card = {};
  card.value = 14;
  console.log(card) // -> { value: 14 }
  ```

- delete 연산자를 사용하면 프로퍼티를 삭제할 수 있다.

  ```js
  delete card.value;
  console.log(card) // -> {}
  ```



### 4.1.4 in 연산자로 프로퍼티가 있는지 확인하기

- in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있다. 반환값은 true false이다.

- '프로퍼티 이름을 뜻하는 문자열 in 객체명'의 형식으로 사용한다.

  ```js
  var card = {suit: "하트", rank: "A"};
  console.log("suit" in card); // -> true
  console.log("color" in card); // -> false
  ```

- in 연산자는 객체가 가진 프로퍼티와 그 객체가 상속받은 모든 프로퍼티를 대상으로 조사한다.

  ```js
  console.log("toString" in card); // true
  ```

  위의 반환값이 true인 이유는 Object 객체를 card가 상속받았기 때문이다.



### 4.1.5 객체 리터럴 예제

아래는 객체 리터럴을 사용하는 예제들이다

1. ##### 좌표평면의 점을 표현하는 객체

   ```js
   var p = { x: 1.0, y: 2.5};
   ```

   

2. ##### 원을 표현하는 객체

   ```js
   var circle = { center: { x: 1.0, y: 2.0}, radius: 2.5};
   console.log(circle.center.x) // -> 1
   ```

   위 예제를 보면 객체의 프로퍼티 값으로 다른 객체를 대입할 수 있다는 것을 알 수 있다.

   

3. ##### 회원 정보를 표현하는 객체

   ```js
   var person = { name: "이정규", age: 18, sex: "남", married: false };
   ```



### 4.1.6 메서드

- 프로퍼티에 함수 타입의 값이 저장되어 있으면 그 프로퍼티를 메서드라고 한다.



### 4.1.7 객체는 참조 타입

- 객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 **참조**(메모리에서의 위치 정보)가 저장된다. 이 때의 변수 상태를 가리켜 객체를 참조하고 있다라고 한다.

  ```js
  var card = { suit: "하트", rank: "A"};
  ```

  위 코드에서는 변수 card가 객체를 참조하고 있다고 한다.

  ```js
  var a = card;
  ```

  card에는 객체의 참조가 저장되어 있는데, 이를 다른 변수에 저장할 수도 있다. 이 때 a를 통해 객체를 수정할 수 있다.

  ```js
  console.log(a.suit); // -> 하트
  a.suit = "스페이드";
  console.log(a.suit); // -> 스페이드
  console.log(card.suit); // -> 스페이드
  ```



## 4.2 함수의 기초

### 4.2.1 함수

- 어떠한 입력 값에 대해 출력 값을 주는 기능. 입력 값을 **인수**, 출력 값을 **반환값**이라고 부른다.



### 4.2.2 함수 선언문으로 함수 정의하기

- function 키워드로 정의한다.

  ```js
  function square(x) { return x * x; }
  ```



### 4.2.3 함수 이름

- 변수 이름과 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있다.
- 함수 이름은 일반적으로 함수의 기능을 알 수 있게 해주는 동사 또는 동사로 시작되는 어휘로 만든다.



### 4.2.4 함수 호출

- 함수를 호출할 땐 함수 이름 뒤에 소괄호로 인수를 묶어 입력한다.

  ```js
  square(3)	// -> 9
  ```

  이 때 인수로 넘긴 값인 3이 함수 정의문의 인수 x로 전달되어 중괄호를 거쳐 return 된다. 함수 호출 시에 전달되는 값을 인수, 함수 정의문의 인수를 인자라고 한다.



### 4.2.5 인수

- 인수는 여러 개로 받을 수도 있는데, 이 때 인수는 쉼표로 구분한다.

  ```js
  function dist(p, q){
  	var dx = q.x - p.x;
  	var dy = q.y - p.y;
  	return Math.sqrt(dx*dx+dy*dy);
  } // 두 점 사이의 거리를 구하는 함수 
  ```

  위의 Math.sqrt는 제곱근을 구하는 함수이다.

- 인수를 받지 않는 함수도 정의할 수 있다.

  ```js
  var bark = function() { console.log("Bow-wow");};
  
  bark(); // "Bow-wow"
  ```

  위 코드엔 인수도 return문도 존재하지 않아 제어권이 함수를 호출한 코드로 되돌아가면 함수의 반환값이 undefined가 된다.

  ```js
  console.log(bark()); // -> undefined
  ```



### 4.2.6 함수의 실행 흐름

1. 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다.
2. 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다.
3. return 문이 실행되면 호출한 코드로 돌아간다. 이 때 return의 값이 반환값이 된다.
4. return 문이 실행되지 않은 상태로 마지막 문장이 실행되면, undefined가 반환된다.



### 4.2.7 함수 선언문의 끌어올림

- 함수 선언문은 변수 선언문처럼 프로그램의 첫머리로 끌어올려진다.

  ```js
  console.log(square(5)); // -> 25
  function square(x) { return x * x; }
  ```



### 4.2.8 값으로서의 함수

- 자바스크립트에서는 함수가 객체이다. 함수 선언문으로 함수를 선언하면 내부적으로는 함수 이름을 변수 이름으로 한 변수와 함수 객체가 만들어지고, 그 변수에 함수 객체의 참조가 저장된다.

- 즉, 위 예제에선 변수 square가 함수 객체를 참조하고 있는 것이다. 

- 이 변수 값을 다른 변수에 할당하면 그 변수 이름으로 함수를 실행할 수 있다.

  ```js
  var sq = square;
  console.log(sq(5)); // -> 25
  ```

- 함수는 다른 함수의 인수로도 넘길 수 있다.



### 4.2.9 참조에 의한 호출과 값에 의한 호출

- 함수의 인수가 원시 값이냐 객체냐에 따라 동작하는 과정이 다르다.

- **원시 값**

  ```js
  function add1(x) { return x = x + 1; }
  var a = 3;
  var b = add1(a);
  console.log("a= ", + a + ", b = " + b); // -> a=3, b=4
  ```

  위 함수에서 인자 x는 변수 a의 복사본이다. 즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달된다. 이를 **값의 전달**이라고 부른다.

- **객체**

  ```js
  function add1(p) { p.x= p.x + 1; .y = p.y + 1; return p; }
  var a={x:3, y:4};
  var b=add1(a);
  console.log(a,b); // -> Object {x=4, y=5} Object {x=4, y=5}
  ```

  위 코드에서는 a가 객체의 참조를 저장하고 있기 때문에 p에 객체의 참조가 전달되고, 함수를 통해 객체가 수정되면서 a와 b가 같게 되는 것이다.

- ##### 인수 여러 개를 우아하게 전달하는 방법(elegant way)

  - 함수에 넘겨야 하는 인수 개수가 많아지면 

    - 인수의 순서를 착각하거나 
    - 함수가 받는 인수의 개수를 바꿨을 때 함수의 호출 방법이 바뀌어 프로그램 전체를 수정하는 등

    의 문제가 발생한다. 

    이러한 문제는 객체의 프로퍼티에 인수를 담아서 넘기는 방법으로 해결할 수 있다.

    ```js
    function setBallProperties(x, y, vx, vy, radius) {...}
    ...
    setBallProperties(0,0,10,15,5);
    //아래는 수정한 방법
    var parameters = {
    	x:0,
    	y:0
    	vx:10,
    	vy:15,
    	radius:5
    };
    
    function setBallProperties(params) { ... }
    ...
    setBallProperties(parameters);
    ```

    단, 함수 아나에서 객체의 프로퍼티를 수정한다면 호출한 코드에 있는 인수 객체의 프로퍼티가 함께 바뀌는 점을 주의해야 한다.



### 4.2.10 변수의 유효 범위

##### 전역 유효 범위와 지역 유효 범위

- **유효 범위**: 각 변수에 접근할 수 있는 범위.

- **어휘적 범위**: 프로그램의 구문으로 유효 범위를 정하는 방법. 자바스크립트는 어휘적 범위를 채택하였다.

- **동적 범위**: 프로그램 샐행 중 유효 범위를 정하는 방법.

- 자바스크립트 변수는 변수의 유효 범위에 따라 **전역 변수**와 **지역 변수**로 나뉜다.

- **전역 변수**는 함수 바깥에서 선언된 변수로 유효 범위가 프로그램 전체이다.

- **지역 변수**는 함수 안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부이다.

- ```js
  var a = "global";
  function f(){
  	var b = "local";
  	console.log(a); // -> "global"
  	return b;
  }
  f();
  console.log(b); // -> 에러 발생
  ```

  위의 코드에서 a는 전역 변수, b는 지역 변수이다.



##### 변수의 충돌

- 변수의 유효 범위는 각기 다른 부분에 있는 같은 이름의 변수가 충돌하지 않게 해준다.

- 때문에 전역 변수와 지역 변수의 이름이 같다면 충돌을 일으키게 된다.

- 전역 변수와 지역 변수 이름이 같다면 지역 변수를 사용하게 된다.

  ```js
  var a = "global";
  function f() {
  	var a = "local";
  	console.log(a); // -> local
  	return a;
  }
  f();
  console.log(a);	// -> global
  ```



##### 함수 안에서의 변수 선언과 변수 끌어올림

- 함수 안에서 선언된 지역 변수의 유효 범위는 함수 전체이다. 변수 끌어올림은 함수 내에서 적용된다.

  ```js
  function f() {
  	console.log(a); // 선언은 되었지만 값은 적용되지 않음 -> undefined 
  	var a = "local";
  	console.log(a); // -> local
  	return a;
  }
  ```

  



##### 함수 안에서의 변수 선언 생략

3.1.3에서 언급했듯이 변수를 선언하지 않고 값만 대입하면 자동으로 전역 변수로 선언된다. 이 현상은 함수 안에서도 발생한다.

```js
function f() {
	a = "local";
	console.log(a); // ->local
	return a;
}
f();
console.log(a); // -> local
```



### 4.2.11 블록 유효 범위 : let과 const

- 블록 유효 범위를 갖는 변수를 선언한다.

- 블록 유효 범위를 가진 변수는 중괄호 안에서만 유효하다.

- let은 변수 선언, const는 한 번만 할당 가능한 상수를 선언한다.

- ##### let 선언자

  - 블록 유효 범위를 갖는 지역 변수를 선언한다. 사용법은 var 문과 같다.

    ```js
    let x = "outer x";
    {
    	let x = "inner x";
    	let y = "inner y";
    	console.log(x); // -> inner x
    	console.log(y); // -> inner y
    }
    console.log(x);	// -> outer x
    console.log(y); // -> 에러 발생
    ```

  - let 문은 var 문과 달리 끌어올리는 현상이 발생하지 않고, 중복되는 변수를 선언하면 하나로 통일하지 않고 오류로 처리한다.

    ```js
    console.log(x); // -> 에러 발생
    let x = 5;
    ```

    ```js
    let x;
    let x; // 문법 오류	
    ```

- ##### const 선언자

  - 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다. 동작 규칙은 let 문과 동일하지만 반드시 초기화를 해야한다는 차이점이 있다.

    ```js
    const c = 2;
    c = 5; // -> 타입 에러
    ```

    const 문으로 선언한 변수에 다시 대입을 시도하면 위처럼 타입 오류가 발생한다. 그러나 상수 값이 객체이거나 배열일 경우에서 프로퍼티 또는 프로퍼티 값을 수정할 수 있다.

    ```js
    const origin = { x:1, y:2};
    origin.x = 3;
    console.log(origin); // -> Object {x:3, y:2}
    ```



### 4.2.12 함수 리터럴로 함수 정의하기

- 함수 리터럴을 통해 함수를 정의할 수 있다.

  ```js
  var square = function(x) { return x * x; };
  ```

  위 코드에서 function(x) {...} 부분이 함수 리터럴이다.

- 함수 리터럴은 이름이 없는 함수로 익명 함수 또는 무명 함수라고도 부른다.

- 함수 리터럴에는 끝에 세미콜론을 반드시 붙여야 한다.

- 함수 리터럴의 사용법은 함수와 같이 square(5)의 형식으로 사용하면 된다. 이는 두 함수 모두 내부적으로 square 변수에 함수 객체의 참조를 저장하기 때문이다.

- 함수와 함수 리터럴의 차이는 각각 끌어올려지느냐 아니냐의 차이이다.

  ```js
  console.log(square(3)); // 에러 발생
  var square = function(x) { return x * x; };
  ```

- 익명 함수에도 이름을 붙일 수 있다.

  ```js
   var square = function sq(x) { return x * x; };
  ```

  그러나 sq라는 이름은 함수 안에서만 유효하다. 이름이 없는 것과 있는 것의 차이는 디버거에서 이름으로 표시되느냐 anonymous function으로 표현되느냐의 차이를 지니고 있다.



### 4.2.13 객체의 메서드

- 객체의 프로퍼티 중 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 **메서드**라고 부른다.

- 메서드를 정의할 때는 프로퍼티 값으로 함수 리터럴을 대입한다.

  ```js
  var circle = {
  	center: { x:1.0, y:2.0 },
  	radius: 2.5,
  	area: function(){	// 원의 넓이를 구하는 메서드
  		return Math.PI * this.radius * this.radius;
  	}
  };
  ```

  함수 객체 안의 this는 그 함수를 메서드로 가지고 있는 객체를 가리킨다.

- 메서드는 일반 함수와 바찬가지로 소괄호를 붙여서 실행한다.

  ```js
  circl.area() // -> 19.63495...
  ```

- 메서드 또한 프로퍼티의 일종으로 나중에 추가할 수 있다. 위의 객체에 아래의 메서드를 추가할 수 있다.

  ```js
  circle.translate = function(a, b) {
  	this.center.x = this.center.x + a;
  	this.center.y = this.center.y + b;
  };
  ```

  ```js
  circle.translate(1,2);
  cercle.center; // -> Object {x=2, y=4}
  ```

- 이처럼 메서드는 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용한다. 일반적인 객체 지향 언어에서는 데이터와 그 상태를 바꾸는 메서드를 하나로 묶는 용도로 객체를 사용한다.



### 4.2.14 함수를 활용하면 얻을 수 있는 장점

##### 재사용할 수 있다

동일한 작업 반복을 함수 호출만으로 같은 작업을 여러 번 반복할 수 있다.

##### 만든 프로그램을 이해하기 쉽다

프로그램이 간결해지므로 프로그램의 흐름을 파악하기 쉬워진다.

##### 프로그램 수정이 간단해진다

똑같은 수정을 여러 반복할 필요가 없어지기 때문에 프로그램 수정이 간단해진다.



## 4.3 객체의 기초 2번 생성자

### 4.3.1 생성자로 객체 생성하기

- 자바, c++ 등은 다수의 객체를 생성하는 수단으로 클래스를 사용하지만 자바스크립트는 클래스가 없어 생성자라고 하는 함수로 객체를 생성한다.

##### 간단한 예

- 아래는 트럼프 카드를 표현하는 객체를 생성하는 생성자이다.

```js
function Card(suit, rank) {
	this.suit = suit;
	this.rank = rank;
}
```

- 생성자로 객체를 생성할 때는 new 연산자를 사용한다.

  ```js
  var car = new Card("하트", "A");
  ```

- 위 코드 실행 시 suit 프로퍼티에는 "하트", rank 프로퍼티에는 "A"라는 값이 저장된 객체가 생성되고, 그 객체의 참조가 변수 card에 할당된다.

  ```js
  console.log(card); // -> Card { suit: "하트", rank: "A"}
  ```

  이때 Card 생성자로 생성한 객체를 Card 객체라고 부른다.

##### 생성자

- 위처럼 new 연산자로 객체를 생성할 것이라 기대하고 만든 함수를 생성자라고 부른다.

- 생성자명은 관례적으로 첫 글자를 대문자로 쓰는 파스칼 표기법을 사용한다.

- 생성자 안에서 **this.프로퍼티 이름**에 값을 대입하면 그 이름을 가진 프로퍼티에 값이 할당된 객체가 생성된다. 위의 생성자는 아래의 객체 리터럴과 같다.

  ```js
  var card = {};
  card.suit = "하트";
  card.rank = "A";
  ```

- 생성자와 new 연산자로 생성한 객체를 그 생성자의 **인스턴스(실체)**라고 부른다. 객체 지향 언어에서 인스턴스는 클래스로 생성한 실체를 뜻하므로 엄밀히 말해 생성자로 생성한 객체는 아니지만 역할이 동일하므로 인스턴스라고 부른다.

##### 생성자의 역할

- 생성자는 객체를 생성하고 초기화하는 역할을 한다. 생성자를 사용하면 이름은 같지만 프로퍼티 값이 다른 객체(인스턴스) 여러 개를 간단히 생성할 수 있다.

  ```js
  var card1 = new Card("하트", "A");
  var card2 = new Card("클럽", "K");
  var card3 = new Card("스페이드", "2");
  ```

- 생성자는 함수이므로 프로퍼티에 값을 대입할 수 있다. 이를 활용하면 객체를 생성할 때 초기화 작업을 병행할 수 있다.

  ```js
  function Particle(x, y, vx, vy){
  	this.x = x;
  	this.y = y;
  	this.vx = vx;
  	this.vy = vy;
  	this.velocity = Math.sqrt(vx * vx + vy * vy);
  }
  var p = new Particle(0, 0, 3, 4);
  console.log(p); // -> Particle {x:0, y:0, vx:3, vy:4, velocity:5}
  ```



### 4.3.2 메서드를 가진 객체를 생성하는 생성자

- 생성자에서 **this.프로퍼티 이름**에 함수의 참조를 대입하면 메서드를 정의할 수 있다. 이때 메서드 함수 내부에 있는 this는 생성될 인스턴스를 가리킨다.

  ```js
  function Circle(center, radius) {
  	this.center = center;
  	this.radius = radius;
  	this.area = function() {
  		return Math.PI * this.radius * this.radius;
  	};
  }
  var p = {x:0, y:0};
  var c = new Circle(p, 2.0);
  console.log("넓이 = " + c.area()); // -> 넓이 = 12.56637...
  ```

  메서드 함수 안에서 this를 사용하면 그 값이 인스턴스의 프로퍼티임을 명시할 수 있다.



## 4.4 객체의 기초 3번 내장 객체

- 자바스크립트에는 내장되어 있는 객체가 마련되어 있다.

### 4.4.1 내장 생성자

- 자바스크립트에서 사용할 수 있는 생성자에는 기본적으로 내장되어 있는 '내장 생성자'가 있다.
- 목록은 추후 작성



### 4.4.2 Date 생성자

- Date 생성자는 대표적인 내장 생성자로 날짜와 시간을 표현하는 객체를 생성하낟.

  ```js
  var now = new Date();
  ```

  위 문장을 실행할 시 실행한 시점의 날짜와 시간 정보를 담은 객체를 생성하고, 그 객체의 참조를 변수 now에 대입한다.

  ```js
  console.log(now);	//-> Date {Tue Aug 01 2017 09:41:54 GMT+0900 (KST)}
  ```

- Date 생성자의 인수로 날짜와 시간을 전달하면 그 날짜와 시간을 가리키는 Date 객체가 생성된다.

  ```js
  var then = new Date(2008, 5, 10);
  console.log(then);	// -> Date {Tue Jun 10 2008 00:00:00 GMT+0900 (KST)}
  ```

- Date 객체는 계산식 안에서 밀리초 단위 정수로 값의 타입이 바뀐다.

  ```
  var elapsed = new - then;
  console.log(elapsed);	//-> 245177916548
  ```

  이를 활용해 프로그램 실행에 걸리는 시간을 밀리초 단위로 구할 수 있다.

  ```js
  var start = new Date();
  /* 실행 시간을 측정할 코드를 작성하는 위치*/
  var end = new Date();
  var elapsed = end - start;
  ```

- 다음은 Date 객체가 제공하는 주요 메서드이다.(추후 작성)



### 4.4.3 Function 생성자

- 함수를 생성하는 내장 생성자

  ```js
  var square = new Function("x", "return x * x");
  ```

  첫 번째 인자인 "x"는 인수의 이름을 뜻하는 문자열이고 두 번째 인수는 함수 몸통이 작성된 문자열이다. 인수가 여러 개일 때는 인수 여러 개를 정렬 후 함수 몸통을 작성한다.

- Function 생성자로 생성한 함수는 전역 변수와 자신의 지역 변수만 읽고 쓸 수 있다는 단점이 있어 함수를 동적으로 생성해야 하는 상황 외에는 사용하지 않는다.

- 함수 리터럴에 래퍼 객체(5.3.2 참조)를 제공한다.

- 함수를 다룰 때 중요한 프로퍼티와 메서드가 정의되어 있으며, 이를 모든 함수에서 사용할 수 있다.



### 4.4.4 기타 내장 객체

- **내장 객체**: 내장되어 있는 객체로 내장 생성자로 생성한다.

  | 내장 객체 | 설명                                    | 설명하는 장 | 비고 |
  | --------- | --------------------------------------- | ----------- | ---- |
  | 전역 객체 | 프로그램 어디에서나 사용할 수 있는 객체 | 13장        |      |
  | JSON      | JSON을 처리하는 기능을 제공             | 9장         |      |
  | Math      | 수학적인 함수와 상수를 제공             | 5장         |      |
  | Reflect   | 프로그램의 흐름을 가로채는 기능을 제공  | -           | ES6  |

  

### 4.4.5 전역 객체

- 프로그램의 어느 위치에서나 사용 가능한 객체. 아래는 전역 객체의 프로퍼티이다.

  | 분류          | 프로퍼티                             | 설명하는 장 |
  | ------------- | ------------------------------------ | ----------- |
  | 전역 프로퍼티 | undefined, NaN, Infinity             | 13장        |
  | 생성자        | Object(), String(), Number() 등      | 9장         |
  | 전역 함수     | parseInt(), parseFloat(), isNaN() 등 | 5장         |
  | 내장 객체     | Math, JSON, Reflect                  | -           |

- 클라이언트 측 자바스크립트에서는 Window 객체가 전역 객체이다. 웹 브라우저의 전역 객체 프로퍼티는 콘솔에서 다음과 같이 입력하여 확인할 수 있다

  ```js
  console.dir(window);
  ```



### 4.4.6 자바스크립트 객체의 분류

##### 네이티브 객체

ECMAScript 사양에 정의된 객체로 내장 생성자로 생성된 객체와 JSON, Math, Reflect 등이 해당한다.

##### 호스트 객체

자바스크립트 실행 환경에 정의된 객체로 브라우저 객체(Window, Navigator, History, Location 등), DOM에 정의되어 있는 객체, Ajax를 위한 XMLHttpRequest 객체, HTML5의 각종 API 등이 클라이언트 측 자바스크립트에 정의된 호스트 객체의 예이다.

##### 사용자 정의 객체

사용자가 정의하고 생성한 객체



## 4.5 배열의 기초

### 4.5.1 배열 리터럴로 생성하기

- 배열 리터럴은 쉼표로 구분한 값을 대괄호로 묶어서 표현한다.

  ```js
  var evens = [ 2, 4, 6, 8];
  ```

  대괄호 부분이 배열 리터럴이며 배열 값 하나를 배열 요소라고 부른다.  배열 요소에는 왼쪽부터 순서대로 0부터 번호가 매겨져 있으며 요소에 매긴 번호는 **요소 번호** 또는 **인덱스**라고 부른다.

- 자바스크립트의 배열은 객체 타입이므로 배열을 변수에 대입하면 배열의 참조가 변수에 저장된다. 즉, 위 코드에선 변수 evens가 배열의 참조를 가지고 있는 것이다.

- 배열 리터럴 안에 요소를 작성하지 않으면 빈 배열이 생성된다.

  ```js
  var empty = [];
  console.log(empty);	// -> []
  ```

- 배열 리터럴 요소의 값을 생략하면 그 요소는 생성되지 않는다.

  ```js
  var a = [2, , 4];
  console.log(a);	// -> [ 2, undefined, 4]
  ```

  위 코드에서 인덱스가 1인 요소에 undifined가 표시되어 있지만 실제로는 존재하지 않는 것이다.

- 배열의 요소에는 변수와 마찬가지로 모든 타입의 값이 올 수 있다.

  ```js
  var various = [ 3.14, "pi", true, {x:1, y:2}, [2,4,6,8]]
  ```



### 4.5.2 length 프로퍼티

- length 프로퍼티에는 배열 요소의 최대 인덱스 값 + 1이 담겨 있다.

  ```js
  var evens = [2,4,6,8];
  evens.length;	// -> 4
  ```

  즉, 배열의 길이를 나타내는 것이다.

- 자바스크립트에서는 배열의 길이가 배열 요소의 개수를 뜻하지 않는 경우가 있으므로 주의해야 한다.(4.5.7 참조)

- length 프로퍼티에 현재의 배열 요소 개수보다 작고 0보다 큰 정수 값을 대입하면 배열 길이가 줄어든다. 설정한 배열 길이의 값보다 더 큰 인덱스 번호에 할당된 배열 요소는 삭제된다.

  ```js
  var a = ["A", "B", "C", "D"];
  a.length = 2;
  console.log(a);	// -> ["A", "B"]
  ```

- 반대로 현재의 length 프로퍼티에 현재의 배열 요소 개수보다 큰 값을 대입하면 length 프로퍼티의 값만 바뀐다.



### 4.5.3 Array 생성자로 생성하기

- 배열은 Array 생성자로 생성할 수 있다.

  ```js
  var evens = new Array(2,4,6,8);
  var empty = new Array();
  var a = new Array(2,4);
  var various = new Array(3.14, "pi", true, {x:1, y:2}, [2,4,6,8]);
  ```

- Array 생성자의 인수가 한 개이고 그 값이 양의 정수이면 인수는 배열의 길이를 의미하게 되어 그 길이만큼의 배열이 생성된다.

  ```js
  var x = new Array(3);
  console.log(x.length); // -> 3
  ```

  반면 인수가 한 개이고 그 값이 양의 정수가 아니면 오류가 발생한다.



### 4.5.4 배열 요소의 참조

- 특정 인덱스의 요소는 대괄호 연산자를 사용해서 읽거나 쓸 수 있다.

  ```js
  evens[2]	//	인덱스가 2인 요소. 즉, 세 번째 요소
  ```

- 배열 요소 하나는 변수 하나로 사용할 수 있다.



### 4.5.5 배열은 객체

- C나 Java에선 배열 요소가 메모리의 연속된 공간에 차례대로 배치되어 있어 인덱스를 지정할 시 인덱스가 가리키는 요소를 매우 빠르게 읽거나 쓸 수 있다.

- 하지만 자바스크립트의 배열은 Array 객체이며 객체로 배열의 기능을 가상으로 흉내 낸 것이다.

- Array 객체는 배열의 인덱스를 문자열로 변환해서 그것을 프로퍼티로 이용한다. 즉, 배열에 대괄호 연산자를 사용하는 것은 객체에 대괄호 연산자를 사용하는 것과 마찬가지이며, 배열의 요소 번호로 숫자 값 대신 문자열을 사용할 수도 있다.

  ```js
  var a = ["A", "B", "C", "D"];
  console.log(a["2"])	// -> C
  ```

  이 때 없는 배열 요소를 읽으려고 하면 undefined가 반환된다.

  ```js
  a[4] // -> undefined
  ```

  

### 4.5.6 배열 요소의 추가와 삭제

- 없는 배열 요소에 값을 대입하면 새로운 요소가 추가된다.

  ```js
  var a = ["A", "B", "C"];
  a[3] = "D";
  console.log(a);	//	-> ["A", "B", "C", "D"];
  ```

- push 메서드 사용 시 요소를 배열 끝에 추가할 수 있다.

  ```js
  var a = ["A", "B", "C"];
  a.push("D");
  console.log(a);	//	-> ["A", "B", "C", "D"];
  ```

- delete 연산자를 사용하면 특정 배열 요소를 삭제할 수 있다.

  ```js
  delete a[1];
  console.log(a);	//	-> ["A", undefined, "C", "D"]
  ```

  이 때 그 배열의 length 프로퍼티 값은 바뀌지 않는다.



### 4.5.7 희소 배열

- 배열에 요소를 추가하거나 제거했을 때 인덱스가 0부터 시작되지 않는 배열

  ```js
  var a = ["A", "B", "C"];
  a[4]="E";
  console.log(a); // -> ["A", "B", "C", undefined, "E"]
  ```

  위 코드의 결과를 보면 a[3]이 undefined라고 표시되지만 실제로 저 요소는 존재하지 않는다.

- 때문에 희소 배열의 길이는 배열 요소의 개수보다 크다.

