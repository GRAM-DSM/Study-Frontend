[TOC]

# 1장 자바스크립트의 개요

## 1.1 프로그래밍 언어로서의 자바스크립트

### 1.1.1 프로그래밍 언어

#### 프로그래밍 언어의 정의

- **프로그래밍 언어**: 컴퓨터 프로그램을 작성하기 위한 언어 = 소프트웨어의 동작(알고리즘)을 설명하는 언어
- **프로그래밍**: 프로그램을 개발하는 행위
- **소스 코드(코드)**: 프로그래밍 언어로 작성한 프로그램



#### 컴파일 언어와 인터프리터 언어

- **컴파일**: 소스 코드를 기계어로 번역하는 행위
- **컴파일러**: 컴파일을 수행하는 소프트웨어
- **컴파일 언어**: 소스 코드 여러 개를 하나로 묶어서 컴파일한 후에 실행하는 프로그래밍 언어. 컴파일 시 시간이 소모되지만 실행되는 속도는 빠르다. C, C++, Java 등
- **인터프리터 언어**: 프로그램을 한 줄마다 기계어로 번역해서 실행하는 프로그래밍 언어. 자바스크립트, Python, Ruby 등이 있다. 한 줄 한 줄 동작을 확인해 가면서 프로그램을 개발할 수 있지만 처리 속도가 느림.
- **인터프리터**: 프로그램을 번역해서 실행시키는 소프트웨어.



#### 프로그래밍 언어의 유형

프로그램을 만들어 가는 방식에 따른 프로그래밍 언어의 분류

- **절차적 언어**: 절차를 순서대로 작성해 나가는 프로그래밍 언어
- **객체 지향 언어**: 문제 해결에 관련된 데이터와 절차를 하나로 묶어 객체 단위로 관리하는 프로그래밍 언어
- **함수형 언어**: 프로그램을 함수를 조합하여 구현해 나가는 프로그래밍 언어
- **논리형 언어**: 데이터 사이의 관계와 논리를 설명해 나가는 프로그래밍 언어



### 1.1.2 자바스크립트의 특징

- **1. 인터프리터 언어이다.**
  - 인터프리터 언어이면서 JIT 컴파일러라는 자바스크립트 컴파일러가 웹 브라우저에 내장되어 있어 실행 속도도 매우 빠름
- **2. 동적 프로토타입 기반 객체 지향 언어이다.**
  - 프로토타입을 상속하는 프로토타입 기반 객체 지향 언어로 객체를 생성한 후에도 프로퍼티와 메서드를 동적으로 추가하거나 삭제할 수 있다.
- **3. 동적 타입 언어이다.**
  - 변수 타입이 없어 프로그램의 실행 도중에 변수에 저장되는 데이터 타입이 동적으로 바뀐다.
- **4. 함수가 일급 객체이다.**
  - 자바스크립트의 함수는 객체이며, 함수에 함수를 인수로 넘길 수 있다.
- **5. 함수가 클로저를 정의한다.**
  - 자바스크립트의 함수는 클로저를 정의한다. 클로저는 변수를 은닉하거나 영속성을 보장하는 등 다양한 기능을 구현할 수 있다.

### 1.1.3 자바스크립트의 기술적 요소

- **ECMAScript(코어 언어)**

  - 자바스크립트의 핵심 기술으로 ECMA라는 조직의 TC-39 위원회가 표준화 작업을 하고 있고, ECMA-262라는 문서로 공개하고 있다. 최신 버전은 ECMAScript 8이다. 

- **클라이언트 측의 고유한 기술 요소**

  - 웹 브라우저에서 동작하는 자바스크립트를 클라이언트 측 자바스크립트라 한다. 이는 ECMAScript가 규정한 코어 언어와 웹 브라우저의 API로 구성되어 있다. 웹 브라우저의 주요 API는 다음과 같다.

    | 명칭              | 기능                                                        |
    | ----------------- | ----------------------------------------------------------- |
    | Window 인터페이스 | 자바스크립트로 브라우저 또는 창을 조작하는 기능을 제공한다. |
    | DOM               | 자바스크립트로 HTML 문서의 요소를 제어하는 기능을 제공한다. |
    | XMLHttpRequest    | 서버와 비동기로 통신하는 기능을 제공한다.                   |

  - HTML5에 규정된 다양한 API도 사용할 수 있다.
  
    | 명칭             | 기능                                                         |
    | ---------------- | ------------------------------------------------------------ |
    | Drag and Drop    | HTML 요소 혹은 파일을 끌어서(드래그) 다른 HTML 요소에 놓을 때(드롭) 데이터를 전달하는 기능을 제공한다. |
    | Blob             | 이진 데이터를 다루는 기능을 제공한다.                        |
    | File             | 로컬 파일 시스템을 읽고 쓸 수 있는 기능을 제공한다.          |
    | WebWorkers       | 프로그램 여러 개를 멀티스레드로 병렬 처리하는 기능을 제공한다. |
    | Wdb Storage      | 대용량이며 저장 기간에 제한이 없는 데이터를 로컬에 저장하는 기능을 제공한다. |
    | Indexed Database | 로컬에 키-값(key-value) 타입의 관계형 데이터베이스 기능을 제공한다. |
    | WebSockets       | 서버와의 양방향 통신 기능을 제공한다.                        |
    | Geolocation      | GPS 등의 위치 정보를 다루는 기능을 제공한다.                 |
    | Canvas           | 2차원, 3차원 그래픽스 기능을 제공한다.                       |
  
- **서버 측 자바스크립트의 고유한 기술 요소**

  - *서버 측 자바스크립트*: 웹 서버에서 동작하는 자바스크립트
  - 아래는 서버 측 자바스크립트 실행 환경에 있는 구현체
    - **Node.js**: 구글이 개발한 자바스크립트 실행 환경
    - **Rhino**: 오픈 소스로 개발되어 현재는 모질라가 관리하고 있는 자바스크립트 실행 환경
    - **Aptana Jaxer**: 압타나(Aptana) 사가 개발하고 현재는 오픈 소스로 개발되고 있는 자바스클비트 실행 환경

### 1.1.4 ECMScript 6

- 새로운 ECMAScript 버전. ECMScript 2015라고도 한다.

- 아래는 이 버전에서 새로 추가된 주요 기능들이다.

  | 새로 추가된 기능                      | 키워드                                          | 장    |
  | ------------------------------------- | ----------------------------------------------- | ----- |
  | 템플릿 리터럴                         | 보간 표현식, 태그가 지정된 템플릿 리터럴        | 3,8장 |
  | Symbol                                | 유일무이한 불변 데이터 타입                     | 3,9장 |
  | 블록 범위                             | let 선언자, const 선언자                        | 4장   |
  | Math, Number, Strinng의 새로운 메소드 | 기능 향상, 유니코드 대응                        | 5장   |
  | 화살표 함수                           | 함수 정의의 약식 표기                           | 8장   |
  | 함수 매개변수에 추가된 기능           | 기본 매개변수, 나머지 매개변수                  | 8장   |
  | 이터레이터/제너레이터                 | 반복처리의 추상화, for/of 문                    | 8장   |
  | 객체 리터럴에 추가된 기능             | 계산된 프로퍼티 이름, 프로퍼티 정의의 약식 표기 | 9장   |
  | Object에 추가된 메소드                | assign, getOwnPropertySymbols 등                | 9장   |
  | 비구조화 할당                         | 배열과 객체의 값을 별도의 변수에 할당하기       | 10장  |
  | 전개 연산자                           | 반복이 가능한 객체를 배열 등에 할당하기         | 10장  |
  | Map, Set, WeakMap, WeakSet            | 컬렉션 타입 객체                                | 10장  |
  | ArrayBuffer와 형식화 배열             | 연속된 데이터 영역 이용하기                     | 10장  |
  | Array에 추가된 메소드                 | copyWithin, fill, entities 등                   | 10장  |
  | 정규 표현식에 추가된 메소드           | u 플래그, y 플래그, flags 프로퍼티              | 12장  |
  | Promise                               | 비동기 처리를 간략하게 작성하기                 | 15장  |
  | 클래스                                | 클래스 구문과 상속                              | 18장  |
  | 모듈                                  | import.export를 사용한 모듈 읽기와 내보내기     | -     |
  | Proxy, Reflect                        | 객체에 액세스할 때 처리를 추가하기              | -     |
  | 꼬리 재귀 최적화                      | 재귀 함수의 스택 오버플로우 해결하기            | -     |

  

# 2장 프로그램의 작성법과 실행법

## 2.1 실습 준비하기

### 2.1.1 웹 브라우저와 Node.js 설치하기

- 크롬과 Node.js 설치



### 2.1.2 텍스트 편집기 준비하기

- 메모장으로도 가능하지만 프로그램 작성용 편집기나 통합 개발 환경 설치가 편리



### 2.1.3 확장자를 표시하도록 설정하기

- 시작 메뉴에서 파일 탐색기를 선택하고 보기 탭의 파일 확장명을 체크한다.



## 2.2 간단한 예제

```javascript
function fact(n){
	if(n<=1) return n;
	return n*fact(n-1);
}
for(var i=1; i<10; i++){
	console.log(i+"!=" + fact(i));
}
```



## 2.3 프로그램 실행법

### 2.3.1 웹 브라우저의 콘솔에서 실행하기

**개발자 도구 켜기**

 윈도우 : ctrl + shift + I

**콘솔에서 프로그램 실행하기**

- shift + enter로 여러 줄을 입력하여 프로그래밍을 할 수 있다.

  

### 2.3.2 HTML 문서에 삽입하여 웹 브라우저로 실행하기

- HTML 문서 내에 자바스크립트 프로그램을 삽입하려면 <script> 요소를 사용하면 된다.
- 순수 자바스크립트 프로그램을 실행할 땐 script 요소를 body 요소에 배치하는 것이 좋다. 반대로 HTML 요소와 CSS 스타일을 제어할 때는 script 요소를 head 요소의 자식 요소로 배치하는 것이 좋다.(6장 참고)
- 위 예제를 html 문서에 삽입하고 console.log를 document.write로 바꾸면 출력 결과를 웹 페이지의 창 안에서 확인할 수 있다. 단 괄호 안의 부분에 + "< br / >"을 해주어야 줄바꿈이 적용된다.

##### 다른 자바스크립트 파일에 작성하기

- 자바스크립트 코드가 길어지면 위의 방법은 전체 HTML을 읽는 것에 불편함을 주므로 다른 파일에 자바스크립트 파일을 따로 만들어 주는 것이 좋다.

- <script src="./파일명.js"></script>의 방식으로 HTML 문서에 js 파일을 불러들일 수 있다.

### 2.3.3 Node.js에서 실행하기

- 명령 프롬프트를 사용하여 Node.js를 실행할 수 있다. 
- 디렉토리와 파일을 다루는 방법을 알고 있어야 사용 가능하다.

**Node.js의 대화형 모드로 실행하기**

- 명령 프롬프트에 node를 입력하여 Node.js를 대화형 모드(REPL)로 실행시킨다.

- 사용 방법은 크롬 콘솔과 큰 차이가 없다. 계산식을 입력하고 enter를 누르면 계산 결과가 표시된다.

- 자바스크립트 명령도 입력할 수 있다.

  ```js
  console.log("Hello, world!");
  ```

  위의 console.log()는 표준 출력(화면)에 괄호 안의 값을 표시한다.

- 프로그램을 아래와 같이 작성하면 Node.js가 자동으로 여러 줄을 입력하도록 해준다.

  ```js
  function fact(n){
  	if(n<=1) return n;
  	return n*fact(n-1);
  }
  ```

  개행을 한 채로 enter 키를 누르면 여러 줄 모드로 전환된다.

- ctrl c를 누르면 위의 여러 줄 모드를 강제로 해제할 수 있다.

- 편집기 모드를 활용하여 입력할 수 있다. .editor를 입력하면 된다.

  ```
  > .editor
  // Entering editor mode (^D to finish, ^C to cancel)
  function fact(n){
  	if(n<=1) return n;
  	return n*fact(n-1);
  }
  ```

- Node.js의 대화형 모드를 종료하려면 .exit를 입력하거나 ctrl c를 연속 두 번 누르면 된다.

**Node.js로 파일을 읽어 들여 실행하기**

- 규모가 큰 프로그램도 텍스트 편집기로 작성하거나 편집한 후에 실행시킬 수 있다는 장점이 있다.
- 예시: factorial.js가 gilbut이라는 유저의 js_study라는 디렉터리 안에 저장되어 있다. 아래의 방법들로 js 파일을 호출하고 이동할 수 있다.
  1. cd js_study 	(js_study 디렉토리로 이동)
  2. cd (현재의 디렉토리를 표시)
  3. dir (현재 디렉토리 안에 저장된 파일 목록을 표시)
  4. dir *.js (현재 디렉토리 안의 js 확장자를 지닌 파일의 목록을 표시)
- node 파일의 경로를 입력하면 Node.js에서 파일을 읽어 들일 수 있다. (ex: node factorial.js)



## 2.4 프로그램 작성법

### 2.4.1 문자 코드

- 자바스크립트 프로그램은 유니코드 문자로 작성한다.

### 2.4.2 대문자와 소문자

- 자바스크립트 프로그램은 알파벳 대문자와 소문자를 구별한다.

### 2.4.3 토큰과 공백 문자

##### 토큰

- **토큰**: 프로그램을 구성하는 최소 단위 (ex: 영어 문장의 경우 토큰=단어 I love you.의 경우 'I', 'love', 'you', '.'으로 분해된다. 즉, 토큰은 의미를 가지는 최소한의 문자 덩어리이다.) (ex: return n*fact(n-1);을 토큰으로 나누면 'return', 'n', 'fact', '(', 'n', '-', '1', ')', ';'처럼 된다.)
- **어휘 분석**: 자바스크립트 인터프리터가 프로그램 실행 전 프로그램을 토큰으로 분해하는 동작
- **구문 분석(파싱)**: 분해된 토큰들을 한 줄로 나열하고 이것을 자바스크립트의 구문 규약에 비추어 보았을 때 올바른 프로그램인지 판별하는 동작

##### 공백 문자

- 인접한 토큰을 공백 등에 넣지 않고 나열만 한다면 토큰을 판별할 수 없다.(ex: return n을 공백 없이 입력하면 returnn이 되어 return과 n을 하나의 토큰으로 인식한다.)
- 때문에 토큰과 토큰 사이에 공백 문자를 입력하여 구분한다.
- 공백 문자는 연속하여 입력해도 하나로 인식된다.

##### 공백 문자 생략하기

- 산술 연산자 앞뒤의 공백 문자, (){}[]와 같은 괄호 앞뒤의 공백 문자, 세미콜론(;), 쉼표(,), 콜론(:), 마침표(.) 앞뒤의 공백 문자는 생략할 수 있다.
- 위와 같은 토큰들은 **분리자 또는 구분자**라고 불린다.

##### 프로그램 가독성 높이기

- 사람들이 코드를 알아보기 쉽게 코드를 짜는 것을 프로그램의 가독성을 높인다고 한다. 아래의 예시를 보자.

  ```js
  function fact(n) {if(n<=1)return n;return n*fact(n-1);}
  
  function fact(n){
  	if(n<=1) return n;
  	return n*fact(n-1);
  }
  ```

### 2.4.4 문장

##### 문장

- 토큰을 나열한 후 세미콜론으로 마무리 짓는다. 아래는 여러 의미를 지닌 문장들이다.

  ```js
  console.log(i+"! = "+fact(i)); //괄호 안의 값을 콘솔에 출력
  var x; //변수 선언
  message = "Hi, "+name; // 표현식의 대입
  counter++; //변수 값 증가
  prompt("이름을 입력하십시오") // 함수 호출
  ```

##### 복합문

- 문장 여러 개를 중괄호({})로 감싼 코드를 복합문 또는 블록문이라고 한다.

  ```js
  {
  	sum = sum + x;
  	console.log("sum = "+x);
  }
  ```

- 복합문의 끝에는 세미콜론을 붙이지 않는다.

- 복합문 내의 문장은 중괄호를 기준으로 들여쓰기를 할 수 있다. 이는 프로그램의 가독성을 높히는 과정에 해당된다.

##### 빈 문장

- 문장이 하나도 없는 빈 문장이다. 이 문장이 쓰이는 경우는 7장에서 작성할 것이다.

  ```js
  ;
  ```

##### 세미콜론 자동 추가

- 문장을 작성하고 다음 줄에 문장을 작성하면 앞 문장 끝에 세미콜론이 없어도 자바스크립트 엔진이 자동으로 세메콜론을 추가하여 해석한다.

  ```js
  console.log("Hello")
  console.log("Hi")
  
  console.log("Hello");
  console.log("Hi");
  ```

- 단, 세미콜론을 생략한 줄이 다음 줄과 이어지고 있다고 판단하면 세미콜론은 자동으로 추가되지 않는다.

  ```js
  c = a+b
  (x+y).toString()
  
  c = a+b(x+y).toString();
  ```

- 세미콜론 자동 삽입 규칙에서 예외 처리 되는 것들이 있는데, return 문, break 문, continue 문이 있다.

  ```js
  return
  
  1;
  
  
  
  return;
  
  1;
  ```

### 2.4.5 주석

- 프로그램의 소스 코드에 삽입하는 설명문
- /* 주석문 */, // 주석문 의 2가지의 형식으로 주석문을 만들 수 있다. 
- /* 주석문 */의 형식은 코드의 토큰을 분할하지 않는 임의의 위치에 작성할 수 있다. 또한 여러 줄로 나누어 작성해도 문제가 발생하지 않고 줄 중간에 삽입할 수도 있다.
- // 주석문은 각 줄의 끝에 작성할 수 있다.



# 3장 변수와 값

## 3.1 변수

### 3.1.1 변수

- 값을 담는 저장 공간으로 각각의 변수에게 이름을 붙여야 한다.



### 3.1.2 변수 선언

- 자바스크립트에서 변수를 선언하려면 아래와 같이 작성해야 한다.

  ```js
  var 변수이름;
  ```

- 위 코드의 var은 자바스크립트의 키워드로 변수를 선언하기 위한 선언자이다. 이외에도 let, const라는 선언자가 있다.

- 자바스크립트에는 변수 타입이 존재하지 않아 모든 데이터 타입(정수, 문자 등)의 값을 저장할 수 있다.

- 쉼표를 사용하면 변수 여러 개를 한 개의 문장으로 선언할 수 있다.

  ```js
  var sum, a;
  ```

- 변수를 선언하기만 하고 값을 저장하지 않으면 변수 안에는 정의되지 않았음을 뜻하는 undefined라는 값이 들어간다.

  ```js
  var x;
  console.log(x); // -> undefined
  ```

- 등호를 사용해 변수에 값을 대입할 수 있다.

  ```js
  x = 2;
  ```

- 변수 선언과 동시에 초깃값을 설정할 수도 있다.

  ```js
  var x = 5;
  ```

- 위를 응용하면 다중 변수 선언과 동시에 초깃값을 설정할 수도 있다.

  ```js
  var a=1, b=2, c=3;
  ```



### 3.1.3 변수 선언 생략

- 선언되지 않은 변수 값을 읽으려고 시도하면 참조 오류가 발생한다.

  ```js
  console.log(x); // -> ReferenceError: x is not defined(오류 메시지)
  ```

- 그러나 var 문으로 선언하지 않은 변수에 값을 대입할 때는 오류가 발생하지 않는다. 이는 자바스크립트 엔진이 그 변수를 자동으로 **전역 변수**로 선언해주기 때문이다.

  ```js
  x = 2;
  console.log(x); // -> 2
  ```

  허나 이런 행위는 버그의 원인이 될 수 있으므로 변수는 반드시 선언하고 사용해야 한다.



### 3.1.4 변수 끌어올림과 변수 중복 선언

- 프로그램은 작성한 순서에 따라 윗줄부터 차례대로 실행되지만 변수 선언은 이 원칙을 따르지 않는다. 아래의 예시 코드를 참조하자

  ```js
  console.log(x);	// -> undefined
  var x;
  ```

  이처럼 프로그램 중간에서 변수를 선언하더라도 변수가 프로그램 시작점에 선언된 것처럼 다른 문장 앞에 생성되는 현상을 **변수 선언의 끌어올림(hoisting)**이라고 한다.

- 단, 선언과 동시에 대입을 할 경우 변수는 끌어 올려지지만 변수의 값은 끌어지지 않는다. var x =5;라는 문장이 있으면 var x만 끌어 올려지고 x=5는 분리되는 것이다.

  ```js
  console.log(x); // -> undefined
  var x = 5;
  console.log(x); // -> 5
  ```

- var 문으로 같은 이름을 가진 변수를 여러 개 선언하더라도 오류가 발생하지 않는다. 이는 같은 이름으로 선언된 변수 모드를 끌어올린 후에 단 하나의 영역에만 할당되기 때문이다.



### 3.1.5 변수의 명명 규칙

- 변수, 함수, 라벨 이름 등 사용자가 정의하는 이름을 식별자라고 한다. 이를 정할 땐 다음의 규칙을 준수해야 한다.
  - 사용할 수 있는 문자에는 알파벳(a~z, A~Z), 숫자(0~9), 언더바(_), 달러 기호($)가 있다.
  - 식별자의 첫 글자는 숫자 사용이 불가하다.
  - 예약어를 식별자로 사용할 수 없다.(예약어는 3.1.6 예약어 참조)
- 프로그램의 크기가 커질수록 변수도 많아지므로 변수 이름을 짓는 표기법을 따라 작성하면 변수의 의미(역할)을 쉽게 알 수 있다. 표기법은 아래와 같다.
  - **캐멀 표기법(로어 캐멀 표기법)**: 변수명이 2개 이상의 단어일 때, 두 번째 이후 단어의 첫 글자를 대문자로 표기하고 나머지는 소문자로 표기한다.(ex: newName	createLifeGame)
  - **파스칼 표기법(어퍼 캐멀 표기법)**: 각 단어의 첫 글자를 대문자로 표기하고 나머지는 소문자로 표기한다.(ex: NewName	CreateLifeGame)
  - **밑줄 표기법(스네이크 표기법)**: 모든 단어를 소문자로 표기하고 단어를 언더바로 구분한다.(ex: new_name	create_life_game)
- 아래는 변수 이름을 지을 때 일반적으로 사용하는 표기법이다.
  - 위에 명시된 표기법을 사용한다.
  - 기본적으로 영어 **단어**를 사용한다.
  - 루프 카운터 변수 이름으로는 i, j, k 등을 사용한다.
  - 상수는 대문자로 표현한다. ex) MAX_SIZE
  - 논리값(3.2.5 참조)을 표현하는 변수에는 이름 앞에 is를 붙인다. ex)isMouseDown
  - 생성자(4.3 참조) 이름을 붙일 때는 파스칼 표기법을 사용한다.



### 3.1.6 예약어

- **예약어**: 자바스크립트 문법을 규정짓기 위해 자바스크립트 언어 사양에서 사용하는 특수한 키워드(var 등)
- 쓰지 말아야할 예약어에는 예악어, 예약어가 될 키워드, 자바스크립트에 미리 정의된 전역 변수와 전역 함수가 있다.



## 3.2 데이터 타입

### 3.2.1 데이터 타입과 변수의 동적 타이핑

- **데이터 타입**: 변수에 저장하는 데이터의 종류(정수, 문자열 등)
- **정적 타입 언어**: 변수의 타입(정수 타입 변수, 부동소주점 타입 변수 등)과 일치하는 데이터만 저장할 수 있는 언어. C나 Java 등이 있다.
- **동적 타입 언어**: 실행 시 변수에 저장된 데이터 타입을 동적으로 바꿀 수 있는 언어. 자바스크립트가 이에 해당된다.



### 3.2.2 데이터 타입의 분류

##### 원시 타입

- 숫자, 문자열, 논리값, 특수한 값(undefined)과 심벌(symbol)이 이 타입에 속한다.
- 데이터를 구성하는 가장 기본적인 요소로 불변 값(값을 바꿀 수 없는 데이터, 리터럴)으로 정의되어 있다.

##### 객체 타입

- 변수 여러 개가 모여 만들어진 복합 데이터 타입
- 객체에 저장된 값은 바꿀 수 있다.
- 객체는 참조 타입으로 객체 타입의 값을 변수에 대입하면 변수에는 그 객체에 대한 참조(메모리에서의 위치 정보)가 할당된다.
- 배열, 함수, 정규 표현식 등이 있다.



### 3.2.3 숫자

- 자바스크립트에서 모든 숫자는 64비트 부동소수점으로 표현된다.

- 표현 가능한 최댓값과 최솟값은 다음과 같다.

  - 최댓값: 1.7976931348623157e+308
  - 최댓값: 4.940656458412465e-324

- 정수 값은 -2e+53 ~ 2e+53 범위의 값을 처리할 수 있다.

- 단, 배열 인덱스 값과 비트 연산은 32비트로 처리한다.

- **리터럴**: 프로그램에 직접 작성할 수 있는 상수 값.

- 아래는 특수한 숫자를 표현하기 위한 문자열이다.

  | 분류              | 표기법                   | 설명                               | 비고 |
  | ----------------- | ------------------------ | ---------------------------------- | ---- |
  | 전역 변수         | Infinity                 | 플러스 무한대                      |      |
  | 전역 변수         | NaN                      | 부정 값(숫자가 아님, Not a Number) |      |
  | Number의 프로퍼티 | Number.POSITIVE_INFINITY | 플러스 무한대                      |      |
  | Number의 프로퍼티 | Number.NEGATIVE_INFINITY | 마이너스 무한대                    |      |
  | Number의 프로퍼티 | Number.MAX_VALUE         | 표현할 수 있는 최댓값              |      |
  | Number의 프로퍼티 | Number.MIN_VALUE         | 표현할 수 있는 최솟값              |      |
  | Number의 프로퍼티 | Number.NaN               | 부정 값                            |      |
  | Number의 프로퍼티 | Number.EPSILON           | 2.220446049250313-16               | ES6  |
  | Number의 프로퍼티 | Number.MIN_SAFE_INTEGER  | -9007199254740990                  | ES6  |
  | Number의 프로퍼티 | Number.MAX_SAFE_INTEGER  | 9007199254740990                   | ES6  |

   

### 3.2.4 문자열

- **문자열 리터럴**: 프로그램에 직접 문자열을 작성한다. 작은따옴표('')나 큰따옴표("")를 문자열의 앞뒤에 붙여서 표현한다.

- "", ''처럼 빈 문자열을 만들 수도 있다.

- 자바스크립트를 HTML 요소에 끼워 넣을 때는 자바스크립트 프로그램을 문자열로 작성한다.

  ```html
  <input type="button" value="Click" onclick="alert('Thanks!')"
  ```

  위 상황에서는 HTML 코드에는 큰따옴표를 사용하고 자바스크립트 코드에는 작은따옴표를 사용하여 둘을 구분해주는 것이 좋다.

- 줄 바꿈 문자와 탭 문자 등은 문자열에 그대로 추가할 수 없다. 이러한 특수문자들은 아래의 이스케이프 시쿼스로 표현해야 한다.

  | 이스케이프 시퀀스 | 의미                                             | 비고 |
  | ----------------- | ------------------------------------------------ | ---- |
  | \0                | 널 문자                                          |      |
  | \b                | 백스페이스 문자                                  |      |
  | \t                | 수평 탭 문자                                     |      |
  | \n                | 개행 문자                                        |      |
  | \v                | 수직 탭 문자                                     |      |
  | \f                | 다음 페이지 문자                                 |      |
  | \r                | 캐리지 리턴 문자                                 |      |
  | \ '               | 작은따옴표 문자                                  |      |
  | \ "               | 큰따옴표 문자                                    |      |
  | \ \               | 역슬래시 문자                                    |      |
  | \xXX              | 두 자릿수 16진수 XX로 지정된 Latin-1 문자        |      |
  | \uXXXX            | 네 자릿수 16진수 XXXX로 지정된 유니코드 문자     |      |
  | \u{XXXXXX}        | 16진수 코드 포인트 XXXXXX로 지정된 유니코드 문자 | ES6  |



### 3.2.5 논리값

- 조건식이 참인지 거짓인지 표현하기 위해 사용하는 값.
- true, false로 구분된다.



### 3.2.6 특수한 값

- **값이 없음**을 표현하기 위한 특수한 값으로 null과 undefined가 있다.
- undefined는 정의되지 않은 상태를 뜻하며 다음과 같은 상황에 값이 undefined로 설정된다.
  - 값을 할당하지 않은 변수의 값
  - 없는 객체의 프로퍼티를 읽으려고 시도했을 때의 값
  - 없는 배열의 요소를 읽으려고 시도했을 때의 값
  - 아무것도 반환하지 않는 함수가 반환하는 값
  - 함수를 호출했을 때 전달받지 못한 인수의 값
- null은 아무것도 없음을 값으로 표현한 리터럴이다.



## 3.3 ECMAScript 6부터 추가된 데이터 타입

### 3.3.1 심벌

- ES6부터 새로이 추가된 원시 값이다.

- 자기 자신을 제외한 그 어떤 값과도 다른 유일한 값이다.

  ##### 심벌의 생성

  - Symbol()을 사용해서 생성한다.

    ```js
    var sym1 = Symbol();
    ```

  - Symbol()은 호출할 때마다 새로운 값을 만든다. 아래의 코드에서 sym1과 sym2의 값은 다르다.

    ```js
    var sym1 = Symbol();
    var sym2 = Symbol();
    ```

  - Symbol()에 인수를 전달하면 생성된 심벌의 설명을 덧붙일 수 있다.

    ```js
    var HEART = Symbol("하트"); // Symbol(하트)
    ```

  ##### 심벌과 문자열 연결하기

  - Symbol.for()를 활용하면 문자열과 연결된 심벌을 생성할 수 있다.

    ```js
    var sym1 = Symbol.for("club");
    ```

  - 전역 레지스트리에서 만들어진 심벌을 위에서 지정한 문자열로 불러올 수 있다.

    ```js
    var sym2 = Symbol.for("club");
    console.log(sym1 == sym2); //->true
    ```

  - 심벌과 연결된 문자열은 Symbol.keyFor()로 구할 수 있다.

    ```js
    var sym1 = Symbol.for("club");
    var sym2 = Symbol("club");
    console.log(Symbol.keyFor(sym1)); //->club
    console.log(Symbol.keyFor(sym2)); //->undefined
    ```

### 3.3.2  템플릿 리터럴

- 문자열 표현 구문이다.

- **템플릿**: 일부만을 변경하여 반복하거나 재사용할 수 있는 틀

- 템플릿 리터럴을 통해 표현식의 값을 문자열에 추가하거나 여러 줄의 문자열을 표현할 수 있다.

  ##### 기본적인 사용법

  - 템플릿 리터럴은 문자열을 역따옴표(`)로 묶어주면 사용할 수 있다.

    ```js
    `I'm going to learn Javascript.`
    ```

  - 템플릿 리터럴은 문자열 리터럴과 달리 일반적인 줄 바꿈 문자를 사용할 수 있게 해준다.

    ```js
    var t = `Man errs as long as 
    he strives.`; //템플릿 리터럴
    
    var t = `Man errs as long as\nhe strives.`; //문자열 리터럴 
    ```

    단, 문자열 리터럴처럼 이스케이프 시퀸스를 사용할 수도 있다.

    ```
  var t = `Man errs as long as
    he strives.`;
    ```
  
    
  
- 이스케이프 시퀀스 문자를 그대로 출력하려면 템플릿 리터럴 앞에 String.raw를 붙이면 된다.
  
  ```js
    var t = String.raw`Man errs as long as\nhe strives.`;
  
    var t = `Man errs as long as\\nhe strives.`;
  ```
  
  이 String.raw를 **태그 함수**라고 한다.
  
  ##### 보간 표현식
  
  - 템플릿 리터럴 안에는 **플레이스 홀더**를 넣을 수 있다. ${...}로 표기한다.
  
  - 플레이스 홀더 안의 ... 부분을 표현식으로 간주하여 평가한다. 이를 활용하여 문자열 안에 변수나 표현식의 결괏괎을 삽입할 수 있다.
  
    ```js
    var a = 2, b = 3;
    console.log(`${a} + ${b} = ${a+b}`); // -> 2 + 3 = 5
    var now = new Date();
    console.log(`오늘은 ${now.getMonth()+1} 월 ${now.getDate()}일입니다.`);
    // -> 오늘은 8 월 1 일입니다.
    ```




# 4장 객체와 배열, 함수의 기초

## 4.1 객체의 기초 1번 객체 리터럴

### 4.1.1 객체

- **객체**: 객체는 이름과 값을 한 쌍으로 묶은 데이터를 여러 개 모은 것이다. 즉, 복합 데이터로 **연관 배열** 또는 **사전**이라고도 부른다.
- 객체에 포함된 데이터 하나(이름과 값의 쌍)를 가리켜 객체의 **프로퍼티**라고 한다. 이 프로퍼티의 이름을 프로퍼티 이름 또는 키라고 부른다.
- 객체는 객체 리터럴을 사용하거나 생성자라는 함수를 사용하여 생성할 수 있다.

### 4.1.2 객체 리터럴로 객체 생성하기

- ```js
  var card = { suit: "하트", rank: "A"};
  ```

  위의 예시에서 {...} 부분이 객체 리터럴이다.

- 키와 프로퍼티 값은 콜론(:)을 사용하여 구분하고 프로퍼티들은 쉼표로 구분한다.

- 키로는 모든 식별자와 문자열 리터럴을 사용할 수 있다. 따라서 아래의 경우도 가능하다.

  ```js
  var card = { "suit": "하트", `rank`: "A"};
  ```

- 변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 마침표(.) 연산자 또는 대괄호 연산자를 사용한다.

  ``` js
  card.suit	// -> 하트
  card["rank"] 	// -> A
  ```

  마침표로 프로퍼티를 호출할 때는 키값만 사용할 수 있다. 허나 대괄호로 프로퍼티를 호출할 땐 키값 또는 문자열을 반환하는 표현식을 사용할 수 있다.

- 객체에 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환한다.

- 객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면 빈 객체가 생성된다.

  ```js
  var obj = {};
  console.log(obj);	// -> Object{}
  ```



### 4.1.3 프로퍼티 추가와 삭제

- 존재하지 않는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가된다.

  ```js
  var card = {};
  card.value = 14;
  console.log(card) // -> { value: 14 }
  ```

- delete 연산자를 사용하면 프로퍼티를 삭제할 수 있다.

  ```js
  delete card.value;
  console.log(card) // -> {}
  ```



### 4.1.4 in 연산자로 프로퍼티가 있는지 확인하기

- in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있다. 반환값은 true false이다.

- '프로퍼티 이름을 뜻하는 문자열 in 객체명'의 형식으로 사용한다.

  ```js
  var card = {suit: "하트", rank: "A"};
  console.log("suit" in card); // -> true
  console.log("color" in card); // -> false
  ```

- in 연산자는 객체가 가진 프로퍼티와 그 객체가 상속받은 모든 프로퍼티를 대상으로 조사한다.

  ```js
  console.log("toString" in card); // true
  ```

  위의 반환값이 true인 이유는 Object 객체를 card가 상속받았기 때문이다.



### 4.1.5 객체 리터럴 예제

아래는 객체 리터럴을 사용하는 예제들이다

1. ##### 좌표평면의 점을 표현하는 객체

   ```js
   var p = { x: 1.0, y: 2.5};
   ```

   

2. ##### 원을 표현하는 객체

   ```js
   var circle = { center: { x: 1.0, y: 2.0}, radius: 2.5};
   console.log(circle.center.x) // -> 1
   ```

   위 예제를 보면 객체의 프로퍼티 값으로 다른 객체를 대입할 수 있다는 것을 알 수 있다.

   

3. ##### 회원 정보를 표현하는 객체

   ```js
   var person = { name: "이정규", age: 18, sex: "남", married: false };
   ```



### 4.1.6 메서드

- 프로퍼티에 함수 타입의 값이 저장되어 있으면 그 프로퍼티를 메서드라고 한다.



### 4.1.7 객체는 참조 타입

- 객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 **참조**(메모리에서의 위치 정보)가 저장된다. 이 때의 변수 상태를 가리켜 객체를 참조하고 있다라고 한다.

  ```js
  var card = { suit: "하트", rank: "A"};
  ```

  위 코드에서는 변수 card가 객체를 참조하고 있다고 한다.

  ```js
  var a = card;
  ```

  card에는 객체의 참조가 저장되어 있는데, 이를 다른 변수에 저장할 수도 있다. 이 때 a를 통해 객체를 수정할 수 있다.

  ```js
  console.log(a.suit); // -> 하트
  a.suit = "스페이드";
  console.log(a.suit); // -> 스페이드
  console.log(card.suit); // -> 스페이드
  ```



## 4.2 함수의 기초

### 4.2.1 함수

- 어떠한 입력 값에 대해 출력 값을 주는 기능. 입력 값을 **인수**, 출력 값을 **반환값**이라고 부른다.



### 4.2.2 함수 선언문으로 함수 정의하기

- function 키워드로 정의한다.

  ```js
  function square(x) { return x * x; }
  ```



### 4.2.3 함수 이름

- 변수 이름과 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있다.
- 함수 이름은 일반적으로 함수의 기능을 알 수 있게 해주는 동사 또는 동사로 시작되는 어휘로 만든다.



### 4.2.4 함수 호출

- 함수를 호출할 땐 함수 이름 뒤에 소괄호로 인수를 묶어 입력한다.

  ```js
  square(3)	// -> 9
  ```

  이 때 인수로 넘긴 값인 3이 함수 정의문의 인수 x로 전달되어 중괄호를 거쳐 return 된다. 함수 호출 시에 전달되는 값을 인수, 함수 정의문의 인수를 인자라고 한다.



### 4.2.5 인수

- 인수는 여러 개로 받을 수도 있는데, 이 때 인수는 쉼표로 구분한다.

  ```js
  function dist(p, q){
  	var dx = q.x - p.x;
  	var dy = q.y - p.y;
  	return Math.sqrt(dx*dx+dy*dy);
  } // 두 점 사이의 거리를 구하는 함수 
  ```

  위의 Math.sqrt는 제곱근을 구하는 함수이다.

- 인수를 받지 않는 함수도 정의할 수 있다.

  ```js
  var bark = function() { console.log("Bow-wow");};
  
  bark(); // "Bow-wow"
  ```

  위 코드엔 인수도 return문도 존재하지 않아 제어권이 함수를 호출한 코드로 되돌아가면 함수의 반환값이 undefined가 된다.

  ```js
  console.log(bark()); // -> Bow-wow \n undefined
  ```



### 4.2.6 함수의 실행 흐름

1. 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다.
2. 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다.
3. return 문이 실행되면 호출한 코드로 돌아간다. 이 때 return의 값이 반환값이 된다.
4. return 문이 실행되지 않은 상태로 마지막 문장이 실행되면, undefined가 반환된다.



### 4.2.7 함수 선언문의 끌어올림

- 함수 선언문은 변수 선언문처럼 프로그램의 첫머리로 끌어올려진다.

  ```js
  console.log(square(5)); // -> 25
  function square(x) { return x * x; }
  ```



### 4.2.8 값으로서의 함수

- 자바스크립트에서는 함수가 객체이다. 함수 선언문으로 함수를 선언하면 내부적으로는 함수 이름을 변수 이름으로 한 변수와 함수 객체가 만들어지고, 그 변수에 함수 객체의 참조가 저장된다.

- 즉, 위 예제에선 변수 square가 함수 객체를 참조하고 있는 것이다. 

- 이 변수 값을 다른 변수에 할당하면 그 변수 이름으로 함수를 실행할 수 있다.

  ```js
  function square(x) { return x * x; }
  var sq = square;
  console.log(sq(5)); // -> 25
  ```

- 함수는 다른 함수의 인수로도 넘길 수 있다.



### 4.2.9 참조에 의한 호출과 값에 의한 호출

- 함수의 인수가 원시 값이냐 객체냐에 따라 동작하는 과정이 다르다.

- **원시 값**

  ```js
  function add1(x) { return x = x + 1; }
  var a = 3;
  var b = add1(a);
  console.log("a= ", + a + ", b = " + b); // -> a=3, b=4
  ```

  위 함수에서 인자 x는 변수 a의 복사본이다. 즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달된다. 이를 **값의 전달**이라고 부른다.

- **객체**

  ```js
  function add1(p) { p.x= p.x + 1; .y = p.y + 1; return p; }
  var a={x:3, y:4};
  var b=add1(a);
  console.log(a,b); // -> Object {x=4, y=5} Object {x=4, y=5}
  ```

  위 코드에서는 a가 객체의 참조를 저장하고 있기 때문에 p에 객체의 참조가 전달되고, 함수를 통해 객체가 수정되면서 a와 b가 같게 되는 것이다.

- ##### 인수 여러 개를 우아하게 전달하는 방법(elegant way)

  - 함수에 넘겨야 하는 인수 개수가 많아지면 

    - 인수의 순서를 착각하거나 
    - 함수가 받는 인수의 개수를 바꿨을 때 함수의 호출 방법이 바뀌어 프로그램 전체를 수정하는 등

    의 문제가 발생한다. 

    이러한 문제는 객체의 프로퍼티에 인수를 담아서 넘기는 방법으로 해결할 수 있다.

    ```js
    function setBallProperties(x, y, vx, vy, radius) {...}
    ...
    setBallProperties(0,0,10,15,5);
    //아래는 수정한 방법
    var parameters = {
    	x:0,
    	y:0
    	vx:10,
    	vy:15,
    	radius:5
    };
    
    function setBallProperties(params) { ... }
    ...
    setBallProperties(parameters);
    ```

    단, 함수 아나에서 객체의 프로퍼티를 수정한다면 호출한 코드에 있는 인수 객체의 프로퍼티가 함께 바뀌는 점을 주의해야 한다.



### 4.2.10 변수의 유효 범위

##### 전역 유효 범위와 지역 유효 범위

- **유효 범위**: 각 변수에 접근할 수 있는 범위.

- **어휘적 범위**: 프로그램의 구문으로 유효 범위를 정하는 방법. 자바스크립트는 어휘적 범위를 채택하였다.

- **동적 범위**: 프로그램 실행 중 유효 범위를 정하는 방법.

- 자바스크립트 변수는 변수의 유효 범위에 따라 **전역 변수**와 **지역 변수**로 나뉜다.

- **전역 변수**는 함수 바깥에서 선언된 변수로 유효 범위가 프로그램 전체이다.

- **지역 변수**는 함수 안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부이다.

- ```js
  var a = "global";
  function f(){
  	var b = "local";
  	console.log(a); // -> "global"
  	return b;
  }
  f();
  console.log(b); // -> 에러 발생
  ```

  위의 코드에서 a는 전역 변수, b는 지역 변수이다.



##### 변수의 충돌

- 변수의 유효 범위는 각기 다른 부분에 있는 같은 이름의 변수가 충돌하지 않게 해준다.

- 때문에 전역 변수와 지역 변수의 이름이 같다면 충돌을 일으키게 된다.

- 전역 변수와 지역 변수 이름이 같다면 지역 변수를 사용하게 된다.

  ```js
  var a = "global";
  function f() {
  	var a = "local";
  	console.log(a); // -> local
  	return a;
  }
  f();
  console.log(a);	// -> global
  ```



##### 함수 안에서의 변수 선언과 변수 끌어올림

- 함수 안에서 선언된 지역 변수의 유효 범위는 함수 전체이다. 변수 끌어올림은 함수 내에서 적용된다.

  ```js
  function f() {
  	console.log(a); // 선언은 되었지만 값은 적용되지 않음 -> undefined 
  	var a = "local";
  	console.log(a); // -> local
  	return a;
  }
  ```

  



##### 함수 안에서의 변수 선언 생략

3.1.3에서 언급했듯이 변수를 선언하지 않고 값만 대입하면 자동으로 전역 변수로 선언된다. 이 현상은 함수 안에서도 발생한다.

```js
function f() {
	a = "local";
	console.log(a); // ->local
	return a;
}
f();
console.log(a); // -> local
```



### 4.2.11 블록 유효 범위 : let과 const

- 블록 유효 범위를 갖는 변수를 선언한다.
- 블록 유효 범위를 가진 변수는 중괄호 안에서만 유효하다.
- let은 변수 선언, const는 한 번만 할당 가능한 상수를 선언한다.

- ##### let 선언자

  - 블록 유효 범위를 갖는 지역 변수를 선언한다. 사용법은 var 문과 같다.

    ```js
    let x = "outer x";
    {
    	let x = "inner x";
    	let y = "inner y";
    	console.log(x); // -> inner x
    	console.log(y); // -> inner y
    }
    console.log(x);	// -> outer x
    console.log(y); // -> 에러 발생
    ```

  - let 문은 var 문과 달리 끌어올리는 현상이 발생하지 않고, 중복되는 변수를 선언하면 하나로 통일하지 않고 오류로 처리한다.

    ```js
    console.log(x); // -> 에러 발생
    let x = 5;
    ```

    ```js
    let x;
    let x; // 문법 오류	
    ```

- ##### const 선언자

  - 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다. 동작 규칙은 let 문과 동일하지만 반드시 초기화를 해야한다는 차이점이 있다.

    ```js
    const c = 2;
    c = 5; // -> 타입 에러
    ```

    const 문으로 선언한 변수에 다시 대입을 시도하면 위처럼 타입 오류가 발생한다. 그러나 상수 값이 객체이거나 배열일 경우에서 프로퍼티 또는 프로퍼티 값을 수정할 수 있다.

    ```js
    const origin = {x:1, y:2};
    origin.x = 3;
    console.log(origin); // -> Object {x:3, y:2}
    ```



### 4.2.12 함수 리터럴로 함수 정의하기

- 함수 리터럴을 통해 함수를 정의할 수 있다.

  ```js
  var square = function(x) { return x * x; };
  ```

  위 코드에서 function(x) {...} 부분이 함수 리터럴이다.

- 함수 리터럴은 이름이 없는 함수로 익명 함수 또는 무명 함수라고도 부른다.

- 함수 리터럴에는 끝에 세미콜론을 반드시 붙여야 한다.

- 함수 리터럴의 사용법은 함수와 같이 square(5)의 형식으로 사용하면 된다. 이는 두 함수 모두 내부적으로 square 변수에 함수 객체의 참조를 저장하기 때문이다.

- 함수와 함수 리터럴의 차이는 각각 끌어올려지느냐 아니냐의 차이이다.

  ```js
  console.log(square(3)); // 에러 발생
  var square = function(x) { return x * x; };
  ```

- 익명 함수에도 이름을 붙일 수 있다.

  ```js
   var square = function sq(x) { return x * x; };
  ```

  그러나 sq라는 이름은 함수 안에서만 유효하다. 이름이 없는 것과 있는 것의 차이는 디버거에서 이름으로 표시되느냐 anonymous function으로 표현되느냐의 차이를 지니고 있다.



### 4.2.13 객체의 메서드

- 객체의 프로퍼티 중 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 **메서드**라고 부른다.

- 메서드를 정의할 때는 프로퍼티 값으로 함수 리터럴을 대입한다.

  ```js
  var circle = {
  	center: { x:1.0, y:2.0 },
  	radius: 2.5,
  	area: function(){	// 원의 넓이를 구하는 메서드
  		return Math.PI * this.radius * this.radius;
  	}
  };
  ```

  함수 객체 안의 this는 그 함수를 메서드로 가지고 있는 객체를 가리킨다.

- 메서드는 일반 함수와 바찬가지로 소괄호를 붙여서 실행한다.

  ```js
  circle.area() // -> 19.63495...
  ```

- 메서드 또한 프로퍼티의 일종으로 나중에 추가할 수 있다. 위의 객체에 아래의 메서드를 추가할 수 있다.

  ```js
  circle.translate = function(a, b) {
  	this.center.x = this.center.x + a;
  	this.center.y = this.center.y + b;
  };
  ```

  ```js
  circle.translate(1,2);
  cercle.center; // -> Object {x=2, y=4}
  ```

- 이처럼 메서드는 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용한다. 일반적인 객체 지향 언어에서는 데이터와 그 상태를 바꾸는 메서드를 하나로 묶는 용도로 객체를 사용한다.



### 4.2.14 함수를 활용하면 얻을 수 있는 장점

##### 재사용할 수 있다

동일한 작업 반복을 함수 호출만으로 같은 작업을 여러 번 반복할 수 있다.

##### 만든 프로그램을 이해하기 쉽다

프로그램이 간결해지므로 프로그램의 흐름을 파악하기 쉬워진다.

##### 프로그램 수정이 간단해진다

똑같은 수정을 여러 반복할 필요가 없어지기 때문에 프로그램 수정이 간단해진다.



## 4.3 객체의 기초 2번 생성자

### 4.3.1 생성자로 객체 생성하기

- 자바, c++ 등은 다수의 객체를 생성하는 수단으로 클래스를 사용하지만 자바스크립트는 클래스가 없어 생성자라고 하는 함수로 객체를 생성한다.

##### 간단한 예

- 아래는 트럼프 카드를 표현하는 객체를 생성하는 생성자이다.

```js
function Card(suit, rank) {
	this.suit = suit;
	this.rank = rank;
}
```

- 생성자로 객체를 생성할 때는 new 연산자를 사용한다.

  ```js
  var card = new Card("하트", "A");
  ```

- 위 코드 실행 시 suit 프로퍼티에는 "하트", rank 프로퍼티에는 "A"라는 값이 저장된 객체가 생성되고, 그 객체의 참조가 변수 card에 할당된다.

  ```js
  console.log(card); // -> Card { suit: "하트", rank: "A"}
  ```

  이때 Card 생성자로 생성한 객체를 Card 객체라고 부른다.

##### 생성자

- 위처럼 new 연산자로 객체를 생성할 것이라 기대하고 만든 함수를 생성자라고 부른다.

- 생성자명은 관례적으로 첫 글자를 대문자로 쓰는 파스칼 표기법을 사용한다.

- 생성자 안에서 **this.프로퍼티 이름**에 값을 대입하면 그 이름을 가진 프로퍼티에 값이 할당된 객체가 생성된다. 위의 생성자는 아래의 객체 리터럴과 같다.

  ```js
  var card = {};
  card.suit = "하트";
  card.rank = "A";
  ```

- 생성자와 new 연산자로 생성한 객체를 그 생성자의 **인스턴스(실체)**라고 부른다. 객체 지향 언어에서 인스턴스는 클래스로 생성한 실체를 뜻하므로 엄밀히 말해 생성자로 생성한 객체는 아니지만 역할이 동일하므로 인스턴스라고 부른다.

##### 생성자의 역할

- 생성자는 객체를 생성하고 초기화하는 역할을 한다. 생성자를 사용하면 이름은 같지만 프로퍼티 값이 다른 객체(인스턴스) 여러 개를 간단히 생성할 수 있다.

  ```js
  var card1 = new Card("하트", "A");
  var card2 = new Card("클럽", "K");
  var card3 = new Card("스페이드", "2");
  ```

- 생성자는 함수이므로 프로퍼티에 값을 대입할 수 있다. 이를 활용하면 객체를 생성할 때 초기화 작업을 병행할 수 있다.

  ```js
  function Particle(x, y, vx, vy){
  	this.x = x;
  	this.y = y;
  	this.vx = vx;
  	this.vy = vy;
  	this.velocity = Math.sqrt(vx * vx + vy * vy);
  }
  var p = new Particle(0, 0, 3, 4);
  console.log(p); // -> Particle {x:0, y:0, vx:3, vy:4, velocity:5}
  ```



### 4.3.2 메서드를 가진 객체를 생성하는 생성자

- 생성자에서 **this.프로퍼티 이름**에 함수의 참조를 대입하면 메서드를 정의할 수 있다. 이때 메서드 함수 내부에 있는 this는 생성될 인스턴스를 가리킨다.

  ```js
  function Circle(center, radius) {
  	this.center = center;
  	this.radius = radius;
  	this.area = function() {
  		return Math.PI * this.radius * this.radius;
  	};
  }
  var p = {x:0, y:0};
  var c = new Circle(p, 2.0);
  console.log("넓이 = " + c.area()); // -> 넓이 = 12.56637...
  ```

  메서드 함수 안에서 this를 사용하면 그 값이 인스턴스의 프로퍼티임을 명시할 수 있다.



## 4.4 객체의 기초 3번 내장 객체

- 자바스크립트에는 내장되어 있는 객체가 마련되어 있다.

### 4.4.1 내장 생성자

- 자바스크립트에서 사용할 수 있는 생성자에는 기본적으로 내장되어 있는 '내장 생성자'가 있다.
- 목록은 추후 작성



### 4.4.2 Date 생성자

- Date 생성자는 대표적인 내장 생성자로 날짜와 시간을 표현하는 객체를 생성한다.

  ```js
  var now = new Date();
  ```

  위 문장을 실행할 시 실행한 시점의 날짜와 시간 정보를 담은 객체를 생성하고, 그 객체의 참조를 변수 now에 대입한다.

  ```js
  console.log(now);	//-> Date {Tue Aug 01 2017 09:41:54 GMT+0900 (KST)}
  ```

- Date 생성자의 인수로 날짜와 시간을 전달하면 그 날짜와 시간을 가리키는 Date 객체가 생성된다.

  ```js
  var then = new Date(2008, 5, 10);
  console.log(then);	// -> Date {Tue May 10 2008 00:00:00 GMT+0900 (KST)}
  ```

- Date 객체는 계산식 안에서 밀리초 단위 정수로 값의 타입이 바뀐다.

  ```
  var elapsed = new - then;
  console.log(elapsed);	//-> 245177916548
  ```

  이를 활용해 프로그램 실행에 걸리는 시간을 밀리초 단위로 구할 수 있다.

  ```js
  var start = new Date();
  /* 실행 시간을 측정할 코드를 작성하는 위치*/
  var end = new Date();
  var elapsed = end - start;
  ```

- 다음은 Date 객체가 제공하는 주요 메서드이다.(추후 작성)



### 4.4.3 Function 생성자

- 함수를 생성하는 내장 생성자

  ```js
  var square = new Function("x", "return x * x");
  ```

  첫 번째 인자인 "x"는 인수의 이름을 뜻하는 문자열이고 두 번째 인수는 함수 몸통이 작성된 문자열이다. 인수가 여러 개일 때는 인수 여러 개를 정렬 후 함수 몸통을 작성한다.

- Function 생성자로 생성한 함수는 전역 변수와 자신의 지역 변수만 읽고 쓸 수 있다는 단점이 있어 함수를 동적으로 생성해야 하는 상황 외에는 사용하지 않는다.

- 함수 리터럴에 래퍼 객체(5.3.2 참조)를 제공한다.

- 함수를 다룰 때 중요한 프로퍼티와 메서드가 정의되어 있으며, 이를 모든 함수에서 사용할 수 있다.



### 4.4.4 기타 내장 객체

- **내장 객체**: 내장되어 있는 객체로 내장 생성자로 생성한다.

  | 내장 객체 | 설명                                    | 설명하는 장 | 비고 |
  | --------- | --------------------------------------- | ----------- | ---- |
  | 전역 객체 | 프로그램 어디에서나 사용할 수 있는 객체 | 13장        |      |
  | JSON      | JSON을 처리하는 기능을 제공             | 9장         |      |
  | Math      | 수학적인 함수와 상수를 제공             | 5장         |      |
  | Reflect   | 프로그램의 흐름을 가로채는 기능을 제공  | -           | ES6  |

  

### 4.4.5 전역 객체

- 프로그램의 어느 위치에서나 사용 가능한 객체. 아래는 전역 객체의 프로퍼티이다.

  | 분류          | 프로퍼티                             | 설명하는 장 |
  | ------------- | ------------------------------------ | ----------- |
  | 전역 프로퍼티 | undefined, NaN, Infinity             | 13장        |
  | 생성자        | Object(), String(), Number() 등      | 9장         |
  | 전역 함수     | parseInt(), parseFloat(), isNaN() 등 | 5장         |
  | 내장 객체     | Math, JSON, Reflect                  | -           |

- 클라이언트 측 자바스크립트에서는 Window 객체가 전역 객체이다. 웹 브라우저의 전역 객체 프로퍼티는 콘솔에서 다음과 같이 입력하여 확인할 수 있다

  ```js
  console.dir(window);
  ```



### 4.4.6 자바스크립트 객체의 분류

##### 네이티브 객체

ECMAScript 사양에 정의된 객체로 내장 생성자로 생성된 객체와 JSON, Math, Reflect 등이 해당한다.

##### 호스트 객체

자바스크립트 실행 환경에 정의된 객체로 브라우저 객체(Window, Navigator, History, Location 등), DOM에 정의되어 있는 객체, Ajax를 위한 XMLHttpRequest 객체, HTML5의 각종 API 등이 클라이언트 측 자바스크립트에 정의된 호스트 객체의 예이다.

##### 사용자 정의 객체

사용자가 정의하고 생성한 객체



## 4.5 배열의 기초

### 4.5.1 배열 리터럴로 생성하기

- 배열 리터럴은 쉼표로 구분한 값을 대괄호로 묶어서 표현한다.

  ```js
  var evens = [ 2, 4, 6, 8];
  ```

  대괄호 부분이 배열 리터럴이며 배열 값 하나를 배열 요소라고 부른다.  배열 요소에는 왼쪽부터 순서대로 0부터 번호가 매겨져 있으며 요소에 매긴 번호는 **요소 번호** 또는 **인덱스**라고 부른다.

- 자바스크립트의 배열은 객체 타입이므로 배열을 변수에 대입하면 배열의 참조가 변수에 저장된다. 즉, 위 코드에선 변수 evens가 배열의 참조를 가지고 있는 것이다.

- 배열 리터럴 안에 요소를 작성하지 않으면 빈 배열이 생성된다.

  ```js
  var empty = [];
  console.log(empty);	// -> []
  ```

- 배열 리터럴 요소의 값을 생략하면 그 요소는 생성되지 않는다.

  ```js
  var a = [2, , 4];
  console.log(a);	// -> [ 2, undefined, 4]
  ```

  위 코드에서 인덱스가 1인 요소에 undifined가 표시되어 있지만 실제로는 존재하지 않는 것이다.

- 배열의 요소에는 변수와 마찬가지로 모든 타입의 값이 올 수 있다.

  ```js
  var various = [ 3.14, "pi", true, {x:1, y:2}, [2,4,6,8]]
  ```



### 4.5.2 length 프로퍼티

- length 프로퍼티에는 배열 요소의 최대 인덱스 값 + 1이 담겨 있다.

  ```js
  var evens = [2,4,6,8];
  evens.length;	// -> 4
  ```

  즉, 배열의 길이를 나타내는 것이다.

- 자바스크립트에서는 배열의 길이가 배열 요소의 개수를 뜻하지 않는 경우가 있으므로 주의해야 한다.(4.5.7 참조)

- length 프로퍼티에 현재의 배열 요소 개수보다 작고 0보다 큰 정수 값을 대입하면 배열 길이가 줄어든다. 설정한 배열 길이의 값보다 더 큰 인덱스 번호에 할당된 배열 요소는 삭제된다.

  ```js
  var a = ["A", "B", "C", "D"];
  a.length = 2;
  console.log(a);	// -> ["A", "B"]
  ```

- 반대로 현재의 length 프로퍼티에 현재의 배열 요소 개수보다 큰 값을 대입하면 length 프로퍼티의 값만 바뀐다.



### 4.5.3 Array 생성자로 생성하기

- 배열은 Array 생성자로 생성할 수 있다.

  ```js
  var evens = new Array(2,4,6,8);
  var empty = new Array();
  var a = new Array(2,4);
  var various = new Array(3.14, "pi", true, {x:1, y:2}, [2,4,6,8]);
  ```

- Array 생성자의 인수가 한 개이고 그 값이 양의 정수이면 인수는 배열의 길이를 의미하게 되어 그 길이만큼의 배열이 생성된다.

  ```js
  var x = new Array(3);
  console.log(x.length); // -> 3
  ```

  반면 인수가 한 개이고 그 값이 양의 정수가 아니면 오류가 발생한다.



### 4.5.4 배열 요소의 참조

- 특정 인덱스의 요소는 대괄호 연산자를 사용해서 읽거나 쓸 수 있다.

  ```js
  evens[2]	//	인덱스가 2인 요소. 즉, 세 번째 요소
  ```

- 배열 요소 하나는 변수 하나로 사용할 수 있다.



### 4.5.5 배열은 객체

- C나 Java에선 배열 요소가 메모리의 연속된 공간에 차례대로 배치되어 있어 인덱스를 지정할 시 인덱스가 가리키는 요소를 매우 빠르게 읽거나 쓸 수 있다.

- 하지만 자바스크립트의 배열은 Array 객체이며 객체로 배열의 기능을 가상으로 흉내 낸 것이다.

- Array 객체는 배열의 인덱스를 문자열로 변환해서 그것을 프로퍼티로 이용한다. 즉, 배열에 대괄호 연산자를 사용하는 것은 객체에 대괄호 연산자를 사용하는 것과 마찬가지이며, 배열의 요소 번호로 숫자 값 대신 문자열을 사용할 수도 있다.

  ```js
  var a = ["A", "B", "C", "D"];
  console.log(a["2"])	// -> C
  ```

  이 때 없는 배열 요소를 읽으려고 하면 undefined가 반환된다.

  ```js
  a[4] // -> undefined
  ```

  

### 4.5.6 배열 요소의 추가와 삭제

- 없는 배열 요소에 값을 대입하면 새로운 요소가 추가된다.

  ```js
  var a = ["A", "B", "C"];
  a[3] = "D";
  console.log(a);	//	-> ["A", "B", "C", "D"];
  ```

- push 메서드 사용 시 요소를 배열 끝에 추가할 수 있다.

  ```js
  var a = ["A", "B", "C"];
  a.push("D");
  console.log(a);	//	-> ["A", "B", "C", "D"];
  ```

- delete 연산자를 사용하면 특정 배열 요소를 삭제할 수 있다.

  ```js
  delete a[1];
  console.log(a);	//	-> ["A", undefined, "C", "D"]
  ```

  이 때 그 배열의 length 프로퍼티 값은 바뀌지 않는다.



### 4.5.7 희소 배열

- 배열에 요소를 추가하거나 제거했을 때 인덱스가 0부터 시작되지 않는 배열

  ```js
  var a = ["A", "B", "C"];
  a[4]="E";
  console.log(a); // -> ["A", "B", "C", undefined, "E"]
  ```

  위 코드의 결과를 보면 a[3]이 undefined라고 표시되지만 실제로 저 요소는 존재하지 않는다.

- 때문에 희소 배열의 길이는 배열 요소의 개수보다 크다.



# 5장 표현식과 연산자

## 5.1 연산자

### 5.1.1 표현식과 연산자

- **표현식**: 결과적으로 *어떤 값*으로 평가되는 것. 이 평가한다는 말은 표현식의 값과 변수, 함수 등의 값을 바탕으로 식의 값을 계산하는 행위를 뜻한다. 표현식은 가장 간단한 원시 값부터 객체 값까지 모두 표현식이다.

  ```js
  3.14, "hello", true, false, null // 원시 값
  sum, circle.radius, a[3], square(5), card.getSum() // 객체 값
  ```

- **연산자**를 이용하면 표현식을 조합할 수 있다.

  ```js
  a+b
  ```

- 위 예시에서 +는 연산자, a와 b는 연산 대상이 되는 표현식이며, 이를 **피연산자**라고 한다.

- +연산자처럼 좌우에 피연산자 두 개를 가진 연산자를 이항 연산자라고 한다. 이처럼 연산자는 피연산자의 개수에 따라 단항, 이항, 삼항으로 구분한다. -부호는 단항에 속한다.

- 삼항 연산자는 **?:** 뿐이다.

- 표현식은 왼쪽 피연산자 값부터 순서대로 평가되고, 연산자로 계산이 시작된다.(단, 일부 연산자(||, &&, ?:)에는 예외가 적용된다. 이 연산자들은 먼저 평가된 후 피연산자들을 평가한다.)

- 위의 예시에서 a, b 값이 각각 2, 3이라면 예시의 표현식은 2 + 3으로 평가된 후 계산된다.



### 5.1.2 연산자의 우선순위

- 연산자에는 우선 순위가 있다. 우선 순위가 가장 높은 연산자는 **그룹 연산자 (괄호)**이다.



### 5.1.3 연산자 결합 법칙

- 우선순위가 같은 연산자가 나열되어 있으면 좌우 중 어느 연산자와 결합하느냐에 따라 결고가 달라진다.

  ```js
  24/6*2
  ```

- 연산자에는 위와 같은 상황에서 좌우 중 어느 연산자와 연산할지를 결정하는 결합 법칙이 정해져 있다. 이에 대해서는 아래 표에서 서술할 것이다.

- 우선순위가 같을 때에는 좌->우 방향으로 결합한다.



### 5.1.4 연산자의 부수 효과

- +연산자처럼 변수 값을 바꾸지 않는 연산자도 있지만 x = y처럼 대입하는 표현식은 변수의 값을 바꾼다. 이러한 표현식은 **부수 효과가 있는 표현식**이라고 한다. 대입 연산자(=), 증감 연산자(++, --), delete 연산자가 이에 해당한다.

- 아래의 표는 연산자의 우선순위와 각 연산자의 결합 볍칙을 정리한 표이다.

  | 우선순위 | 연산자                                                       | 결합 법칙    |
  | -------- | ------------------------------------------------------------ | ------------ |
  | 1        | ()(그룹 연산자)                                              | 없음         |
  | 2        | . []                                                         | 왼쪽->오른쪽 |
  |          | new(인수 있음)                                               | 오른쪽->왼쪽 |
  | 3        | ()(함수 호출)                                                | 왼쪽->오른쪽 |
  |          | new(인수 없음)                                               | 오른쪽->왼쪽 |
  | 4        | ++(후위), --(후위)                                           | 없음         |
  | 5        | !, ~, +(단항), -(부호 반전), typeof, voidm delete, ++(전위), --(전위) | 오른쪽->왼쪽 |
  | 6        | *, /, %                                                      | 왼쪽->오른쪽 |
  | 7        | +, -, +(문자열 결합)                                         | 왼쪽->오른쪽 |
  | 8        | <<, >>, >>>                                                  | 왼쪽->오른쪽 |
  | 9        | <, <=, >, >=, in instanceof                                  | 왼쪽->오른쪽 |
  | 10       | ==, !=, ===, !==                                             | 왼쪽->오른쪽 |
  | 11       | &                                                            | 왼쪽->오른쪽 |
  | 12       | ^                                                            | 왼쪽->오른쪽 |
  | 13       | \|                                                           | 왼쪽->오른쪽 |
  | 14       | &&                                                           | 왼쪽->오른쪽 |
  | 15       | \|\|                                                         | 왼쪽->오른쪽 |
  | 16       | ?:                                                           | 오른쪽->왼쪽 |
  | 17       | yield, yield*                                                | 오른쪽->왼쪽 |
  | 18       | =, +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=, \|=           | 오른쪽->왼쪽 |
  | 19       | ...                                                          | 없음         |
  | 20       | ,                                                            | 왼쪽->오른쪽 |

  

## 5.2 산술 연산

### 5.2.1 산술 연산자

- 피연산자가 숫자인 연산자이다.
- 피연산자가 숫자가 아니면 연산자가 피연산자 타입을 숫자 타입으로 바꾸어 연산한다. 이 때 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때는 NaN이 나온다.

#### 산술 이항 연산자

- +, -, *, /, %가 있다.

  - 아래는 산술 이항 연산자를 쓸 때 몇 가지 주의 사항이다.

    1. **정수끼리 나누어도 결과가 부동소수점이 된다**

    2. **나머지 연산자의 피연산자는 부동소주점이다.**

    3. **+ 연산자는 피연산자 중 하나가 문자열이면 나머지 피연산자도 문자열로 만든다**

    4. ```js
       0/0 // -> NaN : 계산할 수 없음
       "one" * 1 // -> NaN : 계산할 수 없음
       true + true // -> 2 : 논리값의 타입을 숫자로 바꾸어 더함
       1 + null // -> 1 : null을 0으로 바꾸어 더함
       1 + undefined // -> NaN : undifined를 NaN으로 바꾸어 더함
       ```



#### 산술 단항 연산자

- 전후위 ++, -- 연산자와 +(아무것도 처리하지 않음), -(부호 반전) 연산자가 있다.



#### 산술 대입 연산자

- 대입 연산자와 산술 이항 연산자를 조합한 연산자



### 5.2.2 Math 객체의 프로퍼티

- JS는 복잡한 수학적 연산을 Math 객체로 지원한다.(sin, cos 등)



### 5.2.3 부동소수점과 정확도 문제

- JS에서 사용하는 64비트 부동소수점의 규격은 부호 1비트, 지수 11비트, 가수 52비트이다. 즉, 2진수 53자리(10진수 약 16자리)만큼의 가수 부분의 표현할 수 있다.
- **정확도 문제**: 숫자를 자릿수가 정해진 부동소수점으로 표현하여 계산하면 발생하는 오류
- **정밀도 손실**: 값이 가까운 두 수를 뺄셈할 때 발생하는 정확도 문제
- 10진수로 딱 떨어지는 값도 산술 연산을 내부적으로 2진수로 연산한다는 점 때문에 계산 결과가 어긋날 수 있다.



## 5.3 문자열 제어하기

### 5.3.1 문자열 연결

- +연산자는 피연산자가 모두 문자열이면 문자열로, 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 후 연결한다.

  ```js
  10 + "little indians"	//	-> "10 little indians"
  1 + {}	// ->"1[object Object]"
  true + (new Date())	// -> "trueTue Sat Aug ..."
  ```

  위에 해당하지 않는 경우 피연산자를 상황에 따라 숫자 또는 NaN 타입으로 바꾸어 더한다.



### 5.3.2 문자열을 조작하는 메서드

- JS에서는 문자열을 다루는 데 사용하는 **String 객체**를 내장하고 있다. 사용법은 생성자와 같다.

  ```js
  var msgObj = new String("Everything is practice");
  ```

- String은 문자열을 객체로 변환해준다. 이와 같이 원시 값을 객체로 변환하는 행위를 **래핑**한다고 한다.

- String을 통해 객체로 변환한 문자열에는 배열처럼 인덱스 번호가 지정되어 있다.

- String 객체는 다양한 프로퍼티와 메서드를 지니고 있다. 예시로 charAt() 메서드는 문자열의 인덱스 번호를 인자로 받아 그 인덱스 번호에 해당하는 문자를 구하는 기능을 가지고 있다.

- 문자열은 객체가 아니므로 프로퍼티를 지니고 있지 않다.  그럼에도 String 생성자가 동작 가능한 이유는 문자열이 자동으로 String 객체로 변환되기 때문이다.

  ```js
  var c = 'msg'.charAt(2);
  
  //내부적으로 실행되는 작업
  var msgObj = new String('msg'); // 문자열을 String 객체로 변환
  var c = msgObj.charAt(2);
  ```

  위에서 msgObj 객체는 일시적으로 생성되고 작업이 끝나면 사라진다. 이러한 객체를 **래퍼 객체**라고 한다.

- 위 예제에서 문자열을 String 객체로 변환하지 않고 바로 메서드를 호출하는 이유는 String 객체부터가 원시 값이 들어올 것으로 가정하고 작성한 코드이기 때문이다. 때문에 바로 메서드를 호출해 원하는 작업이 처리 가능하다.



### 5.3.3 String 생성자의 메서드

- String 생성자는 JS의 타 함수처럼 프로퍼티를 지니고 있다.



### 5.3.4 문자열을 배열로 읽고 쓰기

- 문자열을 읽을 때는 charAt() 메서드 대신 대괄호 연산자를 사용할 수 있다.

  ```js
  a= 'mag'
  a[2]	// -> g
  a[a.length-1]	// -> g
  ```

- 다만 배열과는 다르게 값을 대입해서 수정할 수는 없다. 만약 값을 대입하려고 시도할 경우 무시한다.



## 5.4 논리 연산자와 관계 연산자

### 5.4.1 관계 연산자

- 관계 연산자는 두 개의 피연산자의 비교 결과를 논리값(t/f)로 반환한다. ==, !=, ===(값과 타입이 같음), !==(값과 타입이 다름), <, >, <=, >= 이 관계 연산자에 해당한다.

##### 동일 연산자

- 동일(==) 연산자는 두 피연산자가 같은지를 판별한다. 피연산자의 타입에 따라 작동 방식이 다르다.
  - **좌우 피연산자의 타입이 같을 때**: 값이 같으면 true, 다르면 false이다. 타입이 원시 타입일 때는 단순히 값을 비교하지만 객체 타입인 경우 참조가 같은지를 판별한다.
  - **좌우 피연산자의 타입이 다를 때**: 같은 타입이 되도록 타입을 변환한 후 아래 규칙에 따라 동일 여부를 판별한다.
    - undefined와 null은 같은 것으로 친다.
    - 한쪽이 숫자, 다른 쪽이 문자열이면 문자열을 숫자로 변환하여 비교한다.
    - 둘 중 한쪽이 논리값이면 true는 1, false는 0으로 변환하여 비교한다.
    - 한쪽이 객체, 다른 쪽이 숫자 또는 문자열이면 객체를 toString이나 valseOf 메서드를 사용하여 원시 타입으로 변환한 다음에 비교한다.

##### 일치 연산자

- 일치(===) 연산자는 두 피연산자의 타입과 값의 동일 여부를 판별해준다.
- NaN은 NaN을 포함한 모든 값과 같지 않다고 판별한다.



### 5.4.2 논리 연산자

- 논리 연산자는 더욱 복잡한 논리를 정의한다. &&(논리곱, and), ||(논리합, or), !(부정, not)이 이에 해당한다.

##### 피연산자의 평가

- 논리 연산자의 피연산자는 논리값(true, false)가 아니어도 된다. 필요에 따라 타입이 자동으로 변하기 때문이다.

##### 논리곱 연산자와 논리합 연산자의 단락 평가

- **단락 평가**: 첫 번째 피연산자 값이 표현식을 결정하면 두 번째 피연산자를 평가하지 않는다.

- &&와 ||는 논리값 대신에 마지막으로 평가한 피연산자의 값을 반환한다.

- 아래는 예시이다.

  ```js
  a && b
  ```

  논리곱은 피연산자 둘 중 하나만 거짓이여도 거짓으로 처리되기 때문에 a가 거짓일 경우 b를 평가하지 않고 표현식의 전체 값이 false 처리 된다. 이 때의 반환값은 false가 아닌 a의 값으로 처리된다. 논리 값이 필요한 경우에는 a 값이 아닌 논리값으로 변환되어 반환한다.

- ```js
  a || b
  ```

  논리합은 피연산자 둘 중 하나만 참이여도 참으로 처리되기 때문에 a가 참일 경우 b를 평가하지 않는다. 위와 같이 true 대신 a의 값 자체를 반환한다.



## 5.5 비트 연산

### 5.5.1 비트 연산

- **비트 연산**: 2진수 숫자의 자릿수 값(비트 값)을 다루는 연산. 

- 비트 연산자는 피연산자를 부호 있는 32비트 정수로 변환해서 처리한다. 

- 비트 연산자에는 비트 논리 연산자와 비트 시프트 연산자가 있다.



### 5.5.2 비트 논리 연산자

- 비트 논리 연산자는 비트 값이 0이면 false, 비트 값이 1이면 true로 평가한다. 논리곱(AND), 논리합(OR), 배타적 논리합(XOR), 논리 부정(NOT)이 있고, 각각의 비트끼리 계산한다.



### 5.5.3 비트 시프트 연산자 

- 비트 시프트 연산자는 정수를 2진수 비트 단위로 오른쪽 또는 왼쪽으로 이동시키는(시프트하는) 연산자이다. <<(왼쪽 시프트), >>(부호 있는 오른쪽 시프트), >>>(부호 없는 오른쪽 시프트)
- 왼쪽 시프트: 비트가 이동하면서 생긴 빈 자리는 0으로 채워지고 넘친 값은 버려진다.
- (부호)오른쪽 시프트: 비트가 이동하면서 생긴 좌측의 빈 자리는 부호 비트로 채워지고 넘친 우측 비트 값은 버려진다.
- 오른쪽 시프트: 비트가 이동하면서 생긴 빈 자리는 0으로 채워지고 넘친 값은 버려진다.



### 5.5.4 비트 연산의 대입 연산자

- 산술 연산자와 마찬가지로 비트 연산자와 대입 연산자를 합칠 수 있다. &=, |=, ^=, <<=, >>=, >>>=가 있다.



## 5.6 기타 연산

### 5.6.1 typeof 연산자

- 단항 연산자로 피연산자의 데이터 타입을 반환한다.

  ```js
  var s = "ABC";
  console.log(typeof s);	// -> string
  ```

- typeof 연산자는 피연산자가 함수 이외의 객체인 경우 모두 object를 반환한다. 함수는 function을 반환한다.



### 5.6.2 조건 연산자

- 조건(?:) 연산자는 주어진 조건의 참과 거짓에 따라 값을 선택한다.

  ```js
  var parity = (a % 2 == 0)? "짝수" : "홀수";
  ```

  콜론을 기준으로 조건이 참일 경우 앞의 값을 반환하고 거짓일 경우 뒤의 값을 반환한다.



### 5.6.3 쉼표 연산자

- 쉼표 연산자는 이항 연산자로 왼쪽의 피연산자부터 차례대로 평가한 후 오른쪽 끝의 피연산자의 값을 반환한다.

- ```js
  i = 0, sum = 0, product = 1;
  ```

  위 표현식의 결괏값은 마지막 피연산자를 평가한 값인 1이 된다. 단, 위 대입문들은 모두 정상적으로 실행된다.

- 쉼표 연산자의 특징(반환값은 하나이지만 대입문은 정상 실행)을 이용하여 for문에 활용할 수 있다.

  ```js
  for(var i = 1, sum = 0; i<=10; i++){
  	sum += i;
  }
  ```

  본래 for 문의 소괄호 안에는 문장을 세 개만 넣을 수 있지만 위 코드에서는 더 많은 문장을 실행하였다.



### 5.6.4 eval 함수

- eval은 함수이지만 연산자의 역할을 담당하고 있다.

  ```js
  var x = 1;
  eval("x++;");
  ```

  eval 함수는 문자열 하나를 인수로 받아 그 문자열을 자바스크립트 코드로 해석한다.

- eval 함수는 eval 함수를 호출한 환경의 유효 범위 내의 변수를 사용할 수 있다.



## 5.7 명시적 타입 변환

### 5.7.1 숫자를 문자열로 변환하기

##### 숫자 + 문자열

- 숫자와 문자열을 + 연산자로 연결하면 숫자의 타입이 문자열로 바뀌어 더해진다.

  ```js
  10 + "cookies"	// -> "10cookies"
  100 + ""	// -> "100"
  ```



##### Number 객체의 메서드를 활용하는 방법

- 문자열을 객체로 바꾸는데 String 생성자가 있듯이 숫자를 개체로 바꿀 땐 Number 생성자를 통해 Number 객체로 변환해줄 수 있다.
- 이 Number 객체의 메서드를 통해 숫자를 문자열로 변환할 수 있다.



##### 스트링 함수를 활용하는 방법

- String 생성자에 new 연산자를 붙이지 않으면 문자열을 반환하는 일반 함수가 된다.

  ```js
  String(26) // -> "26"
  ```



### 5.7.2 문자열을 숫자로 변환하기

##### 수식 안에서 묵시적으로 변환하는 방법

- ```js
  var s = "2";
  s-0	//	-> 2
  +s // -> 2
  ```



##### parseInt 와 parseFloat 함수를 사용하는 방법

- 두 함수는 문자열을 해석해서 숫자로 바꾸는 함수이다. parseInt 함수는 문자열을 정수로, parseFloat 함수는 문자열을 부동소수점으로 바꾼다.
- 두 함수 모두 맨 앞의 문자만 숫자로 바꾸어 반환한다. 그 뒤에 다른 문자들이 있다면 그 문자들은 모두 무시한다. 만약 문자열의 맨 처음 문자가 숫자로 변환할 수 없다면 NaN을 반환한다.



##### Number 함수를 활용하는 방법

- Number 생성자 앞에 new 연산자를 붙이지 않으면 반환값이 숫자인 일반 함수가 된다.
- 단, Number 함수는 10진수만 처리할 수 있다.



### 5.7.3 논리값으로 변환하기

- 모든 값을 논리값으로 바꾸는 방법은 아래 두 가지가 있다.

  ```js
  !!x
  Boolean(x)
  ```

  - 위 코드에서 !는 논리 타입이 아닌 값을 논리 타입으로 바꾸면서 논리 값을 반대로 바꾼다. 때문에 ! 연산자를 하나 더 사용하여 원래의 논리 값으로 복구하여 준다.



# 6장 웹 브라우저에서의 입출력

## 6.1 대화상자 표시하기

### 6.1.1 대화상자

- **대화상자**: 입력을 하거나 메시지를 확인하기 위해 별도로 여는 창
- 대화 상자에서는 일반 텍스트만 표기 가능하며 줄 바꿈 문자 등은 이스케이프 시퀀스로 표현한다.
- **modal window**: 자식 창이 실행 중인 동안 부모 창이 동작하지 않도록 하는 자식 창을 가리킴. 대화 상자는 이에 해당한다. 
- 웹 브라우저에는 전역 객체 Window가 있다. 이 Window 객체는 대화상자를 표시하기 위한 메서드가 3개 있다.
- Window 객체의 메서드는 앞에 붙는 window. 부분을 생략하고 호출할 수 있다.



### 6.1.2 alert(경고 대화상자)

- alert 메서드는 경고 대화상자를 표시한다.

- 인수로는 경고 메시지로 출력할 문자열을 받는다.

  ```js
  alert("경고 메시지");
  ```

  ![image-20191110202911146](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110202911146.png)

- 확인 버튼을 누르면 대화상자가 사라지고 코드 제어권이 호출한 부분으로 돌아간다.



### 6.1.3 prompt(입력 대화상자)

- prompt 메서드는 입력 대화상자를 표시한다.

- 인수로는 입력을 안내하는 문자열을 받는다.

  ```js
  var name = prompt("이름을 입력하십시오");
  ```

  ![image-20191110203607638](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110203607638.png)

- 입력받은 문자열은 메서드의 반환값이 된다.
- 두 번째 인수로는 초기 입력 값을 지정할 수 있다.![image-20191110204926983](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110204926983.png)

- prompt는 문자열로 값을 반환하기 때문에 숫자 값을 구하려면 parseInt나 parseFloat 메서드를 사용해야 한다.



### 6.1.4 confirm(확인 대화상자)

- 확인 대화상자를 표시한다. 인수로는 확인받을 메시지를 뜻하는 문자열을 받는다.

  ```js
  var ret = confirm("링크를 표시하시겠습니까?");
  ```

  ![image-20191110205205701](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110205205701.png)

- confirm 메서드는 논리값을 반환한다.



## 6.2 console

### 6.2.1 Console 객체의 메서드

- 웹 브라우저의 Console 객체는 콘솔 출력을 돕는 다양한 기능을 제공한다.



### 6.2.2 콘솔에 텍스트 출력하기

- console.log, console.info, console.warn, console.error 메서드를 통해 문자열이나 변수 값을 출력할 수 있다. 이들의 차이점은 메서드에 따라 다른 양식을 지니고 있다는 것이다.

- Console 객체의 메서드에는 인수 여러 개를 쉼표로 구분해서 넘길 수 있다. 출력 시엔 각 값을 공백 문자로 구분해서 순서대로 출력한다.

  ```js
  var a = [2,4,6];
  console.log("배열", a, "의 길이는", a.length, "입니다.");
  // -> 배열 [2, 4, 6] 의 길이는 3 입니다.
  ```

  인수를 + 연산자로 연결하여 넘기면 공백 문자를 빼고 출력할 수 있다.

  ```js
  // -> 배열2, 4, 6의 길이는 3입니다.
  ```

  서식 문자열을 사용하여 값을 지정된 서식으로 출력할 수 있다.

  ```js
  var name = "Tom";
  var height = 172.5;
  console.log("그의 이름은 %s 이며 키는 %f cm 입니다", name, height);
  // -> 그의 이름은 Tom 이며 키는 172.5 cm 입니다
  ```

   %s와 %f는 서식 문자열로 인수의 값을 서식 문자열에 해당하는 타입으로 변환하여 대입할 수 있다.



### 6.2.3 객체의 프로퍼티를 목록으로 표시하기

- console.dir 메서드는 객체의 프로퍼티를 나열한다. 인수로는 객체를 받는다.

- ```js
  var p = {x:1, y:2};
  console.dir(p);
  ```

  ![image-20191110223604132](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110223604132.png)



### 6.2.4 타이머

- console.time과 console.timeEnd 메서드는 특정 코드의 실행 시간을 측정할 수 있다.

- ```js
  console.time("answer_time");
  alert("확인 버튼을 누르십시오");
  console.timeEnd("answer_time");
  ```

  console.time의 인자는 타이머 이름을 뜻하는 문자열이다. 위 코드에서는 확인 버튼을 눌러 프로그램이 종료되기까지의 시간을 측정해준다.



## 6.3 이벤트 처리기 등록하기와 타이머 알아보기

### 6.3.1 이벤트 처리기

- **이벤트**: 단말기와 앱이 처리할 수 있는 동작이나 사건(클릭 등)
- **이벤트 주도형 프로그램**: 이벤트가 발생할 때까지 기다리다가 이벤트가 발생하면 실행되는 프로그램.
- 웹 브라우저에서 동작하는 프로그램은 기본적으로 이벤트 주도형 프로그램이다.
- **이벤트 처리기**: 이벤트가 발생하면 실행되는 함수
- 함수를 이벤트 처리기로 등록하는 방법에는 세 가지가 있다. 그 중 2개만 이 절에서 설명한다.



### 6.3.2 HTML 요소의 속성에 이벤트 처리기 등록하기

- HTML 요소에 이벤트 처리기 속성을 설정하면 그 요소에 이벤트가 발생했을 때 설정한 동작이 동작한다.

- ```html
  <input type="button" value="click" onclick="displayTime()">
  ```

  위 코드는 버튼에 onclick(마우스로 클릭했음)이라는 이벤트 유형을 부여해준 것이다. 이 때 onclick을 이벤트 처리기 이름이라고 지칭한다.

- 이벤트 처리기 속성에는 이벤트가 발생했을 때 실행할 자바스크립트 문장을 문자열로 만들어 대입한다. 만약 문장을 여러 개 작성한다면 문장과 문장을 세미콜론으로 구분한 문자열을 대입한다.

- 이 방법은 JS 코드가 HTML 코드와 섞인다는 단점이 있다.



### 6.3.3 DOM에서 가져온 HTML 요소에 이벤트 처리기 지정하기

- **DOM(문서 객체 모델)**: 자바스크립트 등의 프로그램이 HTML 요소를 조작할 수 있게 하는 인터페이스

##### DOM 객체

- DOM에서는 HTML 문서나 HTML 요소를 가리키는 객체로 자바스크립트를 사용하여 HTML 문서를 조작한다.
- window: Window 객체라고 하며 웹 브라우저 탭 하나를 가리킨다.
- document: Document 객체라고 하며 HTMl 문서 전체를 가리킨다. HTML 문서에서 요소 객체를 가져오거나 HTMl 요소를 새로 만드는 기능 등이 있다.
- 요소 객체: HTML 문서의 요소를 가리키는 객체이다.



##### DOM을 사용해서 이벤트 처리기 등록하기

1. window.onload를 사용하여 HTMl 문서를 다 읽어 들인 후에 2와 3을 실행한다.
2. document.getElementById 메서드를 사용하여 특정 id 속성 값을 가진 HTMl 요소의 요소 객체를 가져온다.
3. 요소 객체의 이벤트 처리기 프로퍼티에 이벤트 처리기로 동작할 함수를 등록한다.

```js
//이 함수는 웹 브라우저가 문서를 모두 읽어 들인 후에 실행된다.
window.onload = function(){
	var button = document.getElementById("button");
	button.onclick = displayTime;
};
```

- HTML 전체 문서를 보면 위 코드는 head 요소의 자식 요소로 배치되어 있다. 이는 JS와 HTML 문서를 분리하기 위해서이다.

- 단, 위 방법대로라면 head 요소는 body 요소보다 먼저 실행되기 때문에 window.onload를 사용하여 HTML 문서 전체를 읽은 후 함수를 실행하도록 설정하였다.

- document.getElementById 메서드는 전달받은 인수를 id 속성의 값으로 가지고 있는 HTML 요소의 요소 객체를 반환한다. HTML 요소를 못 찾으면 null이 반환된다.

- 요소 객체의 프로퍼티 onclick의 값으로 함수 displayTime의 참조를 대입한다. 이처럼 이벤트 처리기를 등록하기 위한 프로퍼티를 가리켜 **이벤트 처리기 프로퍼티**라고 한다.

- 함수 리터럴을 통해 직접 이벤트 처리기 함수를 대입할 수 있다.

  ```js
  button.onclick = function displayTime() {
  	var d = new Date();
  	console.log("현재 시작은 " + d.toLocaleString( + " 입니다."));
  };
  ```



##### 이벤트 처리기 제거

- 이벤트 처리기 프로퍼티에 null을 대입한다. 이 null은 이벤트 처리기가 등록되어 있지 않은 이벤트 처리기 프로퍼티 값과 같다.

  ```js
  button.onclick = null;
  ```



### 6.3.4 타이머

##### 지정된 시간이 흐른 후에 함수 실행하기 : setTimeout

- ```js
  setTimeout(function(){console.log(new Date());}, 2000);
  ```

  setTimeout 메서드는 실행할 함수의 참조와 지연 시간을 인수로 받아 지연 시간 후에 함수를 실행한다.

- setTimeout()의 반환 값을 clearTimeout()의 인수로 넘겨서 실행하면 함수 실행이 취소된다.

- 지연 시간을 0으로 지정하면 현재 시행 중인 이벤트 처리기의 작업이 끝난 후 바로 실행된다.



##### 지정된 시간마다 반복해서 실행하기 : setInterval

- ```js
  setInterval(function() {console.log(new Date());}, 1000);
  ```

  setInterval 메서드는 실행할 함수의 참조와 시간 간격을 인수로 받아 지정한 시간 간격마다 함수를 실행한다.

- setInterval()의 반환 값을 clearInterval()의 인수로 넘겨서 실행하면 함수 실행이 취소된다.

- 위의 두 메서드 모두 첫 번째 인수로 문자열을 넘길 수 있다. 이 때 문자열은 내부적으로 eval()로 평가된 후에 실행된다.



## 6.4 HTML 요소를 동적으로 읽고 쓰기

### 6.4.1 HTML 요소의 innerHTML 프로퍼티로 읽고 쓰기

- 요소 객체의 innerHTML 프로퍼티는 HTML 요소의 내용을 가리킨다. 

- ```html
  <!DOCTYPE html>
  <html lang="ko">
  <head>
      <meta charset="UTF-8">
      <title>스톱워치</title>
      <script>
          window.onload = function() {
              var startButton = document.getElementById("start");
              var stopButton = document.getElementById("stop");
              var display = document.getElementById("display");
              var startTime, timer;
              startButton.onclick = start;
              function start() {
                  startButton.onclick = null;
                  stopButton.onclick = stop;
                  startTime = new Date();
                  timer = setInterval(function(){
                      var now = new Date();
                      display.innerHTML = ((now - startTime)/1000).toFixed(2);
                  }, 10);
              }
              function stop() {
                  clearInterval(timer);
                  startButton.onclick = start;
              }
          };
      </script>
  </head>
  <body>
      <p id="display">0.00</p>
      <input type="button" id="start" value="start">
      <input type="button" id="stop" value="stop">
  </body>
  </html>
  ```

  위 코드에서 innerHTML은 display 요소의 내용을 가리키고 있다. display의 innerHTML 프로퍼티에 경과 시간을 대입하여 하여 스톱워치를 구현한다.



### 6.4.2 폼 컨트롤의 입력 값 읽기

- input 요소 같은 폼 컨트롤 요소를 사용하면 사용자의 입력 값을 JS 프로그램에서 사용할 수 있다.

- ```html
  <!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <title>체질량지수 계산하기</title>
      <script>
          window.onload = function() {
              document.getElementById("button").onclick = function() {
                  var h = parseFloat(document.getElementById("height").value); // value
                  var w = parseFloat(document.getElementById("weight").value);
                  var bmi = document.getElementById("bmi");
                  bmi.innerHTML = (w/h/h).toFixed(1);
              };
          };
      </script>
  </head>
  <body>
      <p>키: <input type="number" id="height"> m</p>
      <p>몸무게: <input type="number" id="weight"> kg</p>
      <p>당신의 체질량지수는 <output id="bmi">?</output> 입니다</p>
      <input type="button" id="button" value="계산">
  </body>
  </html>
  ```

  키와 몸무게가 input 요소 객체이므로 value 프로퍼티를 이용해 input 요소의 입력 값을 숫자로 구했다.



### 6.4.3 document.write

- document.write 메서드는 인수로 받은 문자열을 HTML 문서의 body 요소 안에 출력한다. 때문에 HTML 문서의 내용이 바뀌게 되고 웹 브라우저는 수정된 HTML 문서를 표시한다.

  ```html
  <body>
      <script>
      var now = new Date();
      var month = now.getMonth() + 1;
      var day = now.getDate();
      document.write("<p>오늘은 " + month + "월 "+ day + "일 입니다. </p>");
      </script>
  </body>
  ```

  위의 document.write 문은 HTML 문서에 위 문자열의 내용을 추가하게 되고, 이는 곧 현재의 날짜를 출력하는 p 태그가 된다.

  ```html
  <body>
  	<p>오늘은 11월 11일 입니다.</p>
  </body>
  ```

  

- 위의 document.write 문은 window.onload와 쓰지 않았기에 그 즉시 실행된다. 이 출력 값은 script 요소 바로 앞의 HTML 요소에 추가된다. 웹 브라우저는 script 요소 안의 작업이 끝난 후에 body 다음 부분을 해석해서 추가한다.

- 이벤트 처리기로 등록한 함수 안에서 document.write를 사용해서는 안 된다. 이는 이벤트 처리기 실행시 HTML 문서 전체 내용이 document.write의 출력 값으로 바뀌기 때문이다.



## 6.5 Canvas를 활용한 컴퓨터 그래픽스

- Canvas는 웹 브라우저에서 그래픽을 처리하기 위해 추가된 HTML5 구성 요소이다.



### 6.5.1 Canvas의 특징

- Canvas는 즉시 실행형 저수준 API이다.
- **API**: 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
- **저수준**: Canvas는 선, 원, 사각형 등의 기본적인 그리기 기능을 지니고 있다. 이렇게 기본적인 기능만 제공하는 API를 저수준 API라고 한다.
- **즉시 실행형**: Canvas의 그리기 명령을 호출 즉시 실행된다. 그림 상태를 저장하는 중간 데이터 계층이 없다.



### 6.5.2 Canvas의 기본적인 사용법

1. **canvas 요소를 배치한다.**

   - ```html
     <canvas id="mycanvas" width="640" height="400"></canvas>
     ```

2. **canvas 요소의 객체 가져오기**

   - Canvas를 페이지에 배치하면 Canvas 영역은 생기지만 눈에 보이지 않는다. JS에서 이를 작업해 주어야만 한다.

     ```js
     var canvas = document.getElementById("mycanvas");
     ```

3. **렌더링 컨텍스트 가져오기**

   - Canvas로 그림을 그리기 위해선 canvas 요소 객체에서 **렌더링 컨텍스트**라는 객체를 가져와야 한다. 이 때 canvas 요소 객체의 getContext 메서드를 사용한다.

   - **컨텍스트**: 상황에 따른 문맥 혹은 맥락이라고 할 수 있다.

   - ****: 만들고자 하는 그림의 수학적 모델을 사실감을 불어넣는 과정. Canvas에는 2d와 3d의 2가지가 가능하다.

     ```js
     var ctx = canvas.getContext("2d");
     var ctx = canvas.getContext("webgl");
     ```

4. **그림 그리기**

   - 랜더링 컨텍스트의 메서드를 사용하여 Canvas 위에 그림을 그릴 수 있다.

     ```js
     ctx.strokeRect(50, 60, 200, 100);
     ```



### 6.5.3 Canvas 좌표계

- Canvas 좌표계는 기본점이 왼쪽 윗부분을 기준으로 원점 (0, 0)이다.



### 6.5.4 사각형 그리기

##### 사각형 테두리 그리기 : strokeRect(x, y, width, height)

```js
ctx.strokeRect(10,10,200,150)
```



##### 사각형 채우기 : fillRect(x, y, width, height)

```js
ctx.fillRect(50, 40, 120, 90);
```



##### 사각형 영역을 지우고 투명하게 만들기 : clearRect(x, y, width, height)

```js
ctx.clearRect(90, 65, 40, 40);
```



### 6.5.5 패스로 그리기

패스를 이용하여 도형을 그리는 방법은 다음과 같다.

1. **beginPath 메서드 호출하기**
   - 이 메서드는 호출 시 렌더링 컨텍스트 패스를 기록하기 시작한다. 이 때 지금까지 정의한 패스가 초기화되어 새로운 도형을 그릴 수 있게 된다.
2. **패스를 정의하는 메서드 호출하기**
   - 패스를 정의하는 메서드를 호출하면 렌더링 컨텍스트에 호출한 패스가 추가되어 하나씩 연결된다.
   - 패스는 여러 메서드로 호출할 수 있다.
3. **closePath 메서드 호출하기**
   - 이 메서드를 호출하면 패스의 마지막 점과 시작점을 직선으로 연결하고 패스를 닫는다.
   - 만약 패스가 이미 닫혀 있거나 패스 위의 점이 하나일 때는 아무런 작업도 하지 않는다.
4. **패스를 Canvas에 그리기**
   - stroke 나 fill 등의 메서드로 렌더링 컨텍스트에 기록한 패스를 Canvas 위에 그린다.



##### 펜 이동시키기 : moveTo(x,y)

- moveTo(x, y) 메서드는 패스를 그리지 않는다. 패스를 그리는 펜의 좌표만 이동시킨다.

##### 선으로 연결하기 : lineTo(x, y)

- lineTo(x, y) 메서드는 패스를 그리는 펜을 들고 좌표 점 (x, y)로 이동한다. 결과적으론 실행 전의 점과 (x, y) 사이를 잇는 선을 그린다.

##### 원호 그리기 : arc(x, y, radius, startAngle, endAngle, anticlockwise)

- arc 메서드는 원호를 그린다.

- 인수는 중심 좌표, 반지름, 원호의 시작 각과 끝 각, 그려지는 방향을 받는다.

- 인수로 받는 원호의 각은 단위가 digrees가 아닌 radians이므로 변환해줘야 한다. 1라디안은 약 57.3도이다.

  ```js
  var radians = degrees * Math.PI / 180;
  ```

- 선과 원호를 연결하여 둥근 모서리를 구현할 수도 있지만 연결점의 위치를 계산해야 하기에 다음의 방법을 사용한다.

##### 원호를 사용하여 둥근 모서리 그리기 : arcTo(x1, y1, x2, y2, radius)

- arcTo 메서드는 선과 선을 연결하는 모서리를 원호로 그린다.

  ```js
  ctx.beginPath();
  ctx.moveTo(10, 10);
  ctx.arcTo(100, 10, 100, 100, 30);
  ctx.lineTo(100, 100);
  ctx.stroke();
  ```

  ![image-20191112201615856](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191112201615856.png)

  좌표 3개를 x0, x1, x2 좌표라고 할 때, arcTo는 현재 위치한 점 x0에서 x1까지의 선과 x1에서 x2까지의 선을 계산한 후 두 선으로부터 원의 반지름만큼 떨어진 점을 기준으로 원호를 그려 두 선을 연결한다.



### 6.5.6 그래픽스 속성 설정하기

##### 색상 설정 : strokeStyle, fillStyle

- strokeStyle 프로퍼티로 선 색상을, fillstyle 프로퍼티로 채우기 색상을 설정할 수 있다.

  ```js
  ctx.strokeStyle = "red";
  ctx.fillStyle = "green";
  ```

- 초깃값은 #000000(불투명한 검은색)이다.

##### 투명도 설정 : globalAlpha

- Canvas 위의 모든 도형의 투명도를 설정한다.

- 0~1까지의 값이 있으며 초깃값은 1이다.

  ```js
  ctx.globalAlpha = "0.6";
  ```

- 도형마다 다른 투명도를 원한다면 strokeStyle 또는 fillStyle 값에 rgba(red green blue 투명도) 함수를 문자열로 입력하면 된다.

##### 선의 두께 설정 : lineWidth

- stroke와 strokeRect 메서드로 그린 선 두께를 설정한다.
- 프로퍼티 값으로 양의 정수를 대입할 수 있고 초깃값은 1이다. 1미만의 소수도 설정 가능하지만 이 때는 두께를 비율에 따라 1픽셀씩 반투명으로 그린다.

##### 패스 종단점 모양의 설정 : lineCap

- 열린 패스의 종단점 모양을 설정한다. butt, square, round의 값이 설정 가능하다. ![img](https://mblogthumb-phinf.pstatic.net/20121013_248/javaking75_1350129833570hHk3C_PNG/2012-10-13_210338.png?type=w2) 

##### 패스 정점의 설정 : lineJoin

- 패스의 꼭짓점(정점) 모양을 설정한다. miter, roundm bevel의 값이 설정 가능하다.

   ![img](https://mblogthumb-phinf.pstatic.net/20121013_94/javaking75_1350129908234rJu74_PNG/2012-10-13_210454.png?type=w2) 



### 6.5.7 그림 읽어 들이기

- Canvas로 이미지를 표시할 수도 있다. 이미지 파일의 URL, Canvas로 그린 컴퓨터 그래픽스, img 요소 객체, video 요소 객체 등을 읽을 수 있다.

- ```html
  <!DOCTYPE html>
  <html>
  <head>
      <meta charset="UTF-8">
      <title>Canvas로 이미지 파일 읽어 들이기</title>
      <script>
          window.onload = function() {
              var canvas = document.getElementById("mycanvas");
              var ctx = canvas.getContext("2d");
              var img = new Image();
              img.onload = function() {
                  ctx.drawImage(img, 0, 0);
              };
              img.src = "./cat.jpg";
          };
      </script>
  </head>
  <body>
          <canvas id="mycanvas" height="660px" width="335px"></canvas>
  </body>
  </html>
  ```

  위 예제로 canvas가 이미지를 읽어 들이는 방법을 알아보자.

  1. **이미지 객체를 가져온다**

     - ```js
       var img = new Image();
       ```

       먼저 Image 생성자가 이미지 객체를 생성한다. 그 후 이미지 파일의 URL을 이미지 객체의 src 속성에 지정해준다.

       ```js
       img.src = "./cat.jpg";
       ```

       이후 이미지 소스가 읽어진다.

     - 만약 Canvas로 그린 컴퓨터 그래픽스를 이미지 소스로 지정하려면 canvas 요소 객체의 toDataURL 메서드를 사용하면 된다.

       ```js
       img.src = canvas.toDataURL();
       ```

  2. **drawImage 메서드로 이미지 객체의 이미지를 Canvas에 그린다**

     - 이미지 객체가 완성되면 drawImage 메서드로 렌더링 컨텍스트에 그린다.

       ```js
       ctx.drawImage(img, x, y);
       ```

       인수로 이미지 객체의 이름과 왼쪽 위 꼭짓점의 좌표를 받는다.

     - 이미지를 읽어 들이는 데에는 시간이 들기 때문에 이미지가 onload 되었을 때 drawImage를 호출할 수 있도록 한다.

       ```js
       img.onload = function() {
                       ctx.drawImage(img, 0, 0);
                   };
       ```

##### drawImage 메서드의 다양한 사용법

- drawImage에 어떤 인수를 넣느냐에 따라 사용 방법이 달라진다.

  1. ##### drawImage(image, x, y)

     - (x, y) 좌표를 왼쪽 위의 꼭짓점으로 하여 이미지를 그린다.

  2. ##### drawImage(image, x, y, width, height)

     - (x, y) 좌표를 왼쪽 위의 꼭짓점으로 잡고 width 값과 height 값으로 너비와 높이를 설정해준다.

  3. ##### drawImage(image, sx, sy, sw, sh, x, y, width, height)

     - (sx, sy) 좌표를 왼쪽 위의 꼭짓점으로 잡고 너비는 sw, 높이는 sh만큼의 사각형 모양으로 사진을 잘라낸다. 그 후 2와 같은 방법으로 잘라낸 이미지를 그린다. 



### 6.5.8 픽셀 제어하기

##### getImageData(x, y, width, height)

- 렌더링 컨텍스트에 렌더링된 이미지 안의 점 (x, y)를 왼쪽 위의 꼭짓점으로 한 너비가 width, 높이가 height인 사각형 영역 내의 imageData 객체를 가져온다.

- 가져온 imageData 객체에는 width(이미지 너비), height(이미지 높이), data(이미지의 픽셀 값이 저장된 1차원 배열) 프로퍼티가 있다.

- 이 중 data 프로퍼티는 이미지의 모든 픽셀의 R, G, B, A 값이 배열의 각 요소에 저장되어 있다.

- getImageData 메서드는 크로스 도메인 이슈에 따른 정보 유출을 방지하기 위해 origin-clean한 canvas 요소에서만 동작한다.

  - **도메인**: ip에 사람이 외울 수 있도록 부여한 기기의 이름
    - **ip**: 인터넷에 연결된 장치들을 구별하기 위해 각각의 장치를 식별하기 위해 붙인 주소
  - **크로스 도메인 이슈**: 타 서버에서 만든 API의 도용을 방지함
  - origin-clean: 다른 도메인에서 읽어 들인 이미지가 없다는 의미
  - 크롬에서는 로컬 디스크의 이미지도 타 도메인의 이미지로 간주하여 getImageData 메서드를 사용할 수 없다.

- imageData에 담긴 이미지의 왼쪽에서 m번째, 위에서 n번째 픽셀의 RGBA 값은 다음과 같다.

  - ```js
    R = imageData.data[imageData.width * 4 * n + 4 * m]
    G = R + 1
    B = G + 1
    A = B + 1
    ```

##### createImageData 메서드

- 새로운 imageData 객체를 생성한다. 다음과 같은 방법으로 사용한다.

  1. ##### createImageData(width, height)

     - 너비가 width이고 높이가 height인 imageData 객체를 생성한다. 각 픽셀은 투명한 검은색으로 초기화되어 있다.

  2. ##### createImageData(anotherImageData)

     - imageDate 객체를 인수로 받는다. 인수로 받은 객체와 같은 크기의 imageData 객체를 생성(복사)한다. 단 1과 같이 각 픽셀은 투명한 검은색으로 초기화되어 있다.

##### putImageData 메서드

- ImageData 객체의 이미지를 렌더링 컨텍스트에 그린다.

  ```js
  ctx.putImageData(imageData, x, y);
  ```

  좌표 (x, y)를 그릴 이미지의 왼쪽 위 모서리의 좌표를 뜻한다. ImageData 안에 있는 이미지의 좌표를 집어 그 부분부터 그림을 그리는 것이다. 즉, x, y가 0인 경우에 ImageData 안의 전체 이미지를 그릴 수 있다.



# 7장 제어 구문

## 7.1 제어 구문

- 문장은 일반적으로 작성한 순서대로 실행된다. 이를 **순차적 실행**이라고 한다.
- **제어 구문**은 이런 순차적 실행 흐름을 변화시킨다.
- 자바스크립트의 제어 구문에는 **조건문**, **반복문**, **점프문**이 있다.



## 7.2 조건문

- 조건문은 조건식의 값에 따라 실행 흐름을 분기(분리, 나누다)한다.

### 7.2.1 if/else 문

- **만약 ~이라면... 그렇지 않으면...**의 처리 흐름을 표현한다.

- 아래의 두 가지 형식을 지니고 있다.

  ```js
  if (조건식) 문장
  if (조건식) 문장1 else 문장2
  ```

  두 방법 모두 if는 조건식이 참일 때 실행된다. 두 번째 방법의 else는 조건식이 거짓일 때 실행된다.

- if문 안에 if문을 중첩해서 사용할 때 이를 **중첩된 if 문**이라고 한다. if 문을 중첩할 때는 if와 else가 잘 대응하는지를 확인해야 한다.

  ```js
  if(a>b)
  	if(a>c)
  		console.log("a가 가장 크다");
  else
  	console.log("a는 b 이하");
  ```

  위 예에서 else는 겉으로 보기엔 첫 번째 if문에 대응하는 것처럼 보이지만 else문은 가장 가까운 if문에 호응하기 때문에 실제로는 두 번째 if문에 대응한다.

- 위와 같은 오류를 방지하기 위해서 if 문 안의 문장은 단 한 줄일지라도 중괄호로 묶는 것을 권장한다.

- else와 if는 합쳐서 사용할 수 있다.

  ```js
  if(num==1){
  	console.log("One");
  } else if(num==2){
  	console.log("Two");
  } else{
  	console.log("Other");
  }
  ```



### 7.2.2 switch 문

- if/else 문으로 분기점이 여러 개인 조건식을 만들면 코드가 복잡해질 수 있다. switch 문은 이를 훨씬 간결하게 표현할 수 있다.

  ```js
  switch(표현식){
  	case 표현식 1 : 실행문 1
  	case 표현식 2 : 실행문 2
  	...
  	case 표현식 n : 실행문 n
  	default : 실행문 n + 1
  }
  ```

- switch 문은 괄호 안의 표현식을 먼저 평가하고 평가한 값과 일치하는 case 라벨의 값(case 뒤의 표현식)을 위에서부터 찾는다. 일치의 기준은 일치 연산자(===)와 같다.

- 라벨 값과 일치하는 case 라벨을 발견하면 그 case 라벨의 실행문을 차례대로 실행한다. 일치하는 라벨이 없다면 default 라벨을 찾고 그 안의 실행문을 실행한다.

- 각각의 case 라벨 뒤에 이어지는 실행문은 break 문으로 마무리된다. break 문은 코드를 블록 문장에서 빠져나오도록 한다. 만약 break 문이 없다면 case의 실행문이 끝나고도 switch 문의 전체 부분이 실행된다.

- 고의로 break 문을 걸지 않는 경우가 있는데 이것을 폴 스루라고 한다. 폴 스루는 여러 개의 case 라벨이 가리키는 표현식 결과와 일치하는 실행문을 실행하고자 할 때 사용한다.



## 7.3 반복문

- 반복문은 일정한 처리를 한 다음 원래 위치로 돌아가 똑같은 처리를 반복하는 처리를 표현한다.

### 7.3.1 while 문

- while 문은 조건이 맞아떨어지면 일정한 처리를 무한정 반복해서 실행한다.

  ```js
  while (조건식) 문장
  ```

- while 문이 실행되면 조건식을 먼저 평가한다. false이면 while 문을 빠져나오고 true이면 문장을 실행하고 다시 while 문의 시작 부분으로 돌아간다.

- while 문에는 break 문과 continue 문을 사용할 수 있다. break가 실행되면 while 문에서 빠져나오고 continue가 실행되면 while 문의 시작 부분으로 돌아간다.



### 7.3.2 do/while 문

- while 문은 반복 조건을 시작 지점에서 확인하지만 do/while 문은 마지막 지점에서 확인한다.

  ```js
  do 문장 while(조건식);
  ```

- do/while 문의 끝에는 세미콜론이 붙어야 한다.

- 문장을 실행한 후 조건식이 참이면 반복문의 시작 부분으로 돌아가고 거짓이면 빠져나온다.

- while 문의 문장은 조건식이 틀리면 실행되지 않을 수 있지만 do/while 문의 문장은 반드시 한 번은 실행된다.

- break 문과 continue 문을 사용할 수 있다.



### 7.3.3 for 문

- for 문은 반복 조건의 초기화, 반복문의 조건식, 반복 사이클이 한 번 돌았을 시 반복 조건을 갱신하는 작업을 명시적으로 한 곳에 모아서 표시한다.

  ```js
  for( 초기화 식; 조건식; 반복식) 문장
  ```

- for 문은 반복문에 필수로 필요하다시피한 세 가지 작업을 for의 소괄호 안에 모두 작성함으로써 어떤 반복 처리를 하는지 이해하기가 쉽고 반복 조건의 초기화나 갱신 작업을 빼먹는 실수를 미연에 방지할 수 있다.

- 초기화 - 조건식 평가 - 문장 실행 - 반복식 실행 - 조건식 평가

- break 문과 continue 문을 사용할 수 있다.

- 초기화 식 입력 구간에서 쉼표 연산자를 사용할 시 표현식을 여러 개 작성할 수 있다.

- 괄호 안의 모든 식은 생략할 수 있으나 세미콜론만큼은 생략할 수 없다.

- 조건식을 생략하면 무한 반복의 의미가 된다.

- ```js
  for(var i = 0; i < 10; i++){...}
  ```

  위 for 문의 i처럼 반복식 안에서 값이 바뀌는 변수를 루프 카운터 변수라고 한다. 루프 카운터 변수는 여러 개일수도 있다.

  ```js
  for(var i=0, j=10; i<10; i++, j--){...}
  ```

##### 중첩 반복문

- for 문 안에 for 문을 작성하면 중첩 반복문을 만들 수 있다.



### 7.3.4 for/in 문

- for/in 문은 객체 안의 프로퍼티를 순회하는 반복문이다.

  ```js
  for (변수 in 객체 표현식) 문장
  ```

- for/in 문은 객체 표현식을 먼저 평가한다. null 또는 undefined일 경우 for/in 문을 빠져나온다. 객체일 경우 객체의 프로퍼티 이름이 차례대로 변수에 할당되고 각각의 프로퍼티에 대해서 문장이 한 번씩 실행된다.

  ```js
  var obj = {a:1, b:2, c:3};
  for(var p in obj) {
  	console.log("p = " + p);
  }
  // -> p=a
  //	  p=b
  //    p=c
  ```

  위처럼 프로퍼티의 이름이 문자열로 변환되어 변수 p에 대입된다.

- for/in 문은 프로퍼티 이름만 꺼내 변수에 할당한다. 따라서 프로퍼티 값을 꺼내오려면 대괄호 연산자를 사용해야 한다.

  ```js
  var obj = {a:1, b:2, c:3};
  for(var p in obj) {
  	console.log("obj. " + p + " = " + obj[p]);
  }
  // -> obj.a = 1
  //    obj.b = 2
  //    obj.c = 3
  ```

- break 문과 continue 문을 사용할 수 있다.



## 7.4 점프문

- 점프문은 프로그램의 다른 위치로 이동하는 제어 구문이다.

### 7.4.1 라벨문

- JS에서는 모든 문장에 라벨을 붙일 수 있다.

  ```js
  라벨 이름 : 문장
  ```

- 라벨 이름에는 모든 식별자를 사용할 수 있다.

- JS에서 라벨로 점프(이동)할 수 있는 문장은 break 문과 continue 문뿐이다. break 문은 switch 문과 반복문 안에서만 사용할 수 있고 continue 문은 반복문에서만 사용 가능하다.

- 다음 코드에서 break loop;를 실행하면 loop라는 라벨이 붙은 while 문이 종료된다.

  ```js
  loop: while( true ){
  	if( confirm("종료하시겠습니까?")) break loop;
  }
  ```



### 7.4.2 break 문

- ```js
  break;
  ```

- switch 문에서 실행 시 switch 문에서 빠져나오고 반복문에서 실행 시 가장 안쪽의 반복문에서 빠져나온다.

- 점프할 라벨을 지정할 수 있다. 라벨을 지정한 break 문은 라벨 이름이 붙은 문장 끝으로 점프한다.

  ```js
  break 라벨 이름;
  ```

  이 때 지정한 라벨이 존재하지 않으면 문법 오류가 발생한다.

- break 문과 라벨 사이에 줄 바꿈 문자가 들어갈 시 JS 내부적으로 세미콜론이 생겨 라벨이 지정되지 않은 break 문으로 지정된다.

- 라벨을 지정한 break 문은 주로 중첩된 반복문의 안쪽 반복문에서 전체 반복문을 빠져나올 때 쓰인다.



### 7.4.3 continue 문

- ```js
  continue;
  ```

- continue 문에서 점프할 라벨을 지정할 수 있다.

  ```js
  continue 라벨 이름;
  ```

- continue 문을 실행 시 반복문의 실행을 멈추고 반복을 새로 시작한다. 단, 반복문마다 동작이 조금씩 다르다.

  | while 문    | 반복문의 처음으로 돌아가 조건식을 재평가한다. true일 경우 반복문 재실행 |
  | ----------- | ------------------------------------------------------------ |
  | do/while 문 | 반복문의 마지막에 위치한 조건식으로 점프한다. true일 경우 반복문 재실행 |
  | for 문      | 반복식을 실행 후에 조건식을 평가한다. true일 경우 반복문 재실행 |
  | for/in 문   | 반복문의 처음으로 돌아가 지정한 변수에 할당된 프로퍼티의 다음 프로퍼티를 대상으로 작업을 시작한다. |

- 라벨을 지정한 continue 문은 주로 중첩된 반복문의 안쪽 반복문에서 전체 반복문으로 점프할 때 쓰인다.



## 7.5 응용 예제

### 7.5.1 망델브로 집합 그리기



### 7.5.2 암호 원판을 활용한 암호화



# 8장 함수

## 8.1 함수 정의하기

### 8.1.1 함수를 정의하는 방법

1. ##### 함수 선언문으로 정의하는 방법

   ```js
   function square(x) { return x*x; }
   ```

2. ##### 함수 리터럴로 정의하는 방법

   ```js
   var square = function(x) { return x*x; };
   ```

3. ##### Function 생성자로 정의하는 방법

   ```js
   var square = new Function("x", "return x*x");
   ```

4. **화살표 함수 표현식으로 정의하는 방법**

   ```js
   var square = x => x*x;
   ```

   8.11절에서 설명

위 방법 중 1번을 제외한 나머지 방법으로 정의한 함수는 변수에 그 함수의 참조를 할당해야 비로소 사용할 수 있는 상태가 되므로 함수 끌어올림의 대상이 되지 않고 때문에 함수를 호출하는 코드보다 앞에 위치해야 한다.



### 8.1.2 중첩 함수

- **중첩 함수**: 특정 함수의 내부에 선언된 함수
- 중첩 함수는 if 문이나 while 문 등의 문장 블록 안에는 작성할 수 없다 => 외부 함수의 최상위 레벨에만 중첩 함수를 작성할 수 있다.
- 중첩 함수의 참조는 중첩 함수의 외부 함수의 지역 변수에 저장되므로 외부 함수의 바깥에서는 사용할 수 없다.
- 중첩 함수는 자신의 외부 함수의 인수나 지역 변수에 접근할 수 있다.



## 8.2 함수 호출하기

## 8.2.1 함수를 호출하는 방법

1. ##### 함수 호출

   - 함수의 참조가 저장된 변수 뒤에 그룹 연산자인 ()를 붙여서 호출한다.

     ```js
     square(5);
     ```

2. ##### 메서드 호출

   - 메서드가 들어있는 프로퍼티를 호출하면서 그룹 연산자를 사용한다. 본질적으로 1과 같은 방법이다.

     ```js
     obj.m = function() {...};
     obj.m();
     ```

3. ##### 생성자 호출

   - 생성자의 참조를 저장한 변수 앞에 new 키워드를 추가한다.

     ```js
     var obj = new Object();
     ```

4. ##### call, apply를 사용한 간접 호출

   - 함수의 call, apply 메서드를 사용하여 함수를 간접적으로 호출할 수 있다. 9장에서 설명



### 8.2.2 즉시 실행 함수

- 일반적으로 익명 함수를 실행할 때는 익명 함수의 참조를 변수에 할당한 후 그룹 연산자 ()를 붙여서 실행한다.

  ```js
  var f = function() {...};
  f();
  ```

  하지만 JS에는 익명 함수를 정의하고 곧바로 실행하는 **즉시 실행 함수**라는 구문이 있다.

  ```js
  (function() {...})();
  (function() {...}());
  ```

  위의 두 가지 방법을 이용하면 익명 함수를 정의하는 동시에 실행할 수 있다.

- 즉시 실행 함수의 구문에서는 함수 정의식을 그룹 연산자 ()로 묶는다. 이는 괄호 안의 함수 정의식을 평가하여 함수 객체의 참조 값(함수 값)으로 바꾼다. 아래의 방법으로도 함수 정의식을 함수 값으로 만들 수 있다.

  ```js
  +function() {...}()
  ```

  가장 먼저 소개한 익명 함수를 변수에 할당하는 방법도 함수 정의식을 함수 값으로 변환하여 변수에 할당한 것이다.

- 즉시 실행 함수에도 인수를 넘길 수 있다.

  ```js
  (function(a, b){...})(1, 2);
  ```

- 즉시 실행 함수에도 이름을 붙일 수 있지만 함수 내부에서만 유효하다.(사용 예: 재귀 함수)

- 함수 실행 결과를 변수에 할당할 수 있으며 표현식 안에서 사용할 수 있다.

  ```js
  var x = (function(){...})();
  ```



## 8.3 함수의 인수

### 8.3.1 인수의 생략

- 함수 정의식에 작성된 인자 개수보다 인수를 적게 전달해서 함수를 실행하면 생략된 인자는 undefined가 된다.

  ```js
  function f(x, y){
  	console.log(x, y);
  }
  f(2);	// -> x undefined
  ```

- 위의 성질을 활용하면 인수를 생략할 수 있는 함수를 정의할 수 있다. 단, 인수를 생략했을 시의 초깃값을 설정해야 한다.

  ```js
  function multiply(a, b){
  	b = b || 1;
  	return a*b;
  }
  multiply(2); // -> 2
  ```



### 8.3.2 가변 길이 인수 목록(Arguments 객체)

- 모든 함수에는 arguments라는 지역 변수가 있다. 이 변수의 값은 Arguments 객체로 함수의 인수 값을 유사 배열 객체(10.3절 참조)의 형태로 저장한다.

- Arguments 객체는 프로퍼티로 length(인수의 개수)와 callee(현재 실행되고 있는 함수의 참조)를 갖고 있다.

- arguments[i]의 값을 바꾸면 이에 해당하는 인자의 값도 바뀐다.

  ```js
  function f(x, y){
  	arguments[1] = 3;
  	console.log(x, y);
  }
  f(1, 2)	// -> 1 3
  ```

  일반적인 배열에는 이러한 특징이 없다.

- arguments 변수를 활용하면 인수의 개수가 일정하지 않은 가변 인수 함수를 정의할 수 있다.

  ```js
  function myConcat(separator){
  	var s = "";
  	for(var i=1; i<arguments.length; i++){
  		s += arguments[i];
  		if( i < arguments.length-1 ) s += separator;
  	}
  	return s;
  }
  console.log(myConcat("/", "apple", "orange", "peach")); // -> apple/orange/peach
  ```

  위의 코드에서 apple, orange, peach는 인자로서 받아들여지진 않았지만 arguments 변수에는 저장되어 있었기에 위와 같은 코드를 만들 수 있었다. 이처럼 JS의 함수에서는 작성된 인자 개수보다 더 많은 개수의 인수를 넘겨서 함수를 실행할 수 있다.

- arguments[]는 앞서 말했듯이 유사 배열 객체이지만 다음의 방법을 사용하면 배열 객체로 변환할 수 있다.

  ```js
  var params = [].slice.call(arguments);
  ```

  slice는 배열의 메서드로 10.1.3절에서 설명을, call 메서드를 사용한 메서드의 호출 방법은 8.8.3절에서 설명할 것이다.



## 8.4 재귀 함수

- 함수가 자기 자신을 호출하는 행위를 **재귀 호출**, 이러한 호출을 수행하는 함수를 **재귀 함수**라고 한다.

### 8.4.1 재귀 함수의 기본

- 팩토리얼을 반환하는 함수를 여러 가지 방법으로 표현하였다.

  ```js
  // 함수 선언문
  function fact(n) {
  	if(n<=1) return 1;
  	return n*fact(n-1);
  }
  // 함수 리터럴
  var fact = function f(x){
  	if(n<=1) return 1;
  	return n+f(n-1);
  }	// 함수 이름은 함수 안에서만 유효하다.
  // 함수 리터럴(익명 함수)
  var fact = function(n) {
  	if(n<=1) return 1;
  	return n*arguments.callee(n-1);
  }	// callee가 현재 실행 중인 함수의 참조를 뜻하기 때문에 익명 함수가 한 번 더 실행된다.
  ```

- 재귀 함수를 정의할 때는 유의해야 할 사항이 2가지 있다.

  1. **재귀 호출은 반드시 멈춰야 한다**
     - 재귀 함수를 짤 때에는 재귀 호출이 멈출 수 있는 조건을 만들어주어야만 한다. 그렇지 않으면 재귀 함수에서 코드가 빠져나오지 못한다.
  2. **재귀 호출로 문제를 간단하게 해결할 수 있을 때만 사용한다**
     - 재귀 호출로 재귀 함수가 여러번 실행되면 메모리의 사용량이 증가한다.  때문에 반복문으로 해결할 수 있는 문제에는 재귀 함수를 사용하지 않는 것이 좋다.

### 8.4.2 재귀 함수의 예

하노이의 탑(아래에선 막대기 3개로 판 4개를 옮기는 방법을 구현한 재귀 함수

```js
function hanoi(n, a, b, c) {
	if(n<1){return;}
	hanoi(n-1, a, c, b);
	console.log(n + " 번째 원반: " + a " -> " + c);
	hanoi(n-1, b, a, c);
}
hanoi(4, "A", "B", "C");
```

## 8.5 프로그램의 평가와 실행 과정

### 8.5.1 실행 가능한 코드

- JS 엔진은 **실행 가능한 코드**를 만나면 그 코드를 평가해서 **실행 문맥(실행 환경)**으로 만든다.
- 실행 가능한 코드로는 전역 코드, 함수 코드, eval 코드가 있다.
- **전역 코드**: 전역 객체 Window 아래에 정의된 함수
- **함수 코드**: 함수
- **eval 코드**: eval 함수



### 8.5.2 실행 문맥의 구성

- **실행 문맥(실행 환경)**: 실행 가능한 코드가 실제로 실행되고 관리되는 영역으로 실행 가능한 코드를 만날 때마다 생성된다.

- 실행에 필요한 모든 정보는 컴포넌트 여러 개가 나누어 관리한다.

- **컴포넌트**: 프로그래밍의 한 부분으로 재사용이 가능한 최소 단위를 지칭한다.

- 중요한 컴포넌트로는 **렉시컬 환경 컴포넌트, 변수 환경 컴포넌트, 디스 바인딩 컴포넌트**가 있다.

- 아래는 JS의 객체 표현을 빌려 실행 문맥을 표현한 것이다.

  ```js
  //실행 문맥
  ExecutionContext = {
  	//렉시컬 환경 컴포넌트
  	LexicalEncironment: {},
  	//변수 환경 컴포넌트
  	VariavleEnvironment: {},
  	//디스 바인딩 컴포넌트
  	ThisBinding: null,
  }
  ```

- ##### 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트

  - 두 컴포넌트는 앞으로 설명할 **렉시컬 환경** 타입의 컴포넌트이다.
  - 이 두 컴포넌트는 타입과 내부 값이 같다.(with 문을 사용할 때는 제외) 따라서 똑같이 취급해도 큰 문제가 발생하지 않는다.

- ##### 디스 바인딩 컴포넌트

  - 함수를 호출한 객체의 참조가 저장되는 컴포넌트
  - 이 컴포넌트가 가리키는 값이 곧 해당 실행 문맥의 this가 된다.(8.5.9절)



### 8.5.3 렉시컬 환경 컴포넌트의 구성

- 함수 또는 블록의 유효 범위 안에 있는 식별자와 그 결괏값이 저장되는 곳

- **환경 레코드**와 **외부 렉시컬 환경 참조** 컴포넌트로 구성되어 있다.

- 아래는 JS의 객체 표현을 빌려 렉시컬 환경 컴포넌트를 표현한 예제이다.

  ```js
  LexicalEnvironment: {
  	//환경 레코드
  	EnvironmentRecord: {},
  	//외부 렉시컬 환경 참조
  	OuterLexicalEnvironment Reference: {}
  }
  ```

- ##### 환경 레코드

  - 유효 범위 안에 포함된 식별자를 기록하고 실행하는 영역
  - 유효 범위 안의 식별자와 결괏값을 바인드(연관시키다)해서 환경 레코드에 기록한다. 

- ##### 외부 렉시컬 환경 참조

  - 함수를 둘러싸고 있는 코드가 속한 렉시컬 환경 컴포넌트의 참조를 저장
  - JS 엔진은 JS의 기능상(함수 중첩) 유효 범위 너머의 유효 범위를 검색할 수 있어야 한다. 외부 렉시컬 환경 참조는 이를 구현한다.
  - 중첩된 함수에서 바깥의 변수를 읽거나 쓸 때, 외부 렉시컬 환경 참조를 따라 그 변수를 검색한다.



### 8.5.4 환경 레코드의 구성

- 환경 레코드는 렉시컬 환경의 값(식별자와 식별자의 값의 묶음)이 실제로 저장되는 영역이다.

- **선언적 환경 레코드**와 **객체 환경 레코드**로 구성되어 있으며 저장 값의 유형에 따라 쓰임새가 달라진다.

- 아래는 JS의 객체 표현을 빌려 환경 레코드를 표현한 것이다.

  ```js
  EnvironmentRecord: {
  	//선언적 환경 레코드
  	DeclarativeEnvironmentRecord: {},
  	//객체 환경 레코드
  	ObjectEnvironmentRecord: {}
  }
  ```

- ##### 선언적 환경 레코드

  - 실제로 함수와 변수의 식별자와 실행 결과가 저장되는 영역이다.
  - 식별자와 실행 결과를 키와 값의 쌍으로 관리한다.

- ##### 객체 환경 레코드

  - 실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 쓴다.
  - 즉, 전역 객체 등 별도의 객체에 저장된 데이터는 객체 전체의 참조를 가져와서 객체 환경 레코드의 bindObject라는 프로퍼티에 바인드한다.



### 8.5.5 전역 환경과 전역 객체의 생성

- JS 인터프리터는 실행 시 렉시컬 환경 타입의 전역 환경을 생성한다. 

- 전역 객체를 생성한 후 전역 환경의 객체 환경 레코드에 전역 객체의 참조를 대입한다.

- 이 때 최상위 레벨의 this는 전역 객체를 가리킨다.

  ```js
  this === window // -> true
  ```

-  아래는 JS의 객체 표현을 빌려 위에서 설명한 코드의 상태를 표현한 것이다.

   ```js
   //전역 환경
   GlobalEnvironment = {
   	ObjectEnvironmentRecord: {
   		bindObject: window
   	},
   	OuterLexicalEnvironmentReference: null
   }
   
   // 전역 실행 문맥
   ExecutionContext = {
   	LexicalEnvironment: GlobalEnvironment,
   	ThisBinding: window
   }
   ```
   
   위 상황에서 window 객체가 전역 객체이므로 객체 환경 레코드의 bindObject 프로퍼티에는 window의 참조가 할당된다. 또한 생성된 전역 환경의 외부에는 다른 렉시컬 환경이 없으므로 외부 렉시컬 환경 참조에는 null을 할당한다.
   
   this가 window 객체이므로 디스 바인딩 컴포넌트에도 window의 참조가 할당된다.



### 8.5.6 프로그램의 평가와 전역 변수

- JS 인터프리터는 전역 환경과 전역 객체를 생성한 후에 프로그램을 읽어들이고 평가한다. 이 때 최상위 레벨(전역 객체)에 var 문으로 작성한 전역 변수들이 전역 환경의 환경 레코드(객체 환경 레코드)의 프로퍼티로 추가된다. 

- 전역 객체에 프로퍼티로 추가된 전역 변수들은 전역 환경의 환경 레코드(객체 환경 레코드)에 프로퍼티로 기록된다. 프로퍼티의 이름은 변수의 식별자, 프로퍼티 값은 undefined가 된다.

- 함수가 전역 객체에 프로퍼티로 추가되는 경우엔 함수 선언문을 함수 객체로 생성해서 프로퍼티로 기록한다.

  ```
  var a = { x: 1, y: 2 };
  console.log(window.a); // -> Object { x=1, y=2 }
  function norm(x) {...}
  console.log(window.norm); // -> norm(x)
  ```

- 이처럼 최상위 레벨에 선언된 함수와 변수는 프로그램을 평가하기 전에 이미 환경 레코드에 추가되있기 때문에 끌어올림 현상이 발생하는 것이다.

- var 문과 함수 선언문으로 선언한 전역 변수는 [[Configuable]] 속성이 false로 설정되어 있어 delete 연산자로 삭제할 수 없다.

- var 문을 사용하지 않고 변수를 선언해서 값을 할당하면(앞서 언급했던 선언 없는 값 대입)  프로그램의 실행 도중에 디스 바인딩 컴포넌트가 가리키는 객체의 프로퍼티로 추가된다. 위의 상황에선 디스 바인딩 컴포넌트가 전역 객체를 가리키므로 전역 객체에 추가된다. 이 경우 [[Configuable]] 속성이 true로 설정되어 delete 연산자를 통해 삭제할 수 있다.



### 8.5.7 프로그램 실행과 실행 문맥

- 실행 문맥은 **스택**의 구조로 관리된다.
- 실행 문맥은 프로그램 실행 중에 스택에 push되어 실행된다.
- 중첩 함수는 중첩 함수를 포함하는 함수의 실행 문맥에 포함되지 않고 따로 실행 문맥이 생성되어 push된다. 이 방식은 함수를 재귀적으로 호출한 경우에도 똑같이 적용한다.
- 재귀 호출한 함수는 호출한 함수와 같은 함수이지만 전혀 다른 함수로서 push된다.
- 실행 문맥 스택을 **호출 스택**이라고도 한다.



### 8.5.8 자바스크립트는 싱글 스레드

- 프로그램의 실행 방식에는 **싱글 스레드**와 **멀티스레드** 방식이 있다.
- **스레드**: 프로그램의 처리 흐름
- **싱글 스레드**: 프로그램 한 개의 처리 흐름. 프로그램을 순차적으로 실행
- **멀티 스레드**: 프로그램 여러 개의 처리 흐름. 동시에 작업을 여러 개 병렬로 실행
- 자바스크립트는 싱글 스레드 방식으로 작업을 처리한다. (예: 호출 스택에 쌓인 실행 문맥을 위에서부터 아래로 차례차례 실행)
- 이벤트 처리와 비동기 처리도 똑같은 방식으로 실행한다.
- **비동기 처리**: 특정 코드의 연산이 끝날 때까지 기다리지 않고 다음 코드를 진행하는 처리 방식. (예: 코드의 중간 부분에 지연 시간이 입력되어 있는 코드가 있을 때 그 지연 시간이 끝날 때까지 코드 진행을 멈추는 것이 아니라 바로 다음 코드로 넘어가는 것)

- 이벤트 처리와 비동기 처리는 실행하기에 앞서 이벤트 큐에 대기 행렬을 만든다. 그리고 현재 실행 중인 함수의 작업이 끝나면 대기 행렬에서 차례대로 호출 스택에 push된다.



### 8.5.9 환경 레코드와 지역 변수

- 환경 레코드는 함수 안팎의 환경을 기록한다. 이는 사용자로부터 읽거나 쓸 수 없으며 다음과 같은 정보를 기록하는 용도로 사용된다.
  - 함수의 인자
  - 함수 안에서 선언된 중첩 함수의 참조
  - 함수 안에서 var로 선언한 지역 변수
  - arguments
- 함수 선언문으로 생성한 함수 안의 지역 변수에는 그 함수의 함수 객체의 참조가 설정된다. 단, var로 선언한 지역 변수에는 undefined가 설정된다.
- 함수의 실행 문맥, 렉시컬 환경, 환경 레코드가 생성되면 실행 문맥의 디스 바인딩 컴포넌트에 그 함수를 호출한 객체의 참조를 저장하며, 이것으로 this 값을 결정한다. 이 this는 동적인 값이다.
- 함수가 종료되어 함수를 호출한 코드로 제어권이 돌아가면 일반적으로 실행 문맥과 그 안의 렉시컬 환경 컴포넌트가 메모리에서 지워진다. 허나 그 함수 밖의 함수의 참조가 환경 레코드에 유지되는 경우에는 렉시컬 환경 컴포넌트가 메모리에서 지워지지 않는다.



### 8.5.10 this 값

- this 값은 함수가 호출되어 실행되는 시점에 결정된다. 이 this 값은 함수가 호출되었을 때 그 함수가 속해 있던 객체의 참조이다.

  ```js
  var tom = {
  	name: "Tom",
  	sayHello: function() {
  		console.log("Hello!" + this.name);
          }
  };
  ```

  위 예제에서의 this는 tom 객체의 참조이다.

- 위의 특성을 이용해 다음과 같이 사용할 수도 있다.

  ```js
  var huck = { name: "Huck"};
  huck.sayHello = tom.sayHello;
  ```

  위 예제에서 huck.sayHello를 호출하면 this 값이 huck 객체가 된다.

아래는 다양한 상황에서의 this 값을 정리한 것이다.

1. ##### 최상위 레벨 코드의 this

   - 전역 객체를 가리킨다.

2. ##### 이벤트 처리기 안에 있는 this

   - 이벤트가 발생한 요소 객체를 가리킨다.

3. ##### 생성자 함수 안의 this

   - 생성자로 생성한 객체를 가리킨다.

4. ##### 생성자의 prototype 메서드 안의 this

   - 생성자로 생성한 객체를 가리킨다.

5. ##### 직접 호출한 함수 안의 this

   - 최상위 레벨에서의 함수 선언문의 this는 전역 객체를 가리킨다.



### 8.5.11 식별자 결정 : 유효 범위 체인

- 유효 범위가 겹치면서 이름이 같은 변수를 사용한다면 충돌이 발생한다. 이때 겹치는 변수가 어디에서 선언된 변수인지를 결정하는 작업을 **식별자 결정**이라고 한다.

- JS의 식별자 결정 규칙은 **더 안쪽 코드에 선언된 변수를 사용한다**이다.

- **속박 변수**: 함수의 인수와 지역 변수를 가리키는 말

- **자유 변수**: 속박 변수에 해당하지 않는 변수

- **닫힌 함수**: 속박 변수만을 가지고 있는 함수

- **열린 함수**: 자유 변수를 지니고 있는 함수

- ```js
  var a="A";
  function f() {
  	var b = "B";
  	function g() {
  		var c="C";
  		console.log(a+b+C);
  	}
  	g();
  }
  f(); // ->ABC
  ```

1. **속박 변수 c**
   - 변수 c는 함수 g 안에서 선언된 속박 변수이다. 이는 함수 g의 선언적 환경 레코드에 저장된다.
2. **자유 변수 b**
   - 변수 b는 함수 g의 바깥에서 선언된  자유 변수이다. 이는 함수 f의 선언적 환경 레코드에 저장된다.
   - 변수 b가 함수 f의 환경 레코드에 프로퍼티로 추가된 후 함수 g의 선언문이 평가되므로 함수 g의 외부 렉시컬 환경 참조에 저장된 f의 참조를 통해 변수 b를 함수 g에서 사용할 수 있게 된다.
3. **자유 변수 a**
   - a 또한 함수 g의 바깥에서 선언된 자유 변수이다.
   - a는 함수 f의 외부 렉시컬 환경 참조를 타고 올라가 전역 실행 환경의 렉시컬 환경 컴포넌트의 객체 환경 레코드에서 찾을 수 있다.

- 위의 과정처럼 식별자 결정은 외부 렉시컬 환경 참조를 타고 유효 범위 안에 존재하지 않는 식별자를 찾는다.
- 이러한 논리적인 연결고리를 **스코프 체인(ECMAScript3)** 또는 **외부 렉시컬 환경 체인** 또는 **유효 범위 체인**이라고 한다.



### 8.5.12 가비지 컬렉션

- 프로그램에서 객체를 사용하면 메모리 공간이 동적으로 확보된다. 반대로 사용하지 않는 객체의 메모리 영역은 **가비지 컬렉터**가 자동으로 해제한다. 이 매커니즘을 가리켜 가비지 컬렉션이라고 한다.

- 사용하지 않는 객체란 다른 객체의 프로퍼티와 변수가 참조하지 않는 객체를 말한다.

  ```js
  var p = {x:1, y:2};
  console.log(p);
  p = null;
  ```

  위 코드에서 변수 p가 null이 되면서 객체 {x:1, y:2}를 참조하는 변수가 없게 되므로 메모리에서 해제된다.

- 최근의 주요 웹 브라우저는 **마크 앤 스윕** 알고리즘을 사용한다. 전역 객체가 참조할 수 없는 객체를 찾아 해당 객체를 메모리에서 해제하는 방식으로 작동한다.





## 8.6 클로저

### 8.6.1 클로저

- **클로저**: 자기 자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행하는 함수 또는 그 기능을 구현한 자료 구조
- JS의 클로저는 함수 객체와 렉시컬 환경 컴포넌트의 집합이다.
- 8.5.11의 예제로 설명하자면 함수 g에서의 자유 변수 a, b의 식별자 결정을 실행한 함수 객체 g와 g가 참조하는 전역 실행 환경의 렉시컬 환경 컴포넌트(변수 a)과 함수 f의 렉시컬 환경 컴포넌트(변수 b)를 자유 변수의 식별자 결정을 위한 자료 구조라고 할 수 있다.
- 즉 함수 g의 함수 객체와 그 객체가 참조하는 함수 f의 렉시컬 환경 컴포넌트와 전역 실행 환경의 렉시컬 환경 컴포넌트가 클로저에 해당한다.
- 따라서 자바스크립트의 클로저는 **함수 객체와 렉시컬 환경 컴포넌트의 집합**이라고 할 수 있다.



### 8.6.2 클로저의 성질

- ```js
  function makeCounter(){
  	var count = 0;
  	return f;
  	function f() {
  		return count++;
  	}
  }
  var counter = makeCounter();
  //위 코드는 호출할 때마다 값이 1씩 증가한다.
  ```

  위 코드에서 주목해야 할 점은 2가지가 있다. 첫째는 외부 함수가 중첩 함수의 참조를 반환하고 있다는 사실이고 둘째는 중첩 함수가 외부 함수의 지역 변수를 참조한다는 사실이다. 

- 겉으로만 보면 위의 함수는 호출될 때마다 초기화되므로 호출할 때마다 1을 출력해야만 한다. 하지만 실제 결과는 카운터처럼 동작한다. 이 까닭은 전역 변수 counter가 makeCounter를 통해서 함수 f를 참조하고, 이 f는 자유 변수 count를 통해 makeCounter 함수의 렉시컬 환경 컴포넌트를 참조해 결국 전역 환경의 counter 변수가 makeCounter를 간접적으로 참조하고 있기 때문이다.

- 만약 클로저가 작동하지 않는다면 makeCounter 함수의 렉시컬 환경 컴포넌트는 가비지 컬렉터에 의해 메모리에서 해제된다.

- 클로저는 '캡슐화(프로퍼티를 쓸 수 있지만 겉으로는 은폐하는 행위)된 객체'에 빗댈 수 있다.

- ```js
  var counter1 = makeCounter();
  var counter2 = makeCounter();
  ```

  위의 코드를 호출하면 서로 다른 클로저가 생성된다. 마치 생성자와 비슷하다. 이처럼 클로저는 객체로 간주할 수도 있다.



### 8.6.3 클로저를 응용한 예제

1. ##### 여러 개의 내부 상태와 메서드를 가진 클로저

2. ##### 함수 팩토리

3. ##### 초기화 기능이 추가된 함수 생성하기

4. ##### 잘못된 예:  반복문 안에서 클로저 만들기



## 8.7 이름 공간

### 8.7.1 전역 이름 공간의 오염

- 전역 변수와 전역 함수를 전역 객체에 선언하는 행위를 '전역 유효 범위를 오염시킨다'라고한다.
- 전역 유효 범위가 오염되면 변수 이름이나 함수 이름이 겹칠 수 있다.
- 따라서 전역 유효 범위의 오염을 최소화해야 한다.



### 8.7.2 객체를 이름 공간으로 활용하기

- **이름 공간**: 변수 이름과 함수 이름을 한곳에 모아 이름 충돌을 미리 방지하는 공간
- JS에서는 객체를 이름 공간으로 활용할 수 있다.
- 객체를 값으로 가지는 전역 변수를 생성하여 그 객체에 프로그램 전체에서 사용하는 모든 변수와 함수를 프로퍼티로 정의하면 된다.



### 8.7.3 함수를 이름 공간으로 활용하기

- 함수는 변수를 은닉할 수 있기 때문에 이름 공간으로 활용할 수 있다.

- 즉시 실행 함수에 프로그램 전체를 작성하면 라이브러리의 전역 변수와 충돌하지 않을 수 있다.

- ##### 모듈 패턴

  - **모듈**: 기능(함수) 여러 개를 하나로 묶은 것
  - 즉시 실행 함수에 모듈을 작성하면 클로저에 의해 모듈의 내부 변수 이름 도는 함수 이름이 숨겨진다.



## 8.8 객체로서의 함수

### 8.8.1 함수는 객체

- JS의 함수는 Function 객체이자 **일급 객체**이다.
- **일급 객체**: 다음과 같은 특징을 가진 객체
  - 변수나 프로퍼티나 배열 요소에 대입할 수 있음
  - 함수의 인수로 사용할 수 있음
  - 함수의 반환값으로 사용할 수 있음
  - 프로퍼티와 메서드를 가질 수 있음
  - 익명 리터럴로 표현할 수 있음
  - 동적으로 생성 가능



### 8.8.2 함수의 프로퍼티

- | 프로퍼티 이름 | 설명                              |
  | ------------- | --------------------------------- |
  | caller        | 현재 실행 중인 함수를 호출한 함수 |
  | length        | 함수의 인자 개수                  |
  | name          | 함수를 표시할 때 사용하는 이름    |
  | prototype     | 프로토타입 객체의 참조            |



### 8.8.3 apply와 call 메서드

- Function 객체의 메서드에는 apply와 call이 있다.
- 두 메서드 모두 this 값의 호출과 함수의 인수를 사용하여 함수를 실행하는 메서드이다.
- apply는 함수의 인수를 배열의 형태로 넘기고 call은 쉼표로 값을 구분하여 넘긴다.



### 8.8.4 bind 메서드

- Function 객체의 bind 메서드는 객체에 함수를 바인드한다.

  ```js
  function say(greetings, honorifics){
  	console.log(greetings+" "+honorifics+this.name);
  }
  var tom = {name: "Tom Sawyer"};
  var sayToTom = say.bind(tom);
  sayToTom("Hello", "Mr."); // -> Hello! Mr.Tom Sawyer
  ```

- 위 코드에서 bind 메서드를 통해 sayToTom 변수에다가 변수 Tom의 값을 say 함수의 this 값으로 바인드(속박, 고정)시킨 것이다.



### 8.8.5 함수에 프로퍼티 추가하기

- 함수도 객체이므로 프로퍼티를 추가할 수 있다.

  ```js
  function f(x) {...}
  f.p = a;
  f.g = function() {...};
  ```

- Fucntion 객체에 추가된 프로퍼티는 그 함수를 실행하지 않고도 사용할 수 있다.

- **메모이제이션**: 함수 호출 시 함수의 인수와 그 반환값을 한 쌍으로 만들어 저장해 두는 기법. 함수에 한 번 실행한 적 있는 인숫값을 받으면 추가적인 계산은 생략할 수 있다.

- 메모이제이션을 저장하는 공간은 매우 다양하다. 그중에는 함수의 프로퍼티로 저장하는 방법도 있다.



## 8.9 고차 함수

### 8.9.1 고차 함수

- **고차 함수**: 함수를 인수로 받는 함수 또는 함수를 반환하는 함수



### 8.9.2 간단한 예

- 똑같은 작업을 하는 부분을 고차 함수로 만들어 주면 중복 코드를 줄일 수 있다.

- 수열 출력과 랜덤 알파벳 문자열 출력은 모두 지정 횟수만큼 반복문을 실행하여 그 실행값을 문자열로 만들어 준다는 공통점이 있다. 때문에 반복하는 부분과 문자열로 만드는 부분을 고차 함수로 만들면 코드를 최소화할 수 있다.

  ```js
  function joinStrings(n,f){
  	var s = "";
  	for(var = i=0; i<n; i++){
  		s+=f(i);
  	}
  	return s;
  }
  var digits = joinString(10, function(i) {return i; });
  var randomChars = joinStrings(8, function(i) {return String.fromCharCode(Math.floor(Math.random()*26) + "a".charCodeAt(0));
  });
  ```



### 8.9.3 메모이제이션

- ```js
  function memorize(f){
  	var cache = {};
  	return function(x) {
  		if(cache[x] == undefined) cache[x] = f(x);
  		return cache[x];
  	};
  }
  ```

- 위 예제는 함수를 인수로 받아 메모이제이션 기법을 적용하는 함수이다.





### 8.9.4 함수의 합성

- 함수 f(x)와 g(x)가 있을 때 함수 f(g(x))를 f와 g의 합성 함수라고 한다.

  ```js
  function compose(f, g) {
  	return function(x) {
  		return f(g(x));
  	};
  }
  ```



### 8.9.5 부분 적용

- 인수가 여러 개인 함수의 몇몇 인수를 상수로 지정해서 새로운 함수를 생성하는 기법을 **부분 적용**이라고 한다.

- ```js
  function product(x, y) {return x*y;}
  ```

  아래는 위 함수의 인수를 부분 적용한 함수이다.

  ```js
  product2 = function(y) { return product(2, y);};
  product2(3); // -> 6
  ```

- bind 메서드를 사용하면 다음과 같이 쓸 수 있다.

  ```js
  product2 = product.bind(null, 2);
  ```




### 8.9.6 커링

- **커링**: 인수를 2개 이상 받는 함수를 분해하여 인수가 하나인 중첩 함수로 변환하는 작업

- 아래의 두 함수는 원본 함수와 그 함수를 커링한 중첩 함수이다.

  ```js
  Math.pow(base, exponent) = pow(exponent)(base)
  ```

  ```js
  var pow = function(exponent) {
  	return function(base) {
  		return Math.pow(base, exponent);
  	};
  }
  ```

- 커링된 함수의 가장 큰 장점은 원본 함수를 부분 적용하기 쉽다는 것이다.

  ```js
  var square = pow(2);
  ```

  위 코드에서 square는 2라는 값이 부분 적용된 함수이다.





## 8.10 콜백 함수

### 8.10.1 콜백 함수

- **콜백 함수**: 다른 함수에 인수로 넘겨지는 함수

  ```js
  f(g);	// 함수 g가 콜백 함수에 해당
  function f(callback){
  	callback();
  }
  ```

- 콜백 함수는 함수를 호출했을 때 무언가 새로운 일이 생기거나 그 함수의 실행이 끝나고 지정한 콜백 함수를 실행해 주어야 하는 함수를 요청할 때 사용한다.
- 이 때 콜백 함수의 주체는 함수를 호출한 호출자(f)이다. 호출된 함수(g)는 콜백 함수를 실행할 뿐 작업 내용에는 관여하지 않는다.



### 8.10.2 이벤트 처리기

- 이벤트 처리기는 특정 이벤트 발생 시 실행하도록 등록된 함수이다. 이는 함수 호출 시 무언가 사건이 발생하면 콜백 함수가 실행되는 것과 닮았다.



### 8.10.3 타이머

- 타이머 메서드(setTimeout, setInterval)에 첫 번째 인수로 넘기는 함수가 바로 콜백 함수이다.



## 8.11 ECMAScript 6부터 추가된 함수의 기능

### 8.11.1 화살표 함수 표현식으로 함수 정의하기

- 화살표 함수 표현식의 함수 리터럴의 단축 표현이다.

##### 화살표 함수 표현식의 작성법

- 아래는 같은 함수를 각각 함수 리터럴과 화살표 함수 표현식으로 정의한 것이다.

  ```js
  var square = function(x) {return x*x; };
  ```

  ```js
  var square = (x) => {return x*x;};
  ```

- 인수가 여러 개일 경우 인수와 인수를 쉼표로 구분한다.

- 인수가 하나일 경우 인수를 묶는 괄호를 생략할 수도 있다.

  ```js
  var square = x => {return x*x;};
  ```

  단, 인수가 없는 함수는 괄호를 생략할 수 없다.

- 함수 몸통 안의 문장이 return뿐이라면 중괄호와 return 키워드를 생략할 수 있다.

  ```js
  var square = x => x*x;
  ```

- 함수 몸통 안의 문장이 return뿐이더라도 함수의 반환값이 객체 리터럴이라면 객체 리터럴을 그룹 연산자로 묶어야한다.

  ```js
  var f = (a, b) => ({x: a, y: b});
  ```

- 화살표 함수도 즉시 실행 함수로 사용할 수 있다.

  ```js
  (x => x*x)(3);
  ```

##### 함수 리터럴과 화살표 함수의 차이점

1. ###### this 값이 함수를 정의할 때 결정된다

   - 함수 리터럴을 함수가 호출될 때 this 값이 정해지는 반면 화살표 함수의 this 값은 정의할 때 결정된다. 즉, 화살표 함수 바깥 환경의 this 값이 화살표 함수의 this 값이 된다.
   - 화살표 함수는 call이나 apply 메서드를 사용하여 this를 바꾸어 호출해도 값이 바뀌지 않는다.
   
2. ###### arguments 변수가 없다

   - arguments 변수가 정의되지 않는다.

3. ###### 생성자로 사용할 수 없다

   - new 연산자를 사용할 수 없다.

4. ###### yield 키워드를 사용할 수 없다.

   - 이 때문에 제너레이터로 사용할 수 없다.



### 8.11.2 인수에 추가된 기능

##### 나머지 매개변수

- 함수의 인자가 들어가는 부분에 ...을 입력하면 입력받은 인수를 배열로 받는다. 이렇게 표현한 인자를 나머지 매개변수라고 한다.

  ```js
  function f(a, b, ...args) {
  	console.log(a, b, args);
  }
  f(1,2,3,4,5,6); // -> 1, 2, [3,4,5,6]
  ```



##### 인수의 기본값

- 함수의 인자에 대입 연산자를 사용하여 기본값을 설정할 수 있다. 이 때의 대입값에 다른 인자의 값도 사용할 수 있다.

  ```js
  function f(a, b=1){
  	return a*b;
  }
  f(3); // -> 3
  f(3, 2); // -> 6
  ```



### 8.11.3 이터레이터와 for/of 문

##### 이터레이션

- **이터레이션**: 반복 처리. 데이터 안의 요소를 연속적으로 꺼내는 행위



##### 이터레이터

- **이터레이터**: 반복 처리가 가능한 객체

- 배열의 이터레이터를 살펴보자. 배열은 Symbol.iterator 메서드를 가지고 있다. 이 메서드는 이터레이터를 반환한다.

  ```js
  var a[5,4,3];
  var iter = a[Symbol.iterator]();
  console.log(iter.next()); // -> Object {value: 5, done: false};
  console.log(iter.next()); // -> Object {value: 4, done: false};
  console.log(iter.next()); // -> Object {value: 3, done: false};
  console.log(iter.next()); // -> Object {value: undefined, done: true};
  ```

  iter의 next 메서드를 호출할 때마다 **이터레이터 리절트**라는 객체가 반환된다. 이 객체가 갖는 value와 done 프로퍼티는 각각 꺼내진 배열 요소의 값과 요소의 열거가 끝났는지를 뜻하는 논리값이 저장된다.

- 이터레이터는 일반적으로 두 가지 항목을 만족하는 객체이다.

  - next 메서드를 가진다.
  - next 메서드의 반환값이 value, done 프로퍼티를 가진 객체이다. 저장 값은 위의 예제와 같아야 한다.



##### 반복 가능한 객체와 for/of 문

- 이터레이터를 사용해서 이터레이션을 하려면 개발자가 적절한 처리를 직접 작성해야 한다.

- for/of 문을 사용하면 이러한 반복 처리를 자동으로 하도록 만들 수 있다.

  ```js
  //원 코드
  var a = [5, 4, 3];
  var iter = a[Symbol.iterator]();
  while(true){
  	var iteratorResult = iter.next();
  	if(iteratorResult.done == true) break;
  	var v = iteratorResult.value;
  	console.log(v);
  }
  
  //for/of 문
  var a = [5,4,3];
  for(var v of a) console.log(v);
  ```

  for/of 문은 이터레이터의 next 메서드를 순회할 때마다 매번 문장을 호출한다. done 프로퍼티의 값이 true가 아닌 동안은 value 프로퍼티의 값을 변수 v에 대입한다.

- 일반적으로 for/of 문은 2 조건을 만족하는 객체를 반복 처리한다.

  - Symbol.iterator 메서드를 가지고 있다.
  - Symbol.iterator 메서드는 반환값으로 이터레이터를 반환한다.

- Symbol.iterator 메서드를 가진 객체를 **반복 가능**한 객체라고 한다.

- Array, String(문자열), TypedArray, Map, Set의 생성자로 생성한 내장 객체는 모두 Symbol.iterator 메서드를 내장하고 있다.

  ```js
  for(var v of "ABC") console.log(b) // -> "A"
  "B"
  "C"
  ```



### 8.11.4 제너레이터

##### 제너레이터

- 다음과 같은 성질을 지닌 함수이다.
  - 반복 가능한 이터레이터를 값으로 반환한다.
  - 작업의 일시 정지와 재시작을 가능케하며 자신의 상태를 관리한다.



##### 제너레이터의 정의와 실행

```js
function* gen(){
	yield 1; // 포인트 1
	yield 2; // 포인트 2
	yield 3; // 포인트 3
}
var iter = gen();
console.log(iter.next()); // -> Object {value: 1, done: false}
console.log(iter.next()); // -> Object {value: 2, done: false}
console.log(iter.next()); // -> Object {value: 3, done: false}
console.log(iter.next()); // -> Object {value: undefined, done: true}
```

1. 위 코드에서 gen 함수는 제너레이터 함수이다. 이 함수는 호출되어도 바로 실행되지 않고 이터레이터를 반환한다.
2. next 메서드가 호출되면 함수의 첫 번째 yield 연산자의 위치까지 실행하며 이터레이터 리절트를 반환한다. 이 때 value 값으로 yield 표현식에 지정된 값을 저장하고 done 값으로 제너레이터 함수가 끝까지 실행됬는지를 저장한다. 그 후 제너레이터 함수는 포인트 1에서 일시 정지 상태가 된다.
3. 일시 정지된 위치에서 처리를 재개한다. 다음 포인트까지 진행한 후 위와 똑같은 처리를 한 후 일시정지된다.
4. 동일
5. 제너레이터 함수가 끝났으므로 마지막 출력값처럼 이터레이터 리절트를 반환한다.

- 위의 예시로 알 수 있듯이 yield는 제너레이터 함수에서 프로그램이 일시적으로 정지하는 위치이다.

- 제너레이터로 생성한 이터레이터의 next 메서드는 제너레이터 함수의 상태를 실행 상태로 바꾸는 역할을 한다. 반환값은 yield에 지정한 값이다.

- yield 표현식은 yield에 지정한 표현식을 값으로 가지며 이 자체를 변수에 대입할 수 있다.

  ```js
  //다음과 같이 사용가능
  yield;
  yield 표현식;
  
  var a = yield 2;
  ```



##### 제너레이터에 값 넘기기

- 제너레이터로 생성한 이터레이터의 next 메서드에 값을 대입하면 제너레이터에 값을 넘길 수 있다. 이 넘긴 값은 제너레이터가 일시적으로 정지하기 직전의 yield 표현식의 값으로 사용된다.



##### 제너레이터 종료하기 : return 메서드

- 제너레이터로 생성한 이터레이터의 return 메서드를 실행하면 인수 값을 반환한 후 제너레이터를 종료한다

  ```js
  function* g(){
  	yield 1;
  	yield 2;
  }
  var iter = g();
  iter.next();	// 1출력, done 값 false
  iter.return(10); // 10출력, done 값 true
  iter.next(); // undefined 출력, done 값 true
  ```



##### 제너레이터에 예외 던지기 : throw 메서드

- 제너레이터로 생성한 이터레이터의 throw 메서드를 실행하면 제너레이터에 예외를 던질 수 있다.

- 이 예외는 try/catch 문으로 받아서 처리한다.

  ```js
  function* idMaker() {
  	var count = 0;
  	while(true) {
  		try{
  			yield count++;
  		} catch(e) {
  			console.log("오류가 발생하였습니다.");
  		}
  	}
  }
  var iter = idMaker();
  console.log(iter.next()); // 0출력
  console.log(iter.next()); // 1출력
  iter.throw(new Error("오류")); // 오류가 발생하였습니다.
  // 2출력
  ```



##### 반복 가능한 객체에 위임하기 : yield*

- yield*에는 반복 가능한(이터러블) 객체를 지정한다. 지정된 객체에서 순차적으로 값을 꺼내 각각의 값에 yield를 적용한다.

  ```js
  function* f() {
  	yield "X";
  	yield "Y";
  }
  function* g() {
  	yield 0;
  	yield* [2,4];
  	yield* "AB";
  	yield* f();
  }
  var iter = g();
  for(var v of iter) console.log(v); // 0, 2, 4, A, B, X, Y를 순서대로 출력
  ```



### 8.11.5 템플릿 리터럴의 태그 함수

##### 태그가 지정된 템플릿 리터럴

- 템플릿 리터럴의 앞에 함수 이름을 적으면 템플릿 리터럴 안의 내용을 인수로 받는 함수를 호출할 수 있다.

  ```js
  func`${a} + ${b} = ${a+b}`
  ```

  이렇게 호출한 함수를 태그 함수라고 한다.

- 태그 함수의 첫 번째 인수는 문자열을 요소로 담은 배열이다. 이 배열의 요소는 템플릿 리터럴 안의 문자열을 ${...}를 기준으로 분할한 문자열이다. 두 번째 이후의 인수는 ${...} 안에 지정된 표현식을 평가한 값이 각각 순서대로 들어간다.

  ```js
  function list() {return arguments;}
  var t = list`a${1}b${2}c${3}`;
  console.log(t); // [["a", "b", "c"], 1, 2, 3]
  ```

- 템플릿 리터럴의 시작 부분이 문자열이 아닌 ${...}이라면 첫 번째 인수인 배열의 첫 요소가 빈 문자열로 들어온다. 이는 끝 부분도 마찬가지이다.



##### 태그 함수의 첫 번째 인수

- 태그 함수의 첫 번째 인수는 callSite 객체라고 하며 다음과 같은 특징이 있다.

1. **동결되어 있다**
   - 동결된 객체로 읽기만 할 수 있다. 즉, 프로퍼티의 추가, 삭제, 변경은 모두 불가능하다.
2. **callSite 객체는 캐시된다**
   - 처리한 적 있는 템플릿 리터럴 문자열을 만나면(플레이스 홀더는 제외) 캐시된 callSite 객체를 첫 번째 인수로 넘긴다.
3. **raw 프로퍼티가 있다**
   - raw 프로퍼티는 배열이며 요소는 첫 번째 인수의 배열과 같다. 단, 이스케이프되지 않은 문자열로 들어온다.