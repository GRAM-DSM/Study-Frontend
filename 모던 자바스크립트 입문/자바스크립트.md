

[TOC]

# 1장 자바스크립트의 개요

## 1.1 프로그래밍 언어로서의 자바스크립트

### 1.1.1 프로그래밍 언어

#### 프로그래밍 언어의 정의

- **프로그래밍 언어**: 컴퓨터 프로그램을 작성하기 위한 언어 = 소프트웨어의 동작(알고리즘)을 설명하는 언어
- **프로그래밍**: 프로그램을 개발하는 행위
- **소스 코드(코드)**: 프로그래밍 언어로 작성한 프로그램



#### 컴파일 언어와 인터프리터 언어

- **컴파일**: 소스 코드를 기계어로 번역하는 행위
- **컴파일러**: 컴파일을 수행하는 소프트웨어
- **컴파일 언어**: 소스 코드 여러 개를 하나로 묶어서 컴파일한 후에 실행하는 프로그래밍 언어. 컴파일 시 시간이 소모되지만 실행되는 속도는 빠르다. C, C++, Java 등
- **인터프리터 언어**: 프로그램을 한 줄마다 기계어로 번역해서 실행하는 프로그래밍 언어. 자바스크립트, Python, Ruby 등이 있다. 한 줄 한 줄 동작을 확인해 가면서 프로그램을 개발할 수 있지만 처리 속도가 느림.
- **인터프리터**: 프로그램을 번역해서 실행시키는 소프트웨어.



#### 프로그래밍 언어의 유형

프로그램을 만들어 가는 방식에 따른 프로그래밍 언어의 분류

- **절차적 언어**: 절차를 순서대로 작성해 나가는 프로그래밍 언어
- **객체 지향 언어**: 문제 해결에 관련된 데이터와 절차를 하나로 묶어 객체 단위로 관리하는 프로그래밍 언어
- **함수형 언어**: 프로그램을 함수를 조합하여 구현해 나가는 프로그래밍 언어
- **논리형 언어**: 데이터 사이의 관계와 논리를 설명해 나가는 프로그래밍 언어



### 1.1.2 자바스크립트의 특징

- **1. 인터프리터 언어이다.**
  - 인터프리터 언어이면서 JIT 컴파일러라는 자바스크립트 컴파일러가 웹 브라우저에 내장되어 있어 실행 속도도 매우 빠름
- **2. 동적 프로토타입 기반 객체 지향 언어이다.**
  - 프로토타입을 상속하는 프로토타입 기반 객체 지향 언어로 객체를 생성한 후에도 프로퍼티와 메서드를 동적으로 추가하거나 삭제할 수 있다.
- **3. 동적 타입 언어이다.**
  - 변수 타입이 없어 프로그램의 실행 도중에 변수에 저장되는 데이터 타입이 동적으로 바뀐다.
- **4. 함수가 일급 객체이다.**
  - 자바스크립트의 함수는 객체이며, 함수에 함수를 인수로 넘길 수 있다.
- **5. 함수가 클로저를 정의한다.**
  - 자바스크립트의 함수는 클로저를 정의한다. 클로저는 변수를 은닉하거나 영속성을 보장하는 등 다양한 기능을 구현할 수 있다.

### 1.1.3 자바스크립트의 기술적 요소

- **ECMAScript(코어 언어)**

  - 자바스크립트의 핵심 기술으로 ECMA라는 조직의 TC-39 위원회가 표준화 작업을 하고 있고, ECMA-262라는 문서로 공개하고 있다. 최신 버전은 ECMAScript 8이다. 

- **클라이언트 측의 고유한 기술 요소**

  - 웹 브라우저에서 동작하는 자바스크립트를 클라이언트 측 자바스크립트라 한다. 이는 ECMAScript가 규정한 코어 언어와 웹 브라우저의 API로 구성되어 있다. 웹 브라우저의 주요 API는 다음과 같다.

    | 명칭              | 기능                                                        |
    | ----------------- | ----------------------------------------------------------- |
    | Window 인터페이스 | 자바스크립트로 브라우저 또는 창을 조작하는 기능을 제공한다. |
    | DOM               | 자바스크립트로 HTML 문서의 요소를 제어하는 기능을 제공한다. |
    | XMLHttpRequest    | 서버와 비동기로 통신하는 기능을 제공한다.                   |

  - HTML5에 규정된 다양한 API도 사용할 수 있다.
  
    | 명칭             | 기능                                                         |
    | ---------------- | ------------------------------------------------------------ |
    | Drag and Drop    | HTML 요소 혹은 파일을 끌어서(드래그) 다른 HTML 요소에 놓을 때(드롭) 데이터를 전달하는 기능을 제공한다. |
    | Blob             | 이진 데이터를 다루는 기능을 제공한다.                        |
    | File             | 로컬 파일 시스템을 읽고 쓸 수 있는 기능을 제공한다.          |
    | WebWorkers       | 프로그램 여러 개를 멀티스레드로 병렬 처리하는 기능을 제공한다. |
    | Wdb Storage      | 대용량이며 저장 기간에 제한이 없는 데이터를 로컬에 저장하는 기능을 제공한다. |
    | Indexed Database | 로컬에 키-값(key-value) 타입의 관계형 데이터베이스 기능을 제공한다. |
    | WebSockets       | 서버와의 양방향 통신 기능을 제공한다.                        |
    | Geolocation      | GPS 등의 위치 정보를 다루는 기능을 제공한다.                 |
    | Canvas           | 2차원, 3차원 그래픽스 기능을 제공한다.                       |
  
- **서버 측 자바스크립트의 고유한 기술 요소**

  - *서버 측 자바스크립트*: 웹 서버에서 동작하는 자바스크립트
  - 아래는 서버 측 자바스크립트 실행 환경에 있는 구현체
    - **Node.js**: 구글이 개발한 자바스크립트 실행 환경
    - **Rhino**: 오픈 소스로 개발되어 현재는 모질라가 관리하고 있는 자바스크립트 실행 환경
    - **Aptana Jaxer**: 압타나(Aptana) 사가 개발하고 현재는 오픈 소스로 개발되고 있는 자바스클비트 실행 환경

### 1.1.4 ECMScript 6

- 새로운 ECMAScript 버전. ECMScript 2015라고도 한다.

- 아래는 이 버전에서 새로 추가된 주요 기능들이다.

  | 새로 추가된 기능                      | 키워드                                          | 장    |
  | ------------------------------------- | ----------------------------------------------- | ----- |
  | 템플릿 리터럴                         | 보간 표현식, 태그가 지정된 템플릿 리터럴        | 3,8장 |
  | Symbol                                | 유일무이한 불변 데이터 타입                     | 3,9장 |
  | 블록 범위                             | let 선언자, const 선언자                        | 4장   |
  | Math, Number, Strinng의 새로운 메소드 | 기능 향상, 유니코드 대응                        | 5장   |
  | 화살표 함수                           | 함수 정의의 약식 표기                           | 8장   |
  | 함수 매개변수에 추가된 기능           | 기본 매개변수, 나머지 매개변수                  | 8장   |
  | 이터레이터/제너레이터                 | 반복처리의 추상화, for/of 문                    | 8장   |
  | 객체 리터럴에 추가된 기능             | 계산된 프로퍼티 이름, 프로퍼티 정의의 약식 표기 | 9장   |
  | Object에 추가된 메소드                | assign, getOwnPropertySymbols 등                | 9장   |
  | 비구조화 할당                         | 배열과 객체의 값을 별도의 변수에 할당하기       | 10장  |
  | 전개 연산자                           | 반복이 가능한 객체를 배열 등에 할당하기         | 10장  |
  | Map, Set, WeakMap, WeakSet            | 컬렉션 타입 객체                                | 10장  |
  | ArrayBuffer와 형식화 배열             | 연속된 데이터 영역 이용하기                     | 10장  |
  | Array에 추가된 메소드                 | copyWithin, fill, entities 등                   | 10장  |
  | 정규 표현식에 추가된 메소드           | u 플래그, y 플래그, flags 프로퍼티              | 12장  |
  | Promise                               | 비동기 처리를 간략하게 작성하기                 | 15장  |
  | 클래스                                | 클래스 구문과 상속                              | 18장  |
  | 모듈                                  | import.export를 사용한 모듈 읽기와 내보내기     | -     |
  | Proxy, Reflect                        | 객체에 액세스할 때 처리를 추가하기              | -     |
  | 꼬리 재귀 최적화                      | 재귀 함수의 스택 오버플로우 해결하기            | -     |

  

# 2장 프로그램의 작성법과 실행법

## 2.1 실습 준비하기

### 2.1.1 웹 브라우저와 Node.js 설치하기

- 크롬과 Node.js 설치



### 2.1.2 텍스트 편집기 준비하기

- 메모장으로도 가능하지만 프로그램 작성용 편집기나 통합 개발 환경 설치가 편리



### 2.1.3 확장자를 표시하도록 설정하기

- 시작 메뉴에서 파일 탐색기를 선택하고 보기 탭의 파일 확장명을 체크한다.



## 2.2 간단한 예제

```javascript
function fact(n){
	if(n<=1) return n;
	return n*fact(n-1);
}
for(var i=1; i<10; i++){
	console.log(i+"!=" + fact(i));
}
```



## 2.3 프로그램 실행법

### 2.3.1 웹 브라우저의 콘솔에서 실행하기

**개발자 도구 켜기**

 윈도우 : ctrl + shift + I

**콘솔에서 프로그램 실행하기**

- shift + enter로 여러 줄을 입력하여 프로그래밍을 할 수 있다.

  

### 2.3.2 HTML 문서에 삽입하여 웹 브라우저로 실행하기

- HTML 문서 내에 자바스크립트 프로그램을 삽입하려면 <script> 요소를 사용하면 된다.
- 순수 자바스크립트 프로그램을 실행할 땐 script 요소를 body 요소에 배치하는 것이 좋다. 반대로 HTML 요소와 CSS 스타일을 제어할 때는 script 요소를 head 요소의 자식 요소로 배치하는 것이 좋다.(6장 참고)
- 위 예제를 html 문서에 삽입하고 console.log를 document.write로 바꾸면 출력 결과를 웹 페이지의 창 안에서 확인할 수 있다. 단 괄호 안의 부분에 + "< br / >"을 해주어야 줄바꿈이 적용된다.

##### 다른 자바스크립트 파일에 작성하기

- 자바스크립트 코드가 길어지면 위의 방법은 전체 HTML을 읽는 것에 불편함을 주므로 다른 파일에 자바스크립트 파일을 따로 만들어 주는 것이 좋다.

- <script src="./파일명.js"></script>의 방식으로 HTML 문서에 js 파일을 불러들일 수 있다.

### 2.3.3 Node.js에서 실행하기

- 명령 프롬프트를 사용하여 Node.js를 실행할 수 있다. 
- 디렉토리와 파일을 다루는 방법을 알고 있어야 사용 가능하다.

**Node.js의 대화형 모드로 실행하기**

- 명령 프롬프트에 node를 입력하여 Node.js를 대화형 모드(REPL)로 실행시킨다.

- 사용 방법은 크롬 콘솔과 큰 차이가 없다. 계산식을 입력하고 enter를 누르면 계산 결과가 표시된다.

- 자바스크립트 명령도 입력할 수 있다.

  ```js
  console.log("Hello, world!");
  ```

  위의 console.log()는 표준 출력(화면)에 괄호 안의 값을 표시한다.

- 프로그램을 아래와 같이 작성하면 Node.js가 자동으로 여러 줄을 입력하도록 해준다.

  ```js
  function fact(n){
  	if(n<=1) return n;
  	return n*fact(n-1);
  }
  ```

  개행을 한 채로 enter 키를 누르면 여러 줄 모드로 전환된다.

- ctrl c를 누르면 위의 여러 줄 모드를 강제로 해제할 수 있다.

- 편집기 모드를 활용하여 입력할 수 있다. .editor를 입력하면 된다.

  ```
  > .editor
  // Entering editor mode (^D to finish, ^C to cancel)
  function fact(n){
  	if(n<=1) return n;
  	return n*fact(n-1);
  }
  ```

- Node.js의 대화형 모드를 종료하려면 .exit를 입력하거나 ctrl c를 연속 두 번 누르면 된다.

**Node.js로 파일을 읽어 들여 실행하기**

- 규모가 큰 프로그램도 텍스트 편집기로 작성하거나 편집한 후에 실행시킬 수 있다는 장점이 있다.
- 예시: factorial.js가 gilbut이라는 유저의 js_study라는 디렉터리 안에 저장되어 있다. 아래의 방법들로 js 파일을 호출하고 이동할 수 있다.
  1. cd js_study 	(js_study 디렉토리로 이동)
  2. cd (현재의 디렉토리를 표시)
  3. dir (현재 디렉토리 안에 저장된 파일 목록을 표시)
  4. dir *.js (현재 디렉토리 안의 js 확장자를 지닌 파일의 목록을 표시)
- node 파일의 경로를 입력하면 Node.js에서 파일을 읽어 들일 수 있다. (ex: node factorial.js)



## 2.4 프로그램 작성법

### 2.4.1 문자 코드

- 자바스크립트 프로그램은 유니코드 문자로 작성한다.

### 2.4.2 대문자와 소문자

- 자바스크립트 프로그램은 알파벳 대문자와 소문자를 구별한다.

### 2.4.3 토큰과 공백 문자

##### 토큰

- **토큰**: 프로그램을 구성하는 최소 단위 (ex: 영어 문장의 경우 토큰=단어 I love you.의 경우 'I', 'love', 'you', '.'으로 분해된다. 즉, 토큰은 의미를 가지는 최소한의 문자 덩어리이다.) (ex: return n*fact(n-1);을 토큰으로 나누면 'return', 'n', 'fact', '(', 'n', '-', '1', ')', ';'처럼 된다.)
- **어휘 분석**: 자바스크립트 인터프리터가 프로그램 실행 전 프로그램을 토큰으로 분해하는 동작
- **구문 분석(파싱)**: 분해된 토큰들을 한 줄로 나열하고 이것을 자바스크립트의 구문 규약에 비추어 보았을 때 올바른 프로그램인지 판별하는 동작

##### 공백 문자

- 인접한 토큰을 공백 등에 넣지 않고 나열만 한다면 토큰을 판별할 수 없다.(ex: return n을 공백 없이 입력하면 returnn이 되어 return과 n을 하나의 토큰으로 인식한다.)
- 때문에 토큰과 토큰 사이에 공백 문자를 입력하여 구분한다.
- 공백 문자는 연속하여 입력해도 하나로 인식된다.

##### 공백 문자 생략하기

- 산술 연산자 앞뒤의 공백 문자, (){}[]와 같은 괄호 앞뒤의 공백 문자, 세미콜론(;), 쉼표(,), 콜론(:), 마침표(.) 앞뒤의 공백 문자는 생략할 수 있다.
- 위와 같은 토큰들은 **분리자 또는 구분자**라고 불린다.

##### 프로그램 가독성 높이기

- 사람들이 코드를 알아보기 쉽게 코드를 짜는 것을 프로그램의 가독성을 높인다고 한다. 아래의 예시를 보자.

  ```js
  function fact(n) {if(n<=1)return n;return n*fact(n-1);}
  
  function fact(n){
  	if(n<=1) return n;
  	return n*fact(n-1);
  }
  ```

### 2.4.4 문장

##### 문장

- 토큰을 나열한 후 세미콜론으로 마무리 짓는다. 아래는 여러 의미를 지닌 문장들이다.

  ```js
  console.log(i+"! = "+fact(i)); //괄호 안의 값을 콘솔에 출력
  var x; //변수 선언
  message = "Hi, "+name; // 표현식의 대입
  counter++; //변수 값 증가
  prompt("이름을 입력하십시오") // 함수 호출
  ```

##### 복합문

- 문장 여러 개를 중괄호({})로 감싼 코드를 복합문 또는 블록문이라고 한다.

  ```js
  {
  	sum = sum + x;
  	console.log("sum = "+x);
  }
  ```

- 복합문의 끝에는 세미콜론을 붙이지 않는다.

- 복합문 내의 문장은 중괄호를 기준으로 들여쓰기를 할 수 있다. 이는 프로그램의 가독성을 높히는 과정에 해당된다.

##### 빈 문장

- 문장이 하나도 없는 빈 문장이다. 이 문장이 쓰이는 경우는 7장에서 작성할 것이다.

  ```js
  ;
  ```

##### 세미콜론 자동 추가

- 문장을 작성하고 다음 줄에 문장을 작성하면 앞 문장 끝에 세미콜론이 없어도 자바스크립트 엔진이 자동으로 세메콜론을 추가하여 해석한다.

  ```js
  console.log("Hello")
  console.log("Hi")
  
  console.log("Hello");
  console.log("Hi");
  ```

- 단, 세미콜론을 생략한 줄이 다음 줄과 이어지고 있다고 판단하면 세미콜론은 자동으로 추가되지 않는다.

  ```js
  c = a+b
  (x+y).toString()
  
  c = a+b(x+y).toString();
  ```

- 세미콜론 자동 삽입 규칙에서 예외 처리 되는 것들이 있는데, return 문, break 문, continue 문이 있다.

  ```js
  return
  
  1;
  
  
  
  return;
  
  1;
  ```

### 2.4.5 주석

- 프로그램의 소스 코드에 삽입하는 설명문
- /* 주석문 */, // 주석문 의 2가지의 형식으로 주석문을 만들 수 있다. 
- /* 주석문 */의 형식은 코드의 토큰을 분할하지 않는 임의의 위치에 작성할 수 있다. 또한 여러 줄로 나누어 작성해도 문제가 발생하지 않고 줄 중간에 삽입할 수도 있다.
- // 주석문은 각 줄의 끝에 작성할 수 있다.



# 3장 변수와 값

## 3.1 변수

### 3.1.1 변수

- 값을 담는 저장 공간으로 각각의 변수에게 이름을 붙여야 한다.



### 3.1.2 변수 선언

- 자바스크립트에서 변수를 선언하려면 아래와 같이 작성해야 한다.

  ```js
  var 변수이름;
  ```

- 위 코드의 var은 자바스크립트의 키워드로 변수를 선언하기 위한 선언자이다. 이외에도 let, const라는 선언자가 있다.

- 자바스크립트에는 변수 타입이 존재하지 않아 모든 데이터 타입(정수, 문자 등)의 값을 저장할 수 있다.

- 쉼표를 사용하면 변수 여러 개를 한 개의 문장으로 선언할 수 있다.

  ```js
  var sum, a;
  ```

- 변수를 선언하기만 하고 값을 저장하지 않으면 변수 안에는 정의되지 않았음을 뜻하는 undefined라는 값이 들어간다.

  ```js
  var x;
  console.log(x); // -> undefined
  ```

- 등호를 사용해 변수에 값을 대입할 수 있다.

  ```js
  x = 2;
  ```

- 변수 선언과 동시에 초깃값을 설정할 수도 있다.

  ```js
  var x = 5;
  ```

- 위를 응용하면 다중 변수 선언과 동시에 초깃값을 설정할 수도 있다.

  ```js
  var a=1, b=2, c=3;
  ```



### 3.1.3 변수 선언 생략

- 선언되지 않은 변수 값을 읽으려고 시도하면 참조 오류가 발생한다.

  ```js
  console.log(x); // -> ReferenceError: x is not defined(오류 메시지)
  ```

- 그러나 var 문으로 선언하지 않은 변수에 값을 대입할 때는 오류가 발생하지 않는다. 이는 자바스크립트 엔진이 그 변수를 자동으로 **전역 변수**로 선언해주기 때문이다.

  ```js
  x = 2;
  console.log(x); // -> 2
  ```

  허나 이런 행위는 버그의 원인이 될 수 있으므로 변수는 반드시 선언하고 사용해야 한다.



### 3.1.4 변수 끌어올림과 변수 중복 선언

- 프로그램은 작성한 순서에 따라 윗줄부터 차례대로 실행되지만 변수 선언은 이 원칙을 따르지 않는다. 아래의 예시 코드를 참조하자

  ```js
  console.log(x);	// -> undefined
  var x;
  ```

  이처럼 프로그램 중간에서 변수를 선언하더라도 변수가 프로그램 시작점에 선언된 것처럼 다른 문장 앞에 생성되는 현상을 **변수 선언의 끌어올림(hoisting)**이라고 한다.

- 단, 선언과 동시에 대입을 할 경우 변수는 끌어 올려지지만 변수의 값은 끌어지지 않는다. var x =5;라는 문장이 있으면 var x만 끌어 올려지고 x=5는 분리되는 것이다.

  ```js
  console.log(x); // -> undefined
  var x = 5;
  console.log(x); // -> 5
  ```

- var 문으로 같은 이름을 가진 변수를 여러 개 선언하더라도 오류가 발생하지 않는다. 이는 같은 이름으로 선언된 변수 모드를 끌어올린 후에 단 하나의 영역에만 할당되기 때문이다.



### 3.1.5 변수의 명명 규칙

- 변수, 함수, 라벨 이름 등 사용자가 정의하는 이름을 식별자라고 한다. 이를 정할 땐 다음의 규칙을 준수해야 한다.
  - 사용할 수 있는 문자에는 알파벳(a~z, A~Z), 숫자(0~9), 언더바(_), 달러 기호($)가 있다.
  - 식별자의 첫 글자는 숫자 사용이 불가하다.
  - 예약어를 식별자로 사용할 수 없다.(예약어는 3.1.6 예약어 참조)
- 프로그램의 크기가 커질수록 변수도 많아지므로 변수 이름을 짓는 표기법을 따라 작성하면 변수의 의미(역할)을 쉽게 알 수 있다. 표기법은 아래와 같다.
  - **캐멀 표기법(로어 캐멀 표기법)**: 변수명이 2개 이상의 단어일 때, 두 번째 이후 단어의 첫 글자를 대문자로 표기하고 나머지는 소문자로 표기한다.(ex: newName	createLifeGame)
  - **파스칼 표기법(어퍼 캐멀 표기법)**: 각 단어의 첫 글자를 대문자로 표기하고 나머지는 소문자로 표기한다.(ex: NewName	CreateLifeGame)
  - **밑줄 표기법(스네이크 표기법)**: 모든 단어를 소문자로 표기하고 단어를 언더바로 구분한다.(ex: new_name	create_life_game)
- 아래는 변수 이름을 지을 때 일반적으로 사용하는 표기법이다.
  - 위에 명시된 표기법을 사용한다.
  - 기본적으로 영어 **단어**를 사용한다.
  - 루프 카운터 변수 이름으로는 i, j, k 등을 사용한다.
  - 상수는 대문자로 표현한다. ex) MAX_SIZE
  - 논리값(3.2.5 참조)을 표현하는 변수에는 이름 앞에 is를 붙인다. ex)isMouseDown
  - 생성자(4.3 참조) 이름을 붙일 때는 파스칼 표기법을 사용한다.



### 3.1.6 예약어

- **예약어**: 자바스크립트 문법을 규정짓기 위해 자바스크립트 언어 사양에서 사용하는 특수한 키워드(var 등)
- 쓰지 말아야할 예약어에는 예악어, 예약어가 될 키워드, 자바스크립트에 미리 정의된 전역 변수와 전역 함수가 있다.



## 3.2 데이터 타입

### 3.2.1 데이터 타입과 변수의 동적 타이핑

- **데이터 타입**: 변수에 저장하는 데이터의 종류(정수, 문자열 등)
- **정적 타입 언어**: 변수의 타입(정수 타입 변수, 부동소주점 타입 변수 등)과 일치하는 데이터만 저장할 수 있는 언어. C나 Java 등이 있다.
- **동적 타입 언어**: 실행 시 변수에 저장된 데이터 타입을 동적으로 바꿀 수 있는 언어. 자바스크립트가 이에 해당된다.



### 3.2.2 데이터 타입의 분류

##### 원시 타입

- 숫자, 문자열, 논리값, 특수한 값(undefined)과 심벌(symbol)이 이 타입에 속한다.
- 데이터를 구성하는 가장 기본적인 요소로 불변 값(값을 바꿀 수 없는 데이터, 리터럴)으로 정의되어 있다.

##### 객체 타입

- 변수 여러 개가 모여 만들어진 복합 데이터 타입
- 객체에 저장된 값은 바꿀 수 있다.
- 객체는 참조 타입으로 객체 타입의 값을 변수에 대입하면 변수에는 그 객체에 대한 참조(메모리에서의 위치 정보)가 할당된다.
- 배열, 함수, 정규 표현식 등이 있다.



### 3.2.3 숫자

- 자바스크립트에서 모든 숫자는 64비트 부동소수점으로 표현된다.

- 표현 가능한 최댓값과 최솟값은 다음과 같다.

  - 최댓값: 1.7976931348623157e+308
  - 최댓값: 4.940656458412465e-324

- 정수 값은 -2e+53 ~ 2e+53 범위의 값을 처리할 수 있다.

- 단, 배열 인덱스 값과 비트 연산은 32비트로 처리한다.

- **리터럴**: 프로그램에 직접 작성할 수 있는 상수 값.

- 아래는 특수한 숫자를 표현하기 위한 문자열이다.

  | 분류              | 표기법                   | 설명                               | 비고 |
  | ----------------- | ------------------------ | ---------------------------------- | ---- |
  | 전역 변수         | Infinity                 | 플러스 무한대                      |      |
  | 전역 변수         | NaN                      | 부정 값(숫자가 아님, Not a Number) |      |
  | Number의 프로퍼티 | Number.POSITIVE_INFINITY | 플러스 무한대                      |      |
  | Number의 프로퍼티 | Number.NEGATIVE_INFINITY | 마이너스 무한대                    |      |
  | Number의 프로퍼티 | Number.MAX_VALUE         | 표현할 수 있는 최댓값              |      |
  | Number의 프로퍼티 | Number.MIN_VALUE         | 표현할 수 있는 최솟값              |      |
  | Number의 프로퍼티 | Number.NaN               | 부정 값                            |      |
  | Number의 프로퍼티 | Number.EPSILON           | 2.220446049250313-16               | ES6  |
  | Number의 프로퍼티 | Number.MIN_SAFE_INTEGER  | -9007199254740990                  | ES6  |
  | Number의 프로퍼티 | Number.MAX_SAFE_INTEGER  | 9007199254740990                   | ES6  |

   

### 3.2.4 문자열

- **문자열 리터럴**: 프로그램에 직접 문자열을 작성한다. 작은따옴표('')나 큰따옴표("")를 문자열의 앞뒤에 붙여서 표현한다.

- "", ''처럼 빈 문자열을 만들 수도 있다.

- 자바스크립트를 HTML 요소에 끼워 넣을 때는 자바스크립트 프로그램을 문자열로 작성한다.

  ```html
  <input type="button" value="Click" onclick="alert('Thanks!')"
  ```

  위 상황에서는 HTML 코드에는 큰따옴표를 사용하고 자바스크립트 코드에는 작은따옴표를 사용하여 둘을 구분해주는 것이 좋다.

- 줄 바꿈 문자와 탭 문자 등은 문자열에 그대로 추가할 수 없다. 이러한 특수문자들은 아래의 이스케이프 시쿼스로 표현해야 한다.

  | 이스케이프 시퀀스 | 의미                                             | 비고 |
  | ----------------- | ------------------------------------------------ | ---- |
  | \0                | 널 문자                                          |      |
  | \b                | 백스페이스 문자                                  |      |
  | \t                | 수평 탭 문자                                     |      |
  | \n                | 개행 문자                                        |      |
  | \v                | 수직 탭 문자                                     |      |
  | \f                | 다음 페이지 문자                                 |      |
  | \r                | 캐리지 리턴 문자                                 |      |
  | \ '               | 작은따옴표 문자                                  |      |
  | \ "               | 큰따옴표 문자                                    |      |
  | \ \               | 역슬래시 문자                                    |      |
  | \xXX              | 두 자릿수 16진수 XX로 지정된 Latin-1 문자        |      |
  | \uXXXX            | 네 자릿수 16진수 XXXX로 지정된 유니코드 문자     |      |
  | \u{XXXXXX}        | 16진수 코드 포인트 XXXXXX로 지정된 유니코드 문자 | ES6  |



### 3.2.5 논리값

- 조건식이 참인지 거짓인지 표현하기 위해 사용하는 값.
- true, false로 구분된다.



### 3.2.6 특수한 값

- **값이 없음**을 표현하기 위한 특수한 값으로 null과 undefined가 있다.
- undefined는 정의되지 않은 상태를 뜻하며 다음과 같은 상황에 값이 undefined로 설정된다.
  - 값을 할당하지 않은 변수의 값
  - 없는 객체의 프로퍼티를 읽으려고 시도했을 때의 값
  - 없는 배열의 요소를 읽으려고 시도했을 때의 값
  - 아무것도 반환하지 않는 함수가 반환하는 값
  - 함수를 호출했을 때 전달받지 못한 인수의 값
- null은 아무것도 없음을 값으로 표현한 리터럴이다.



## 3.3 ECMAScript 6부터 추가된 데이터 타입

### 3.3.1 심벌

- ES6부터 새로이 추가된 원시 값이다.

- 자기 자신을 제외한 그 어떤 값과도 다른 유일한 값이다.

  ##### 심벌의 생성

  - Symbol()을 사용해서 생성한다.

    ```js
    var sym1 = Symbol();
    ```

  - Symbol()은 호출할 때마다 새로운 값을 만든다. 아래의 코드에서 sym1과 sym2의 값은 다르다.

    ```js
    var sym1 = Symbol();
    var sym2 = Symbol();
    ```

  - Symbol()에 인수를 전달하면 생성된 심벌의 설명을 덧붙일 수 있다.

    ```js
    var HEART = Symbol("하트"); // Symbol(하트)
    ```

  ##### 심벌과 문자열 연결하기

  - Symbol.for()를 활용하면 문자열과 연결된 심벌을 생성할 수 있다.

    ```js
    var sym1 = Symbol.for("club");
    ```

  - 전역 레지스트리에서 만들어진 심벌을 위에서 지정한 문자열로 불러올 수 있다.

    ```js
    var sym2 = Symbol.for("club");
    console.log(sym1 == sym2); //->true
    ```

  - 심벌과 연결된 문자열은 Symbol.keyFor()로 구할 수 있다.

    ```js
    var sym1 = Symbol.for("club");
    var sym2 = Symbol("club");
    console.log(Symbol.keyFor(sym1)); //->club
    console.log(Symbol.keyFor(sym2)); //->undefined
    ```

### 3.3.2  템플릿 리터럴

- 문자열 표현 구문이다.

- **템플릿**: 일부만을 변경하여 반복하거나 재사용할 수 있는 틀

- 템플릿 리터럴을 통해 표현식의 값을 문자열에 추가하거나 여러 줄의 문자열을 표현할 수 있다.

  ##### 기본적인 사용법

  - 템플릿 리터럴은 문자열을 역따옴표(`)로 묶어주면 사용할 수 있다.

    ```js
    `I'm going to learn Javascript.`
    ```

  - 템플릿 리터럴은 문자열 리터럴과 달리 일반적인 줄 바꿈 문자를 사용할 수 있게 해준다.

    ```js
    var t = `Man errs as long as 
    he strives.`; //템플릿 리터럴
    
    var t = `Man errs as long as\nhe strives.`; //문자열 리터럴 
    ```

    단, 문자열 리터럴처럼 이스케이프 시퀸스를 사용할 수도 있다.

    ```
  var t = `Man errs as long as
    he strives.`;
    ```
  
    
  
- 이스케이프 시퀀스 문자를 그대로 출력하려면 템플릿 리터럴 앞에 String.raw를 붙이면 된다.
  
  ```js
    var t = String.raw`Man errs as long as\nhe strives.`;
  
    var t = `Man errs as long as\\nhe strives.`;
  ```
  
  이 String.raw를 **태그 함수**라고 한다.
  
  ##### 보간 표현식
  
  - 템플릿 리터럴 안에는 **플레이스 홀더**를 넣을 수 있다. ${...}로 표기한다.
  
  - 플레이스 홀더 안의 ... 부분을 표현식으로 간주하여 평가한다. 이를 활용하여 문자열 안에 변수나 표현식의 결괏괎을 삽입할 수 있다.
  
    ```js
    var a = 2, b = 3;
    console.log(`${a} + ${b} = ${a+b}`); // -> 2 + 3 = 5
    var now = new Date();
    console.log(`오늘은 ${now.getMonth()+1} 월 ${now.getDate()}일입니다.`);
    // -> 오늘은 8 월 1 일입니다.
    ```




# 4장 객체와 배열, 함수의 기초

## 4.1 객체의 기초 1번 객체 리터럴

### 4.1.1 객체

- **객체**: 객체는 이름과 값을 한 쌍으로 묶은 데이터를 여러 개 모은 것이다. 즉, 복합 데이터로 **연관 배열** 또는 **사전**이라고도 부른다.
- 객체에 포함된 데이터 하나(이름과 값의 쌍)를 가리켜 객체의 **프로퍼티**라고 한다. 이 프로퍼티의 이름을 프로퍼티 이름 또는 키라고 부른다.
- 객체는 객체 리터럴을 사용하거나 생성자라는 함수를 사용하여 생성할 수 있다.

### 4.1.2 객체 리터럴로 객체 생성하기

- ```js
  var card = { suit: "하트", rank: "A"};
  ```

  위의 예시에서 {...} 부분이 객체 리터럴이다.

- 키와 프로퍼티 값은 콜론(:)을 사용하여 구분하고 프로퍼티들은 쉼표로 구분한다.

- 키로는 모든 식별자와 문자열 리터럴을 사용할 수 있다. 따라서 아래의 경우도 가능하다.

  ```js
  var card = { "suit": "하트", `rank`: "A"};
  ```

- 변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 마침표(.) 연산자 또는 대괄호 연산자를 사용한다.

  ``` js
  card.suit	// -> 하트
  card["rank"] 	// -> A
  ```

  마침표로 프로퍼티를 호출할 때는 키값만 사용할 수 있다. 허나 대괄호로 프로퍼티를 호출할 땐 키값 또는 문자열을 반환하는 표현식을 사용할 수 있다.

- 객체에 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환한다.

- 객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면 빈 객체가 생성된다.

  ```js
  var obj = {};
  console.log(obj);	// -> Object{}
  ```



### 4.1.3 프로퍼티 추가와 삭제

- 존재하지 않는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가된다.

  ```js
  var card = {};
  card.value = 14;
  console.log(card) // -> { value: 14 }
  ```

- delete 연산자를 사용하면 프로퍼티를 삭제할 수 있다.

  ```js
  delete card.value;
  console.log(card) // -> {}
  ```



### 4.1.4 in 연산자로 프로퍼티가 있는지 확인하기

- in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있다. 반환값은 true false이다.

- '프로퍼티 이름을 뜻하는 문자열 in 객체명'의 형식으로 사용한다.

  ```js
  var card = {suit: "하트", rank: "A"};
  console.log("suit" in card); // -> true
  console.log("color" in card); // -> false
  ```

- in 연산자는 객체가 가진 프로퍼티와 그 객체가 상속받은 모든 프로퍼티를 대상으로 조사한다.

  ```js
  console.log("toString" in card); // true
  ```

  위의 반환값이 true인 이유는 Object 객체를 card가 상속받았기 때문이다.



### 4.1.5 객체 리터럴 예제

아래는 객체 리터럴을 사용하는 예제들이다

1. ##### 좌표평면의 점을 표현하는 객체

   ```js
   var p = { x: 1.0, y: 2.5};
   ```

   

2. ##### 원을 표현하는 객체

   ```js
   var circle = { center: { x: 1.0, y: 2.0}, radius: 2.5};
   console.log(circle.center.x) // -> 1
   ```

   위 예제를 보면 객체의 프로퍼티 값으로 다른 객체를 대입할 수 있다는 것을 알 수 있다.

   

3. ##### 회원 정보를 표현하는 객체

   ```js
   var person = { name: "이정규", age: 18, sex: "남", married: false };
   ```



### 4.1.6 메서드

- 프로퍼티에 함수 타입의 값이 저장되어 있으면 그 프로퍼티를 메서드라고 한다.



### 4.1.7 객체는 참조 타입

- 객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 **참조**(메모리에서의 위치 정보)가 저장된다. 이 때의 변수 상태를 가리켜 객체를 참조하고 있다라고 한다.

  ```js
  var card = { suit: "하트", rank: "A"};
  ```

  위 코드에서는 변수 card가 객체를 참조하고 있다고 한다.

  ```js
  var a = card;
  ```

  card에는 객체의 참조가 저장되어 있는데, 이를 다른 변수에 저장할 수도 있다. 이 때 a를 통해 객체를 수정할 수 있다.

  ```js
  console.log(a.suit); // -> 하트
  a.suit = "스페이드";
  console.log(a.suit); // -> 스페이드
  console.log(card.suit); // -> 스페이드
  ```



## 4.2 함수의 기초

### 4.2.1 함수

- 어떠한 입력 값에 대해 출력 값을 주는 기능. 입력 값을 **인수**, 출력 값을 **반환값**이라고 부른다.



### 4.2.2 함수 선언문으로 함수 정의하기

- function 키워드로 정의한다.

  ```js
  function square(x) { return x * x; }
  ```



### 4.2.3 함수 이름

- 변수 이름과 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있다.
- 함수 이름은 일반적으로 함수의 기능을 알 수 있게 해주는 동사 또는 동사로 시작되는 어휘로 만든다.



### 4.2.4 함수 호출

- 함수를 호출할 땐 함수 이름 뒤에 소괄호로 인수를 묶어 입력한다.

  ```js
  square(3)	// -> 9
  ```

  이 때 인수로 넘긴 값인 3이 함수 정의문의 인수 x로 전달되어 중괄호를 거쳐 return 된다. 함수 호출 시에 전달되는 값을 인수, 함수 정의문의 인수를 인자라고 한다.



### 4.2.5 인수

- 인수는 여러 개로 받을 수도 있는데, 이 때 인수는 쉼표로 구분한다.

  ```js
  function dist(p, q){
  	var dx = q.x - p.x;
  	var dy = q.y - p.y;
  	return Math.sqrt(dx*dx+dy*dy);
  } // 두 점 사이의 거리를 구하는 함수 
  ```

  위의 Math.sqrt는 제곱근을 구하는 함수이다.

- 인수를 받지 않는 함수도 정의할 수 있다.

  ```js
  var bark = function() { console.log("Bow-wow");};
  
  bark(); // "Bow-wow"
  ```

  위 코드엔 인수도 return문도 존재하지 않아 제어권이 함수를 호출한 코드로 되돌아가면 함수의 반환값이 undefined가 된다.

  ```js
  console.log(bark()); // -> Bow-wow \n undefined
  ```



### 4.2.6 함수의 실행 흐름

1. 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다.
2. 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다.
3. return 문이 실행되면 호출한 코드로 돌아간다. 이 때 return의 값이 반환값이 된다.
4. return 문이 실행되지 않은 상태로 마지막 문장이 실행되면, undefined가 반환된다.



### 4.2.7 함수 선언문의 끌어올림

- 함수 선언문은 변수 선언문처럼 프로그램의 첫머리로 끌어올려진다.

  ```js
  console.log(square(5)); // -> 25
  function square(x) { return x * x; }
  ```



### 4.2.8 값으로서의 함수

- 자바스크립트에서는 함수가 객체이다. 함수 선언문으로 함수를 선언하면 내부적으로는 함수 이름을 변수 이름으로 한 변수와 함수 객체가 만들어지고, 그 변수에 함수 객체의 참조가 저장된다.

- 즉, 위 예제에선 변수 square가 함수 객체를 참조하고 있는 것이다. 

- 이 변수 값을 다른 변수에 할당하면 그 변수 이름으로 함수를 실행할 수 있다.

  ```js
  function square(x) { return x * x; }
  var sq = square;
  console.log(sq(5)); // -> 25
  ```

- 함수는 다른 함수의 인수로도 넘길 수 있다.



### 4.2.9 참조에 의한 호출과 값에 의한 호출

- 함수의 인수가 원시 값이냐 객체냐에 따라 동작하는 과정이 다르다.

- **원시 값**

  ```js
  function add1(x) { return x = x + 1; }
  var a = 3;
  var b = add1(a);
  console.log("a= ", + a + ", b = " + b); // -> a=3, b=4
  ```

  위 함수에서 인자 x는 변수 a의 복사본이다. 즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달된다. 이를 **값의 전달**이라고 부른다.

- **객체**

  ```js
  function add1(p) { p.x= p.x + 1; .y = p.y + 1; return p; }
  var a={x:3, y:4};
  var b=add1(a);
  console.log(a,b); // -> Object {x=4, y=5} Object {x=4, y=5}
  ```

  위 코드에서는 a가 객체의 참조를 저장하고 있기 때문에 p에 객체의 참조가 전달되고, 함수를 통해 객체가 수정되면서 a와 b가 같게 되는 것이다.

- ##### 인수 여러 개를 우아하게 전달하는 방법(elegant way)

  - 함수에 넘겨야 하는 인수 개수가 많아지면 

    - 인수의 순서를 착각하거나 
    - 함수가 받는 인수의 개수를 바꿨을 때 함수의 호출 방법이 바뀌어 프로그램 전체를 수정하는 등

    의 문제가 발생한다. 

    이러한 문제는 객체의 프로퍼티에 인수를 담아서 넘기는 방법으로 해결할 수 있다.

    ```js
    function setBallProperties(x, y, vx, vy, radius) {...}
    ...
    setBallProperties(0,0,10,15,5);
    //아래는 수정한 방법
    var parameters = {
    	x:0,
    	y:0
    	vx:10,
    	vy:15,
    	radius:5
    };
    
    function setBallProperties(params) { ... }
    ...
    setBallProperties(parameters);
    ```

    단, 함수 아나에서 객체의 프로퍼티를 수정한다면 호출한 코드에 있는 인수 객체의 프로퍼티가 함께 바뀌는 점을 주의해야 한다.



### 4.2.10 변수의 유효 범위

##### 전역 유효 범위와 지역 유효 범위

- **유효 범위**: 각 변수에 접근할 수 있는 범위.

- **어휘적 범위**: 프로그램의 구문으로 유효 범위를 정하는 방법. 자바스크립트는 어휘적 범위를 채택하였다.

- **동적 범위**: 프로그램 샐행 중 유효 범위를 정하는 방법.

- 자바스크립트 변수는 변수의 유효 범위에 따라 **전역 변수**와 **지역 변수**로 나뉜다.

- **전역 변수**는 함수 바깥에서 선언된 변수로 유효 범위가 프로그램 전체이다.

- **지역 변수**는 함수 안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부이다.

- ```js
  var a = "global";
  function f(){
  	var b = "local";
  	console.log(a); // -> "global"
  	return b;
  }
  f();
  console.log(b); // -> 에러 발생
  ```

  위의 코드에서 a는 전역 변수, b는 지역 변수이다.



##### 변수의 충돌

- 변수의 유효 범위는 각기 다른 부분에 있는 같은 이름의 변수가 충돌하지 않게 해준다.

- 때문에 전역 변수와 지역 변수의 이름이 같다면 충돌을 일으키게 된다.

- 전역 변수와 지역 변수 이름이 같다면 지역 변수를 사용하게 된다.

  ```js
  var a = "global";
  function f() {
  	var a = "local";
  	console.log(a); // -> local
  	return a;
  }
  f();
  console.log(a);	// -> global
  ```



##### 함수 안에서의 변수 선언과 변수 끌어올림

- 함수 안에서 선언된 지역 변수의 유효 범위는 함수 전체이다. 변수 끌어올림은 함수 내에서 적용된다.

  ```js
  function f() {
  	console.log(a); // 선언은 되었지만 값은 적용되지 않음 -> undefined 
  	var a = "local";
  	console.log(a); // -> local
  	return a;
  }
  ```

  



##### 함수 안에서의 변수 선언 생략

3.1.3에서 언급했듯이 변수를 선언하지 않고 값만 대입하면 자동으로 전역 변수로 선언된다. 이 현상은 함수 안에서도 발생한다.

```js
function f() {
	a = "local";
	console.log(a); // ->local
	return a;
}
f();
console.log(a); // -> local
```



### 4.2.11 블록 유효 범위 : let과 const

- 블록 유효 범위를 갖는 변수를 선언한다.
- 블록 유효 범위를 가진 변수는 중괄호 안에서만 유효하다.
- let은 변수 선언, const는 한 번만 할당 가능한 상수를 선언한다.

- ##### let 선언자

  - 블록 유효 범위를 갖는 지역 변수를 선언한다. 사용법은 var 문과 같다.

    ```js
    let x = "outer x";
    {
    	let x = "inner x";
    	let y = "inner y";
    	console.log(x); // -> inner x
    	console.log(y); // -> inner y
    }
    console.log(x);	// -> outer x
    console.log(y); // -> 에러 발생
    ```

  - let 문은 var 문과 달리 끌어올리는 현상이 발생하지 않고, 중복되는 변수를 선언하면 하나로 통일하지 않고 오류로 처리한다.

    ```js
    console.log(x); // -> 에러 발생
    let x = 5;
    ```

    ```js
    let x;
    let x; // 문법 오류	
    ```

- ##### const 선언자

  - 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다. 동작 규칙은 let 문과 동일하지만 반드시 초기화를 해야한다는 차이점이 있다.

    ```js
    const c = 2;
    c = 5; // -> 타입 에러
    ```

    const 문으로 선언한 변수에 다시 대입을 시도하면 위처럼 타입 오류가 발생한다. 그러나 상수 값이 객체이거나 배열일 경우에서 프로퍼티 또는 프로퍼티 값을 수정할 수 있다.

    ```js
    const origin = {x:1, y:2};
    origin.x = 3;
    console.log(origin); // -> Object {x:3, y:2}
    ```



### 4.2.12 함수 리터럴로 함수 정의하기

- 함수 리터럴을 통해 함수를 정의할 수 있다.

  ```js
  var square = function(x) { return x * x; };
  ```

  위 코드에서 function(x) {...} 부분이 함수 리터럴이다.

- 함수 리터럴은 이름이 없는 함수로 익명 함수 또는 무명 함수라고도 부른다.

- 함수 리터럴에는 끝에 세미콜론을 반드시 붙여야 한다.

- 함수 리터럴의 사용법은 함수와 같이 square(5)의 형식으로 사용하면 된다. 이는 두 함수 모두 내부적으로 square 변수에 함수 객체의 참조를 저장하기 때문이다.

- 함수와 함수 리터럴의 차이는 각각 끌어올려지느냐 아니냐의 차이이다.

  ```js
  console.log(square(3)); // 에러 발생
  var square = function(x) { return x * x; };
  ```

- 익명 함수에도 이름을 붙일 수 있다.

  ```js
   var square = function sq(x) { return x * x; };
  ```

  그러나 sq라는 이름은 함수 안에서만 유효하다. 이름이 없는 것과 있는 것의 차이는 디버거에서 이름으로 표시되느냐 anonymous function으로 표현되느냐의 차이를 지니고 있다.



### 4.2.13 객체의 메서드

- 객체의 프로퍼티 중 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 **메서드**라고 부른다.

- 메서드를 정의할 때는 프로퍼티 값으로 함수 리터럴을 대입한다.

  ```js
  var circle = {
  	center: { x:1.0, y:2.0 },
  	radius: 2.5,
  	area: function(){	// 원의 넓이를 구하는 메서드
  		return Math.PI * this.radius * this.radius;
  	}
  };
  ```

  함수 객체 안의 this는 그 함수를 메서드로 가지고 있는 객체를 가리킨다.

- 메서드는 일반 함수와 바찬가지로 소괄호를 붙여서 실행한다.

  ```js
  circle.area() // -> 19.63495...
  ```

- 메서드 또한 프로퍼티의 일종으로 나중에 추가할 수 있다. 위의 객체에 아래의 메서드를 추가할 수 있다.

  ```js
  circle.translate = function(a, b) {
  	this.center.x = this.center.x + a;
  	this.center.y = this.center.y + b;
  };
  ```

  ```js
  circle.translate(1,2);
  cercle.center; // -> Object {x=2, y=4}
  ```

- 이처럼 메서드는 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용한다. 일반적인 객체 지향 언어에서는 데이터와 그 상태를 바꾸는 메서드를 하나로 묶는 용도로 객체를 사용한다.



### 4.2.14 함수를 활용하면 얻을 수 있는 장점

##### 재사용할 수 있다

동일한 작업 반복을 함수 호출만으로 같은 작업을 여러 번 반복할 수 있다.

##### 만든 프로그램을 이해하기 쉽다

프로그램이 간결해지므로 프로그램의 흐름을 파악하기 쉬워진다.

##### 프로그램 수정이 간단해진다

똑같은 수정을 여러 반복할 필요가 없어지기 때문에 프로그램 수정이 간단해진다.



## 4.3 객체의 기초 2번 생성자

### 4.3.1 생성자로 객체 생성하기

- 자바, c++ 등은 다수의 객체를 생성하는 수단으로 클래스를 사용하지만 자바스크립트는 클래스가 없어 생성자라고 하는 함수로 객체를 생성한다.

##### 간단한 예

- 아래는 트럼프 카드를 표현하는 객체를 생성하는 생성자이다.

```js
function Card(suit, rank) {
	this.suit = suit;
	this.rank = rank;
}
```

- 생성자로 객체를 생성할 때는 new 연산자를 사용한다.

  ```js
  var card = new Card("하트", "A");
  ```

- 위 코드 실행 시 suit 프로퍼티에는 "하트", rank 프로퍼티에는 "A"라는 값이 저장된 객체가 생성되고, 그 객체의 참조가 변수 card에 할당된다.

  ```js
  console.log(card); // -> Card { suit: "하트", rank: "A"}
  ```

  이때 Card 생성자로 생성한 객체를 Card 객체라고 부른다.

##### 생성자

- 위처럼 new 연산자로 객체를 생성할 것이라 기대하고 만든 함수를 생성자라고 부른다.

- 생성자명은 관례적으로 첫 글자를 대문자로 쓰는 파스칼 표기법을 사용한다.

- 생성자 안에서 **this.프로퍼티 이름**에 값을 대입하면 그 이름을 가진 프로퍼티에 값이 할당된 객체가 생성된다. 위의 생성자는 아래의 객체 리터럴과 같다.

  ```js
  var card = {};
  card.suit = "하트";
  card.rank = "A";
  ```

- 생성자와 new 연산자로 생성한 객체를 그 생성자의 **인스턴스(실체)**라고 부른다. 객체 지향 언어에서 인스턴스는 클래스로 생성한 실체를 뜻하므로 엄밀히 말해 생성자로 생성한 객체는 아니지만 역할이 동일하므로 인스턴스라고 부른다.

##### 생성자의 역할

- 생성자는 객체를 생성하고 초기화하는 역할을 한다. 생성자를 사용하면 이름은 같지만 프로퍼티 값이 다른 객체(인스턴스) 여러 개를 간단히 생성할 수 있다.

  ```js
  var card1 = new Card("하트", "A");
  var card2 = new Card("클럽", "K");
  var card3 = new Card("스페이드", "2");
  ```

- 생성자는 함수이므로 프로퍼티에 값을 대입할 수 있다. 이를 활용하면 객체를 생성할 때 초기화 작업을 병행할 수 있다.

  ```js
  function Particle(x, y, vx, vy){
  	this.x = x;
  	this.y = y;
  	this.vx = vx;
  	this.vy = vy;
  	this.velocity = Math.sqrt(vx * vx + vy * vy);
  }
  var p = new Particle(0, 0, 3, 4);
  console.log(p); // -> Particle {x:0, y:0, vx:3, vy:4, velocity:5}
  ```



### 4.3.2 메서드를 가진 객체를 생성하는 생성자

- 생성자에서 **this.프로퍼티 이름**에 함수의 참조를 대입하면 메서드를 정의할 수 있다. 이때 메서드 함수 내부에 있는 this는 생성될 인스턴스를 가리킨다.

  ```js
  function Circle(center, radius) {
  	this.center = center;
  	this.radius = radius;
  	this.area = function() {
  		return Math.PI * this.radius * this.radius;
  	};
  }
  var p = {x:0, y:0};
  var c = new Circle(p, 2.0);
  console.log("넓이 = " + c.area()); // -> 넓이 = 12.56637...
  ```

  메서드 함수 안에서 this를 사용하면 그 값이 인스턴스의 프로퍼티임을 명시할 수 있다.



## 4.4 객체의 기초 3번 내장 객체

- 자바스크립트에는 내장되어 있는 객체가 마련되어 있다.

### 4.4.1 내장 생성자

- 자바스크립트에서 사용할 수 있는 생성자에는 기본적으로 내장되어 있는 '내장 생성자'가 있다.
- 목록은 추후 작성



### 4.4.2 Date 생성자

- Date 생성자는 대표적인 내장 생성자로 날짜와 시간을 표현하는 객체를 생성한다.

  ```js
  var now = new Date();
  ```

  위 문장을 실행할 시 실행한 시점의 날짜와 시간 정보를 담은 객체를 생성하고, 그 객체의 참조를 변수 now에 대입한다.

  ```js
  console.log(now);	//-> Date {Tue Aug 01 2017 09:41:54 GMT+0900 (KST)}
  ```

- Date 생성자의 인수로 날짜와 시간을 전달하면 그 날짜와 시간을 가리키는 Date 객체가 생성된다.

  ```js
  var then = new Date(2008, 5, 10);
  console.log(then);	// -> Date {Tue May 10 2008 00:00:00 GMT+0900 (KST)}
  ```

- Date 객체는 계산식 안에서 밀리초 단위 정수로 값의 타입이 바뀐다.

  ```
  var elapsed = new - then;
  console.log(elapsed);	//-> 245177916548
  ```

  이를 활용해 프로그램 실행에 걸리는 시간을 밀리초 단위로 구할 수 있다.

  ```js
  var start = new Date();
  /* 실행 시간을 측정할 코드를 작성하는 위치*/
  var end = new Date();
  var elapsed = end - start;
  ```

- 다음은 Date 객체가 제공하는 주요 메서드이다.(추후 작성)



### 4.4.3 Function 생성자

- 함수를 생성하는 내장 생성자

  ```js
  var square = new Function("x", "return x * x");
  ```

  첫 번째 인자인 "x"는 인수의 이름을 뜻하는 문자열이고 두 번째 인수는 함수 몸통이 작성된 문자열이다. 인수가 여러 개일 때는 인수 여러 개를 정렬 후 함수 몸통을 작성한다.

- Function 생성자로 생성한 함수는 전역 변수와 자신의 지역 변수만 읽고 쓸 수 있다는 단점이 있어 함수를 동적으로 생성해야 하는 상황 외에는 사용하지 않는다.

- 함수 리터럴에 래퍼 객체(5.3.2 참조)를 제공한다.

- 함수를 다룰 때 중요한 프로퍼티와 메서드가 정의되어 있으며, 이를 모든 함수에서 사용할 수 있다.



### 4.4.4 기타 내장 객체

- **내장 객체**: 내장되어 있는 객체로 내장 생성자로 생성한다.

  | 내장 객체 | 설명                                    | 설명하는 장 | 비고 |
  | --------- | --------------------------------------- | ----------- | ---- |
  | 전역 객체 | 프로그램 어디에서나 사용할 수 있는 객체 | 13장        |      |
  | JSON      | JSON을 처리하는 기능을 제공             | 9장         |      |
  | Math      | 수학적인 함수와 상수를 제공             | 5장         |      |
  | Reflect   | 프로그램의 흐름을 가로채는 기능을 제공  | -           | ES6  |

  

### 4.4.5 전역 객체

- 프로그램의 어느 위치에서나 사용 가능한 객체. 아래는 전역 객체의 프로퍼티이다.

  | 분류          | 프로퍼티                             | 설명하는 장 |
  | ------------- | ------------------------------------ | ----------- |
  | 전역 프로퍼티 | undefined, NaN, Infinity             | 13장        |
  | 생성자        | Object(), String(), Number() 등      | 9장         |
  | 전역 함수     | parseInt(), parseFloat(), isNaN() 등 | 5장         |
  | 내장 객체     | Math, JSON, Reflect                  | -           |

- 클라이언트 측 자바스크립트에서는 Window 객체가 전역 객체이다. 웹 브라우저의 전역 객체 프로퍼티는 콘솔에서 다음과 같이 입력하여 확인할 수 있다

  ```js
  console.dir(window);
  ```



### 4.4.6 자바스크립트 객체의 분류

##### 네이티브 객체

ECMAScript 사양에 정의된 객체로 내장 생성자로 생성된 객체와 JSON, Math, Reflect 등이 해당한다.

##### 호스트 객체

자바스크립트 실행 환경에 정의된 객체로 브라우저 객체(Window, Navigator, History, Location 등), DOM에 정의되어 있는 객체, Ajax를 위한 XMLHttpRequest 객체, HTML5의 각종 API 등이 클라이언트 측 자바스크립트에 정의된 호스트 객체의 예이다.

##### 사용자 정의 객체

사용자가 정의하고 생성한 객체



## 4.5 배열의 기초

### 4.5.1 배열 리터럴로 생성하기

- 배열 리터럴은 쉼표로 구분한 값을 대괄호로 묶어서 표현한다.

  ```js
  var evens = [ 2, 4, 6, 8];
  ```

  대괄호 부분이 배열 리터럴이며 배열 값 하나를 배열 요소라고 부른다.  배열 요소에는 왼쪽부터 순서대로 0부터 번호가 매겨져 있으며 요소에 매긴 번호는 **요소 번호** 또는 **인덱스**라고 부른다.

- 자바스크립트의 배열은 객체 타입이므로 배열을 변수에 대입하면 배열의 참조가 변수에 저장된다. 즉, 위 코드에선 변수 evens가 배열의 참조를 가지고 있는 것이다.

- 배열 리터럴 안에 요소를 작성하지 않으면 빈 배열이 생성된다.

  ```js
  var empty = [];
  console.log(empty);	// -> []
  ```

- 배열 리터럴 요소의 값을 생략하면 그 요소는 생성되지 않는다.

  ```js
  var a = [2, , 4];
  console.log(a);	// -> [ 2, undefined, 4]
  ```

  위 코드에서 인덱스가 1인 요소에 undifined가 표시되어 있지만 실제로는 존재하지 않는 것이다.

- 배열의 요소에는 변수와 마찬가지로 모든 타입의 값이 올 수 있다.

  ```js
  var various = [ 3.14, "pi", true, {x:1, y:2}, [2,4,6,8]]
  ```



### 4.5.2 length 프로퍼티

- length 프로퍼티에는 배열 요소의 최대 인덱스 값 + 1이 담겨 있다.

  ```js
  var evens = [2,4,6,8];
  evens.length;	// -> 4
  ```

  즉, 배열의 길이를 나타내는 것이다.

- 자바스크립트에서는 배열의 길이가 배열 요소의 개수를 뜻하지 않는 경우가 있으므로 주의해야 한다.(4.5.7 참조)

- length 프로퍼티에 현재의 배열 요소 개수보다 작고 0보다 큰 정수 값을 대입하면 배열 길이가 줄어든다. 설정한 배열 길이의 값보다 더 큰 인덱스 번호에 할당된 배열 요소는 삭제된다.

  ```js
  var a = ["A", "B", "C", "D"];
  a.length = 2;
  console.log(a);	// -> ["A", "B"]
  ```

- 반대로 현재의 length 프로퍼티에 현재의 배열 요소 개수보다 큰 값을 대입하면 length 프로퍼티의 값만 바뀐다.



### 4.5.3 Array 생성자로 생성하기

- 배열은 Array 생성자로 생성할 수 있다.

  ```js
  var evens = new Array(2,4,6,8);
  var empty = new Array();
  var a = new Array(2,4);
  var various = new Array(3.14, "pi", true, {x:1, y:2}, [2,4,6,8]);
  ```

- Array 생성자의 인수가 한 개이고 그 값이 양의 정수이면 인수는 배열의 길이를 의미하게 되어 그 길이만큼의 배열이 생성된다.

  ```js
  var x = new Array(3);
  console.log(x.length); // -> 3
  ```

  반면 인수가 한 개이고 그 값이 양의 정수가 아니면 오류가 발생한다.



### 4.5.4 배열 요소의 참조

- 특정 인덱스의 요소는 대괄호 연산자를 사용해서 읽거나 쓸 수 있다.

  ```js
  evens[2]	//	인덱스가 2인 요소. 즉, 세 번째 요소
  ```

- 배열 요소 하나는 변수 하나로 사용할 수 있다.



### 4.5.5 배열은 객체

- C나 Java에선 배열 요소가 메모리의 연속된 공간에 차례대로 배치되어 있어 인덱스를 지정할 시 인덱스가 가리키는 요소를 매우 빠르게 읽거나 쓸 수 있다.

- 하지만 자바스크립트의 배열은 Array 객체이며 객체로 배열의 기능을 가상으로 흉내 낸 것이다.

- Array 객체는 배열의 인덱스를 문자열로 변환해서 그것을 프로퍼티로 이용한다. 즉, 배열에 대괄호 연산자를 사용하는 것은 객체에 대괄호 연산자를 사용하는 것과 마찬가지이며, 배열의 요소 번호로 숫자 값 대신 문자열을 사용할 수도 있다.

  ```js
  var a = ["A", "B", "C", "D"];
  console.log(a["2"])	// -> C
  ```

  이 때 없는 배열 요소를 읽으려고 하면 undefined가 반환된다.

  ```js
  a[4] // -> undefined
  ```

  

### 4.5.6 배열 요소의 추가와 삭제

- 없는 배열 요소에 값을 대입하면 새로운 요소가 추가된다.

  ```js
  var a = ["A", "B", "C"];
  a[3] = "D";
  console.log(a);	//	-> ["A", "B", "C", "D"];
  ```

- push 메서드 사용 시 요소를 배열 끝에 추가할 수 있다.

  ```js
  var a = ["A", "B", "C"];
  a.push("D");
  console.log(a);	//	-> ["A", "B", "C", "D"];
  ```

- delete 연산자를 사용하면 특정 배열 요소를 삭제할 수 있다.

  ```js
  delete a[1];
  console.log(a);	//	-> ["A", undefined, "C", "D"]
  ```

  이 때 그 배열의 length 프로퍼티 값은 바뀌지 않는다.



### 4.5.7 희소 배열

- 배열에 요소를 추가하거나 제거했을 때 인덱스가 0부터 시작되지 않는 배열

  ```js
  var a = ["A", "B", "C"];
  a[4]="E";
  console.log(a); // -> ["A", "B", "C", undefined, "E"]
  ```

  위 코드의 결과를 보면 a[3]이 undefined라고 표시되지만 실제로 저 요소는 존재하지 않는다.

- 때문에 희소 배열의 길이는 배열 요소의 개수보다 크다.



# 5장 표현식과 연산자

## 5.1 연산자

### 5.1.1 표현식과 연산자

- **표현식**: 결과적으로 *어떤 값*으로 평가되는 것. 이 평가한다는 말은 표현식의 값과 변수, 함수 등의 값을 바탕으로 식의 값을 계산하는 행위를 뜻한다. 표현식은 가장 간단한 원시 값부터 객체 값까지 모두 표현식이다.

  ```js
  3.14, "hello", true, false, null // 원시 값
  sum, circle.radius, a[3], square(5), card.getSum() // 객체 값
  ```

- **연산자**를 이용하면 표현식을 조합할 수 있다.

  ```js
  a+b
  ```

- 위 예시에서 +는 연산자, a와 b는 연산 대상이 되는 표현식이며, 이를 **피연산자**라고 한다.

- +연산자처럼 좌우에 피연산자 두 개를 가진 연산자를 이항 연산자라고 한다. 이처럼 연산자는 피연산자의 개수에 따라 단항, 이항, 삼항으로 구분한다. -부호는 단항에 속한다.

- 삼항 연산자는 **?:** 뿐이다.

- 표현식은 왼쪽 피연산자 값부터 순서대로 평가되고, 연산자로 계산이 시작된다.(단, 일부 연산자(||, &&, ?:)에는 예외가 적용된다. 이 연산자들은 먼저 평가된 후 피연산자들을 평가한다.)

- 위의 예시에서 a, b 값이 각각 2, 3이라면 예시의 표현식은 2 + 3으로 평가된 후 계산된다.



### 5.1.2 연산자의 우선순위

- 연산자에는 우선 순위가 있다. 우선 순위가 가장 높은 연산자는 **그룹 연산자 (괄호)**이다.



### 5.1.3 연산자 결합 법칙

- 우선순위가 같은 연산자가 나열되어 있으면 좌우 중 어느 연산자와 결합하느냐에 따라 결고가 달라진다.

  ```js
  24/6*2
  ```

- 연산자에는 위와 같은 상황에서 좌우 중 어느 연산자와 연산할지를 결정하는 결합 법칙이 정해져 있다. 이에 대해서는 아래 표에서 서술할 것이다.

- 우선순위가 같을 때에는 좌->우 방향으로 결합한다.



### 5.1.4 연산자의 부수 효과

- +연산자처럼 변수 값을 바꾸지 않는 연산자도 있지만 x = y처럼 대입하는 표현식은 변수의 값을 바꾼다. 이러한 표현식은 **부수 효과가 있는 표현식**이라고 한다. 대입 연산자(=), 증감 연산자(++, --), delete 연산자가 이에 해당한다.

- 아래의 표는 연산자의 우선순위와 각 연산자의 결합 볍칙을 정리한 표이다.

  | 우선순위 | 연산자                                                       | 결합 법칙    |
  | -------- | ------------------------------------------------------------ | ------------ |
  | 1        | ()(그룹 연산자)                                              | 없음         |
  | 2        | . []                                                         | 왼쪽->오른쪽 |
  |          | new(인수 있음)                                               | 오른쪽->왼쪽 |
  | 3        | ()(함수 호출)                                                | 왼쪽->오른쪽 |
  |          | new(인수 없음)                                               | 오른쪽->왼쪽 |
  | 4        | ++(후위), --(후위)                                           | 없음         |
  | 5        | !, ~, +(단항), -(부호 반전), typeof, voidm delete, ++(전위), --(전위) | 오른쪽->왼쪽 |
  | 6        | *, /, %                                                      | 왼쪽->오른쪽 |
  | 7        | +, -, +(문자열 결합)                                         | 왼쪽->오른쪽 |
  | 8        | <<, >>, >>>                                                  | 왼쪽->오른쪽 |
  | 9        | <, <=, >, >=, in instanceof                                  | 왼쪽->오른쪽 |
  | 10       | ==, !=, ===, !==                                             | 왼쪽->오른쪽 |
  | 11       | &                                                            | 왼쪽->오른쪽 |
  | 12       | ^                                                            | 왼쪽->오른쪽 |
  | 13       | \|                                                           | 왼쪽->오른쪽 |
  | 14       | &&                                                           | 왼쪽->오른쪽 |
  | 15       | \|\|                                                         | 왼쪽->오른쪽 |
  | 16       | ?:                                                           | 오른쪽->왼쪽 |
  | 17       | yield, yield*                                                | 오른쪽->왼쪽 |
  | 18       | =, +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=, \|=           | 오른쪽->왼쪽 |
  | 19       | ...                                                          | 없음         |
  | 20       | ,                                                            | 왼쪽->오른쪽 |

  

## 5.2 산술 연산

### 5.2.1 산술 연산자

- 피연산자가 숫자인 연산자이다.
- 피연산자가 숫자가 아니면 연산자가 피연산자 타입을 숫자 타입으로 바꾸어 연산한다. 이 때 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때는 NaN이 나온다.

#### 산술 이항 연산자

- +, -, *, /, %가 있다.

  - 아래는 산술 이항 연산자를 쓸 때 몇 가지 주의 사항이다.

    1. **정수끼리 나누어도 결과가 부동소수점이 된다**

    2. **나머지 연산자의 피연산자는 부동소주점이다.**

    3. **+ 연산자는 피연산자 중 하나가 문자열이면 나머지 피연산자도 문자열로 만든다**

    4. ```js
       0/0 // -> NaN : 계산할 수 없음
       "one" * 1 // -> NaN : 계산할 수 없음
       true + true // -> 2 : 논리값의 타입을 숫자로 바꾸어 더함
       1 + null // -> 1 : null을 0으로 바꾸어 더함
       1 + undefined // -> NaN : undifined를 NaN으로 바꾸어 더함
       ```



#### 산술 단항 연산자

- 전후위 ++, -- 연산자와 +(아무것도 처리하지 않음), -(부호 반전) 연산자가 있다.



#### 산술 대입 연산자

- 대입 연산자와 산술 이항 연산자를 조합한 연산자



### 5.2.2 Math 객체의 프로퍼티

- JS는 복잡한 수학적 연산을 Math 객체로 지원한다.(sin, cos 등)



### 5.2.3 부동소수점과 정확도 문제

- JS에서 사용하는 64비트 부동소수점의 규격은 부호 1비트, 지수 11비트, 가수 52비트이다. 즉, 2진수 53자리(10진수 약 16자리)만큼의 가수 부분의 표현할 수 있다.
- **정확도 문제**: 숫자를 자릿수가 정해진 부동소수점으로 표현하여 계산하면 발생하는 오류
- **정밀도 손실**: 값이 가까운 두 수를 뺄셈할 때 발생하는 정확도 문제
- 10진수로 딱 떨어지는 값도 산술 연산을 내부적으로 2진수로 연산한다는 점 때문에 계산 결과가 어긋날 수 있다.



## 5.3 문자열 제어하기

### 5.3.1 문자열 연결

- +연산자는 피연산자가 모두 문자열이면 문자열로, 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 후 연결한다.

  ```js
  10 + "little indians"	//	-> "10 little indians"
  1 + {}	// ->"1[object Object]"
  true + (new Date())	// -> "trueTue Sat Aug ..."
  ```

  위에 해당하지 않는 경우 피연산자를 상황에 따라 숫자 또는 NaN 타입으로 바꾸어 더한다.



### 5.3.2 문자열을 조작하는 메서드

- JS에서는 문자열을 다루는 데 사용하는 **String 객체**를 내장하고 있다. 사용법은 생성자와 같다.

  ```js
  var msgObj = new String("Everything is practice");
  ```

- String은 문자열을 객체로 변환해준다. 이와 같이 원시 값을 객체로 변환하는 행위를 **래핑**한다고 한다.

- String을 통해 객체로 변환한 문자열에는 배열처럼 인덱스 번호가 지정되어 있다.

- String 객체는 다양한 프로퍼티와 메서드를 지니고 있다. 예시로 charAt() 메서드는 문자열의 인덱스 번호를 인자로 받아 그 인덱스 번호에 해당하는 문자를 구하는 기능을 가지고 있다.

- 문자열은 객체가 아니므로 프로퍼티를 지니고 있지 않다.  그럼에도 String 생성자가 동작 가능한 이유는 문자열이 자동으로 String 객체로 변환되기 때문이다.

  ```js
  var c = 'msg'.charAt(2);
  
  //내부적으로 실행되는 작업
  var msgObj = new String('msg'); // 문자열을 String 객체로 변환
  var c = msgObj.charAt(2);
  ```

  위에서 msgObj 객체는 일시적으로 생성되고 작업이 끝나면 사라진다. 이러한 객체를 **래퍼 객체**라고 한다.

- 위 예제에서 문자열을 String 객체로 변환하지 않고 바로 메서드를 호출하는 이유는 String 객체부터가 원시 값이 들어올 것으로 가정하고 작성한 코드이기 때문이다. 때문에 바로 메서드를 호출해 원하는 작업이 처리 가능하다.



### 5.3.3 String 생성자의 메서드

- String 생성자는 JS의 타 함수처럼 프로퍼티를 지니고 있다.



### 5.3.4 문자열을 배열로 읽고 쓰기

- 문자열을 읽을 때는 charAt() 메서드 대신 대괄호 연산자를 사용할 수 있다.

  ```js
  a= 'mag'
  a[2]	// -> g
  a[a.length-1]	// -> g
  ```

- 다만 배열과는 다르게 값을 대입해서 수정할 수는 없다. 만약 값을 대입하려고 시도할 경우 무시한다.



## 5.4 논리 연산자와 관계 연산자

### 5.4.1 관계 연산자

- 관계 연산자는 두 개의 피연산자의 비교 결과를 논리값(t/f)로 반환한다. ==, !=, ===(값과 타입이 같음), !==(값과 타입이 다름), <, >, <=, >= 이 관계 연산자에 해당한다.

##### 동일 연산자

- 동일(==) 연산자는 두 피연산자가 같은지를 판별한다. 피연산자의 타입에 따라 작동 방식이 다르다.
  - **좌우 피연산자의 타입이 같을 때**: 값이 같으면 true, 다르면 false이다. 타입이 원시 타입일 때는 단순히 값을 비교하지만 객체 타입인 경우 참조가 같은지를 판별한다.
  - **좌우 피연산자의 타입이 다를 때**: 같은 타입이 되도록 타입을 변환한 후 아래 규칙에 따라 동일 여부를 판별한다.
    - undefined와 null은 같은 것으로 친다.
    - 한쪽이 숫자, 다른 쪽이 문자열이면 문자열을 숫자로 변환하여 비교한다.
    - 둘 중 한쪽이 논리값이면 true는 1, false는 0으로 변환하여 비교한다.
    - 한쪽이 객체, 다른 쪽이 숫자 또는 문자열이면 객체를 toString이나 valseOf 메서드를 사용하여 원시 타입으로 변환한 다음에 비교한다.

##### 일치 연산자

- 일치(===) 연산자는 두 피연산자의 타입과 값의 동일 여부를 판별해준다.
- NaN은 NaN을 포함한 모든 값과 같지 않다고 판별한다.



### 5.4.2 논리 연산자

- 논리 연산자는 더욱 복잡한 논리를 정의한다. &&(논리곱, and), ||(논리합, or), !(부정, not)이 이에 해당한다.

##### 피연산자의 평가

- 논리 연산자의 피연산자는 논리값(true, false)가 아니어도 된다. 필요에 따라 타입이 자동으로 변하기 때문이다.

##### 논리곱 연산자와 논리합 연산자의 단락 평가

- **단락 평가**: 첫 번째 피연산자 값이 표현식을 결정하면 두 번째 피연산자를 평가하지 않는다.

- &&와 ||는 논리값 대신에 마지막으로 평가한 피연산자의 값을 반환한다.

- 아래는 예시이다.

  ```js
  a && b
  ```

  논리곱은 피연산자 둘 중 하나만 거짓이여도 거짓으로 처리되기 때문에 a가 거짓일 경우 b를 평가하지 않고 표현식의 전체 값이 false 처리 된다. 이 때의 반환값은 false가 아닌 a의 값으로 처리된다. 논리 값이 필요한 경우에는 a 값이 아닌 논리값으로 변환되어 반환한다.

- ```js
  a || b
  ```

  논리합은 피연산자 둘 중 하나만 참이여도 참으로 처리되기 때문에 a가 참일 경우 b를 평가하지 않는다. 위와 같이 true 대신 a의 값 자체를 반환한다.



## 5.5 비트 연산

### 5.5.1 비트 연산

- **비트 연산**: 2진수 숫자의 자릿수 값(비트 값)을 다루는 연산. 

- 비트 연산자는 피연산자를 부호 있는 32비트 정수로 변환해서 처리한다. 

- 비트 연산자에는 비트 논리 연산자와 비트 시프트 연산자가 있다.



### 5.5.2 비트 논리 연산자

- 비트 논리 연산자는 비트 값이 0이면 false, 비트 값이 1이면 true로 평가한다. 논리곱(AND), 논리합(OR), 배타적 논리합(XOR), 논리 부정(NOT)이 있고, 각각의 비트끼리 계산한다.



### 5.5.3 비트 시프트 연산자 

- 비트 시프트 연산자는 정수를 2진수 비트 단위로 오른쪽 또는 왼쪽으로 이동시키는(시프트하는) 연산자이다. <<(왼쪽 시프트), >>(부호 있는 오른쪽 시프트), >>>(부호 없는 오른쪽 시프트)
- 왼쪽 시프트: 비트가 이동하면서 생긴 빈 자리는 0으로 채워지고 넘친 값은 버려진다.
- (부호)오른쪽 시프트: 비트가 이동하면서 생긴 좌측의 빈 자리는 부호 비트로 채워지고 넘친 우측 비트 값은 버려진다.
- 오른쪽 시프트: 비트가 이동하면서 생긴 빈 자리는 0으로 채워지고 넘친 값은 버려진다.



### 5.5.4 비트 연산의 대입 연산자

- 산술 연산자와 마찬가지로 비트 연산자와 대입 연산자를 합칠 수 있다. &=, |=, ^=, <<=, >>=, >>>=가 있다.



## 5.6 기타 연산

### 5.6.1 typeof 연산자

- 단항 연산자로 피연산자의 데이터 타입을 반환한다.

  ```js
  var s = "ABC";
  console.log(typeof s);	// -> string
  ```

- typeof 연산자는 피연산자가 함수 이외의 객체인 경우 모두 object를 반환한다. 함수는 function을 반환한다.



### 5.6.2 조건 연산자

- 조건(?:) 연산자는 주어진 조건의 참과 거짓에 따라 값을 선택한다.

  ```js
  var parity = (a % 2 == 0)? "짝수" : "홀수";
  ```

  콜론을 기준으로 조건이 참일 경우 앞의 값을 반환하고 거짓일 경우 뒤의 값을 반환한다.



### 5.6.3 쉼표 연산자

- 쉼표 연산자는 이항 연산자로 왼쪽의 피연산자부터 차례대로 평가한 후 오른쪽 끝의 피연산자의 값을 반환한다.

- ```js
  i = 0, sum = 0, product = 1;
  ```

  위 표현식의 결괏값은 마지막 피연산자를 평가한 값인 1이 된다. 단, 위 대입문들은 모두 정상적으로 실행된다.

- 쉼표 연산자의 특징(반환값은 하나이지만 대입문은 정상 실행)을 이용하여 for문에 활용할 수 있다.

  ```js
  for(var i = 1, sum = 0; i<=10; i++){
  	sum += i;
  }
  ```

  본래 for 문의 소괄호 안에는 문장을 세 개만 넣을 수 있지만 위 코드에서는 더 많은 문장을 실행하였다.



### 5.6.4 eval 함수

- eval은 함수이지만 연산자의 역할을 담당하고 있다.

  ```js
  var x = 1;
  eval("x++;");
  ```

  eval 함수는 문자열 하나를 인수로 받아 그 문자열을 자바스크립트 코드로 해석한다.

- eval 함수는 eval 함수를 호출한 환경의 유효 범위 내의 변수를 사용할 수 있다.



## 5.7 명시적 타입 변환

### 5.7.1 숫자를 문자열로 변환하기

##### 숫자 + 문자열

- 숫자와 문자열을 + 연산자로 연결하면 숫자의 타입이 문자열로 바뀌어 더해진다.

  ```js
  10 + "cookies"	// -> "10cookies"
  100 + ""	// -> "100"
  ```



##### Number 객체의 메서드를 활용하는 방법

- 문자열을 객체로 바꾸는데 String 생성자가 있듯이 숫자를 개체로 바꿀 땐 Number 생성자를 통해 Number 객체로 변환해줄 수 있다.
- 이 Number 객체의 메서드를 통해 숫자를 문자열로 변환할 수 있다.



##### 스트링 함수를 활용하는 방법

- String 생성자에 new 연산자를 붙이지 않으면 문자열을 반환하는 일반 함수가 된다.

  ```js
  String(26) // -> "26"
  ```



### 5.7.2 문자열을 숫자로 변환하기

##### 수식 안에서 묵시적으로 변환하는 방법

- ```js
  var s = "2";
  s-0	//	-> 2
  +s // -> 2
  ```



##### parseInt 와 parseFloat 함수를 사용하는 방법

- 두 함수는 문자열을 해석해서 숫자로 바꾸는 함수이다. parseInt 함수는 문자열을 정수로, parseFloat 함수는 문자열을 부동소수점으로 바꾼다.
- 두 함수 모두 맨 앞의 문자만 숫자로 바꾸어 반환한다. 그 뒤에 다른 문자들이 있다면 그 문자들은 모두 무시한다. 만약 문자열의 맨 처음 문자가 숫자로 변환할 수 없다면 NaN을 반환한다.



##### Number 함수를 활용하는 방법

- Number 생성자 앞에 new 연산자를 붙이지 않으면 반환값이 숫자인 일반 함수가 된다.
- 단, Number 함수는 10진수만 처리할 수 있다.



### 5.7.3 논리값으로 변환하기

- 모든 값을 논리값으로 바꾸는 방법은 아래 두 가지가 있다.

  ```js
  !!x
  Boolean(x)
  ```

  - 위 코드에서 !는 논리 타입이 아닌 값을 논리 타입으로 바꾸면서 논리 값을 반대로 바꾼다. 때문에 ! 연산자를 하나 더 사용하여 원래의 논리 값으로 복구하여 준다.



# 6장 웹 브라우저에서의 입출력

## 6.1 대화상자 표시하기

### 6.1.1 대화상자

- **대화상자**: 입력을 하거나 메시지를 확인하기 위해 별도로 여는 창
- 대화 상자에서는 일반 텍스트만 표기 가능하며 줄 바꿈 문자 등은 이스케이프 시퀀스로 표현한다.
- **modal window**: 자식 창이 실행 중인 동안 부모 창이 동작하지 않도록 하는 자식 창을 가리킴. 대화 상자는 이에 해당한다. 
- 웹 브라우저에는 전역 객체 Window가 있다. 이 Window 객체는 대화상자를 표시하기 위한 메서드가 3개 있다.
- Window 객체의 메서드는 앞에 붙는 window. 부분을 생략하고 호출할 수 있다.



### 6.1.2 alert(경고 대화상자)

- alert 메서드는 경고 대화상자를 표시한다.

- 인수로는 경고 메시지로 출력할 문자열을 받는다.

  ```js
  alert("경고 메시지");
  ```

  ![image-20191110202911146](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110202911146.png)

- 확인 버튼을 누르면 대화상자가 사라지고 코드 제어권이 호출한 부분으로 돌아간다.



### 6.1.3 prompt(입력 대화상자)

- prompt 메서드는 입력 대화상자를 표시한다.

- 인수로는 입력을 안내하는 문자열을 받는다.

  ```js
  var name = prompt("이름을 입력하십시오");
  ```

  ![image-20191110203607638](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110203607638.png)

- 입력받은 문자열은 메서드의 반환값이 된다.
- 두 번째 인수로는 초기 입력 값을 지정할 수 있다.![image-20191110204926983](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110204926983.png)

- prompt는 문자열로 값을 반환하기 때문에 숫자 값을 구하려면 parseInt나 parseFloat 메서드를 사용해야 한다.



### 6.1.4 confirm(확인 대화상자)

- 확인 대화상자를 표시한다. 인수로는 확인받을 메시지를 뜻하는 문자열을 받는다.

  ```js
  var ret = confirm("링크를 표시하시겠습니까?");
  ```

  ![image-20191110205205701](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110205205701.png)

- confirm 메서드는 논리값을 반환한다.



## 6.2 console

### 6.2.1 Console 객체의 메서드

- 웹 브라우저의 Console 객체는 콘솔 출력을 돕는 다양한 기능을 제공한다.



### 6.2.2 콘솔에 텍스트 출력하기

- console.log, console.info, console.warn, console.error 메서드를 통해 문자열이나 변수 값을 출력할 수 있다. 이들의 차이점은 메서드에 따라 다른 양식을 지니고 있다는 것이다.

- Console 객체의 메서드에는 인수 여러 개를 쉼표로 구분해서 넘길 수 있다. 출력 시엔 각 값을 공백 문자로 구분해서 순서대로 출력한다.

  ```js
  var a = [2,4,6];
  console.log("배열", a, "의 길이는", a.length, "입니다.");
  // -> 배열 [2, 4, 6] 의 길이는 3 입니다.
  ```

  인수를 + 연산자로 연결하여 넘기면 공백 문자를 빼고 출력할 수 있다.

  ```js
  // -> 배열2, 4, 6의 길이는3입니다.
  ```

  서식 문자열을 사용하여 값을 지정된 서식으로 출력할 수 있다.

  ```js
  var name = "Tom";
  var height = 172.5;
  console.log("그의 이름은 %s 이며 키는 %f cm 입니다", name, height);
  // -> 그의 이름은 Tom 이며 키는 172.5 cm 입니다
  ```

   %s와 %f는 서식 문자열로 인수의 값을 서식 문자열에 해당하는 타입으로 변환하여 대입할 수 있다.



### 6.2.3 객체의 프로퍼티를 목록으로 표시하기

- console.dir 메서드는 객체의 프로퍼티를 나열한다. 인수로는 객체를 받는다.

- ```js
  var p = {x:1, y:2};
  console.dir(p);
  ```

  ![image-20191110223604132](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191110223604132.png)



### 6.2.4 타이머

- console.time과 console.timeEnd 메서드는 특정 코드의 실행 시간을 측정할 수 있다.

- ```js
  console.time("answer_time");
  alert("확인 버튼을 누르십시오");
  console.timeEnd("answer_time");
  ```

  console.time의 인자는 타이머 이름을 뜻하는 문자열이다. 위 코드에서는 확인 버튼을 눌러 프로그램이 종료되기까지의 시간을 측정해준다.



## 6.3 이벤트 처리기 등록하기와 타이머 알아보기

### 6.3.1 이벤트 처리기

- **이벤트**: 단말기와 앱이 처리할 수 있는 동작이나 사건(클릭 등)
- **이벤트 주도형 프로그램**: 이벤트가 발생할 때까지 기다리다가 이벤트가 발생하면 실행되는 프로그램.
- 웹 브라우저에서 동작하는 프로그램은 기본적으로 이벤트 주도형 프로그램이다.
- **이벤트 처리기**: 이벤트가 발생하면 실행되는 함수
- 함수를 이벤트 처리기로 등록하는 방법에는 세 가지가 있다. 그 중 2개만 이 절에서 설명한다.



### 6.3.2 HTML 요소의 속성에 이벤트 처리기 등록하기

- HTML 요소에 이벤트 처리기 속성을 설정하면 그 요소에 이벤트가 발생했을 때 설정한 동작이 동작한다.

- ```html
  <input type="button" value="click" onclick="displayTime()">
  ```

  위 코드는 버튼에 onclick(마우스로 클릭했음)이라는 이벤트 유형을 부여해준 것이다. 이 때 onclick을 이벤트 처리기 이름이라고 지칭한다.

- 이벤트 처리기 속성에는 이벤트가 발생했을 때 실행할 자바스크립트 문장을 문자열로 만들어 대입한다. 만약 문장을 여러 개 작성한다면 문장과 문장을 세미콜론으로 구분한 문자열을 대입한다.

- 이 방법은 JS 코드가 HTML 코드와 섞인다는 단점이 있다.



### 6.3.3 DOM에서 가져온 HTML 요소에 이벤트 처리기 지정하기

- **DOM(문서 객체 모델)**: 자바스크립트 등의 프로그램이 HTML 요소를 조작할 수 있게 하는 인터페이스

##### DOM 객체

- DOM에서는 HTML 문서나 HTML 요소를 가리키는 객체로 자바스크립트를 사용하여 HTML 문서를 조작한다.
- window: Window 객체라고 하며 웹 브라우저 탭 하나를 가리킨다.
- document: Document 객체라고 하며 HTMl 문서 전체를 가리킨다. HTML 문서에서 요소 객체를 가져오거나 HTMl 요소를 새로 만드는 기능 등이 있다.
- 요소 객체: HTML 문서의 요소를 가리키는 객체이다.



##### DOM을 사용해서 이벤트 처리기 등록하기

1. window.onload를 사용하여 HTMl 문서를 다 읽어 들인 후에 2와 3을 실행한다.
2. document.getElementById 메서드를 사용하여 특정 id 속성 값을 가진 HTMl 요소의 요소 객체를 가져온다.
3. 요소 객체의 이벤트 처리기 프로퍼티에 이벤트 처리기로 동작할 함수를 등록한다.

```js
//이 함수는 웹 브라우저가 문서를 모두 읽어 들인 후에 실행된다.
window.onload = function(){
	var button = document.getElementById("button");
	button.onclick = displayTime;
};
```

- HTML 전체 문서를 보면 위 코드는 head 요소의 자식 요소로 배치되어 있다. 이는 JS와 HTML 문서를 분리하기 위해서이다.
- 단, 위 방법대로라면 head 요소는 body 요소보다 먼저 실행되기 때문에 window.onload를 사용하여 HTML 문서 전체를 읽은 후 함수를 실행하도록 설정하였다.