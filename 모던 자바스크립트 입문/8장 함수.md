# 8장 함수

## 8.1 함수 정의하기

### 8.1.1 함수를 정의하는 방법

1. ##### 함수 선언문으로 정의하는 방법

   ```js
   function square(x) { return x*x; }
   ```

2. ##### 함수 리터럴로 정의하는 방법

   ```js
   var square = function(x) { return x*x; };
   ```

3. ##### Function 생성자로 정의하는 방법

   ```js
   var square = new Function("x", "return x*x");
   ```

4. **화살표 함수 표현식으로 정의하는 방법**

   ```js
   var square = x => x*x;
   ```

   8.11절에서 설명

위 방법 중 1번을 제외한 나머지 방법으로 정의한 함수는 변수에 그 함수의 참조를 할당해야 비로소 사용할 수 있는 상태가 되므로 함수 끌어올림의 대상이 되지 않고 때문에 함수를 호출하는 코드보다 앞에 위치해야 한다.



### 8.1.2 중첩 함수

- **중첩 함수**: 특정 함수의 내부에 선언된 함수
- 중첩 함수는 if 문이나 while 문 등의 문장 블록 안에는 작성할 수 없다 => 외부 함수의 최상위 레벨에만 중첩 함수를 작성할 수 있다.
- 중첩 함수의 참조는 중첩 함수의 외부 함수의 지역 변수에 저장되므로 외부 함수의 바깥에서는 사용할 수 없다.
- 중첩 함수는 자신의 외부 함수의 인수나 지역 변수에 접근할 수 있다.



## 8.2 함수 호출하기

## 8.2.1 함수를 호출하는 방법

1. ##### 함수 호출

   - 함수의 참조가 저장된 변수 뒤에 그룹 연산자인 ()를 붙여서 호출한다.

     ```js
     square(5);
     ```

2. ##### 메서드 호출

   - 메서드가 들어있는 프로퍼티를 호출하면서 그룹 연산자를 사용한다. 본질적으로 1과 같은 방법이다.

     ```js
     obj.m = function() {...};
     obj.m();
     ```

3. ##### 생성자 호출

   - 생성자의 참조를 저장한 변수 앞에 new 키워드를 추가한다.

     ```js
     var obj = new Object();
     ```

4. ##### call, apply를 사용한 간접 호출

   - 함수의 call, apply 메서드를 사용하여 함수를 간접적으로 호출할 수 있다. 9장에서 설명



### 8.2.2 즉시 실행 함수

- 일반적으로 익명 함수를 실행할 때는 익명 함수의 참조를 변수에 할당한 후 그룹 연산자 ()를 붙여서 실행한다.

  ```js
  var f = function() {...};
  f();
  ```

  하지만 JS에는 익명 함수를 정의하고 곧바로 실행하는 **즉시 실행 함수**라는 구문이 있다.

  ```js
  (function() {...})();
  (function() {...}());
  ```

  위의 두 가지 방법을 이용하면 익명 함수를 정의하는 동시에 실행할 수 있다.

- 즉시 실행 함수의 구문에서는 함수 정의식을 그룹 연산자 ()로 묶는다. 이는 괄호 안의 함수 정의식을 평가하여 함수 객체의 참조 값(함수 값)으로 바꾼다. 아래의 방법으로도 함수 정의식을 함수 값으로 만들 수 있다.

  ```js
  +function() {...}()
  ```

  가장 먼저 소개한 익명 함수를 변수에 할당하는 방법도 함수 정의식을 함수 값으로 변환하여 변수에 할당한 것이다.

- 즉시 실행 함수에도 인수를 넘길 수 있다.

  ```js
  (function(a, b){...})(1, 2);
  ```

- 즉시 실행 함수에도 이름을 붙일 수 있지만 함수 내부에서만 유효하다.(사용 예: 재귀 함수)

- 함수 실행 결과를 변수에 할당할 수 있으며 표현식 안에서 사용할 수 있다.

  ```js
  var x = (function(){...})();
  ```



## 8.3 함수의 인수

### 8.3.1 인수의 생략

- 함수 정의식에 작성된 인자 개수보다 인수를 적게 전달해서 함수를 실행하면 생략된 인자는 undefined가 된다.

  ```js
  function f(x, y){
  	console.log(x, y);
  }
  f(2);	// -> x undefined
  ```

- 위의 성질을 활용하면 인수를 생략할 수 있는 함수를 정의할 수 있다. 단, 인수를 생략했을 시의 초깃값을 설정해야 한다.

  ```js
  function multiply(a, b){
  	b = b || 1;
  	return a*b;
  }
  multiply(2); // -> 2
  ```



### 8.3.2 가변 길이 인수 목록(Arguments 객체)

- 모든 함수에는 arguments라는 지역 변수가 있다. 이 변수의 값은 Arguments 객체로 함수의 인수 값을 유사 배열 객체(10.3절 참조)의 형태로 저장한다.

- Arguments 객체는 프로퍼티로 length(인수의 개수)와 callee(현재 실행되고 있는 함수의 참조)를 갖고 있다.

- arguments[i]의 값을 바꾸면 이에 해당하는 인자의 값도 바뀐다.

  ```js
  function f(x, y){
  	arguments[1] = 3;
  	console.log(x, y);
  }
  f(1, 2)	// -> 1 3
  ```

  일반적인 배열에는 이러한 특징이 없다.

- arguments 변수를 활용하면 인수의 개수가 일정하지 않은 가변 인수 함수를 정의할 수 있다.

  ```js
  function myConcat(separator){
  	var s = "";
  	for(var i=1; i<arguments.length; i++){
  		s += arguments[i];
  		if( i < arguments.length-1 ) s += separator;
  	}
  	return s;
  }
  console.log(myConcat("/", "apple", "orange", "peach")); // -> apple/orange/peach
  ```

  위의 코드에서 apple, orange, peach는 인자로서 받아들여지진 않았지만 arguments 변수에는 저장되어 있었기에 위와 같은 코드를 만들 수 있었다. 이처럼 JS의 함수에서는 작성된 인자 개수보다 더 많은 개수의 인수를 넘겨서 함수를 실행할 수 있다.

- arguments[]는 앞서 말했듯이 유사 배열 객체이지만 다음의 방법을 사용하면 배열 객체로 변환할 수 있다.

  ```js
  var params = [].slice.call(arguments);
  ```

  slice는 배열의 메서드로 10.1.3절에서 설명을, call 메서드를 사용한 메서드의 호출 방법은 8.8.3절에서 설명할 것이다.

## 8.4 재귀 함수

- 함수가 자기 자신을 호출하는 행위를 **재귀 호출**, 이러한 호출을 수행하는 함수를 **재귀 함수**라고 한다.

### 8.4.1 재귀 함수의 기본

- 팩토리얼을 반환하는 함수를 여러 가지 방법으로 표현하였다.

  ```js
  // 함수 선언문
  function fact(n) {
  	if(n<=1) return 1;
  	return n*fact(n-1);
  }
  // 함수 리터럴
  var fact = function f(x){
  	if(n<=1) return 1;
  	return n+f(n-1);
  }	// 함수 이름은 함수 안에서만 유효하다.
  // 함수 리터럴(익명 함수)
  var fact = function(n) {
  	if(n<=1) return 1;
  	return n*arguments.callee(n-1);
  }	// callee가 현재 실행 중인 함수의 참조를 뜻하기 때문에 익명 함수가 한 번 더 실행된다.
  ```

- 재귀 함수를 정의할 때는 유의해야 할 사항이 2가지 있다.

  1. **재귀 호출은 반드시 멈춰야 한다**
     - 재귀 함수를 짤 때에는 재귀 호출이 멈출 수 있는 조건을 만들어주어야만 한다. 그렇지 않으면 재귀 함수에서 코드가 빠져나오지 못한다.
  2. **재귀 호출로 문제를 간단하게 해결할 수 있을 때만 사용한다**
     - 재귀 호출로 재귀 함수가 여러번 실행되면 메모리의 사용량이 증가한다.  때문에 반복문으로 해결할 수 있는 문제에는 재귀 함수를 사용하지 않는 것이 좋다.

### 8.4.2 재귀 함수의 예

하노이의 탑(아래에선 막대기 3개로 판 4개를 옮기는 방법을 구현한 재귀 함수

```js
function hanoi(n, a, b, c) {
	if(n<1){return;}
	hanoi(n-1, a, c, b);
	console.log(n + " 번째 원반: " + a " -> " + c);
	hanoi(n-1, b, a, c);
}
hanoi(4, "A", "B", "C");
```

## 8.5 프로그램의 평가와 실행 과정

### 8.5.1 실행 가능한 코드

- JS 엔진은 **실행 가능한 코드**를 만나면 그 코드를 평가해서 **실행 문맥(실행 환경)**으로 만든다.
- 실행 가능한 코드로는 전역 코드, 함수 코드, eval 코드가 있다.
- **전역 코드**: 전역 객체 Window 아래에 정의된 함수
- **함수 코드**: 함수
- **eval 코드**: eval 함수



### 8.5.2 실행 문맥의 구성

- **실행 문맥(실행 환경)**: 실행 가능한 코드가 실제로 실행되고 관리되는 영역으로 실행 가능한 코드를 만날 때마다 생성된다.

- 실행에 필요한 모든 정보는 컴포넌트 여러 개가 나누어 관리한다.

- **컴포넌트**: 프로그래밍의 한 부분으로 재사용이 가능한 최소 단위를 지칭한다.

- 중요한 컴포넌트로는 **렉시컬 환경 컴포넌트, 변수 환경 컴포넌트, 디스 바인딩 컴포넌트**가 있다.

- 아래는 JS의 객체 표현을 빌려 실행 문맥을 표현한 것이다.

  ```js
  //실행 문맥
  ExecutionContext = {
  	//렉시컬 환경 컴포넌트
  	LexicalEncironment: {},
  	//변수 환경 컴포넌트
  	VariavleEnvironment: {},
  	//디스 바인딩 컴포넌트
  	ThisBinding: null,
  }
  ```

- ##### 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트

  - 두 컴포넌트는 앞으로 설명할 **렉시컬 환경** 타입의 컴포넌트이다.
  - 이 두 컴포넌트는 타입과 내부 값이 같다.(with 문을 사용할 때는 제외) 따라서 똑같이 취급해도 큰 문제가 발생하지 않는다.

- ##### 디스 바인딩 컴포넌트

  - 함수를 호출한 객체의 참조가 저장되는 컴포넌트
  - 이 컴포넌트가 가리키는 값이 곧 해당 실행 문맥의 this가 된다.(8.5.9절)



### 8.5.3 렉시컬 환경 컴포넌트의 구성

- 함수 또는 블록의 유효 범위 안에 있는 식별자와 그 결괏값이 저장되는 곳

- **환경 레코드**와 **외부 렉시컬 환경 참조** 컴포넌트로 구성되어 있다.

- 아래는 JS의 객체 표현을 빌려 렉시컬 환경 컴포넌트를 표현한 예제이다.

  ```js
  LexicalEnvironment: {
  	//환경 레코드
  	EnvironmentRecord: {},
  	//외부 렉시컬 환경 참조
  	OuterLexicalEnvironment Reference: {}
  }
  ```

- ##### 환경 레코드

  - 유효 범위 안에 포함된 식별자를 기록하고 실행하는 영역
  - 유효 범위 안의 식별자와 결괏값을 바인드(연관시키다)해서 환경 레코드에 기록한다. 

- ##### 외부 렉시컬 환경 참조

  - 함수를 둘러싸고 있는 코드가 속한 렉시컬 환경 컴포넌트의 참조를 저장
  - JS 엔진은 JS의 기능상(함수 중첩) 유효 범위 너머의 유효 범위를 검색할 수 있어야 한다. 외부 렉시컬 환경 참조는 이를 구현한다.
  - 중첩된 함수에서 바깥의 변수를 읽거나 쓸 때, 외부 렉시컬 환경 참조를 따라 그 변수를 검색한다.



### 8.5.4 환경 레코드의 구성

- 환경 레코드는 렉시컬 환경의 값(식별자와 식별자의 값의 묶음)이 실제로 저장되는 영역이다.

- **선언적 환경 레코드**와 **객체 환경 레코드**로 구성되어 있으며 저장 값의 유형에 따라 쓰임새가 달라진다.

- 아래는 JS의 객체 표현을 빌려 환경 레코드를 표현한 것이다.

  ```js
  EnvironmentRecord: {
  	//선언적 환경 레코드
  	DeclarativeEnvironmentRecord: {},
  	//객체 환경 레코드
  	ObjectEnvironmentRecord: {}
  }
  ```

- ##### 선언적 환경 레코드

  - 실제로 함수와 변수의 식별자와 실행 결과가 저장되는 영역이다.
  - 식별자와 실행 결과를 키와 값의 쌍으로 관리한다.

- ##### 객체 환경 레코드

  - 실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 쓴다.
  - 즉, 전역 객체 등 별도의 객체에 저장된 데이터는 객체 전체의 참조를 가져와서 객체 환경 레코드의 bindObject라는 프로퍼티에 바인드한다.



### 8.5.5 전역 환경과 전역 객체의 생성

- JS 인터프리터는 실행 시 렉시컬 환경 타입의 전역 환경을 생성한다. 

- 전역 객체를 생성한 후 전역 환경의 객체 환경 레코드에 전역 객체의 참조를 대입한다.

- 이 때 최상위 레벨의 this는 전역 객체를 가리킨다.

  ```js
  this === window // -> true
  ```

- 아래는 JS의 객체 표현을 빌려 위에서 설명한 코드의 상태를 표현한 것이다.

  ```js
  //전역 환경
  GlobalEnvironment = {
  	ObjectEnvironmentRecord: {
  		bindObject: window
  	},
  	OuterLexicalEnvironmentReference: null
  }
  
  // 전역 실행 문맥
  ExecutionContext = {
  	LexicalEnvironment: GlobalEnvironment,
  	ThisBinding: window
  }
  ```

  위 상황에서 window 객체가 전역 객체이므로 객체 환경 레코드의 bindObject 프로퍼티에는 window의 참조가 할당된다. 또한 생성된 전역 환경의 외부에는 다른 렉시컬 환경이 없으므로 외부 렉시컬 환경 참조에는 null을 할당한다.

  this가 window 객체이므로 디스 바인딩 컴포넌트에도 window의 참조가 할당된다.



### 8.5.6 프로그램의 평가와 전역 변수

- JS 인터프리터는 전역 환경과 전역 객체를 생성한 후에 프로그램을 읽어들이고 평가한다. 이 때 최상위 레벨(전역 객체)에 var 문으로 작성한 전역 변수들이 전역 환경의 환경 레코드(객체 환경 레코드)의 프로퍼티로 추가된다. 

- 전역 객체에 프로퍼티로 추가된 전역 변수들은 전역 환경의 환경 레코드(객체 환경 레코드)에 프로퍼티로 기록된다. 프로퍼티의 이름은 변수의 식별자, 프로퍼티 값은 undefined가 된다.

- 함수가 전역 객체에 프로퍼티로 추가되는 경우엔 함수 선언문을 함수 객체로 생성해서 프로퍼티로 기록한다.

  ```
  var a = { x: 1, y: 2 };
  console.log(window.a); // -> Object { x=1, y=2 }
  function norm(x) {...}
  console.log(window.norm); // -> norm(x)
  ```

- 이처럼 최상위 레벨에 선언된 함수와 변수는 프로그램을 평가하기 전에 이미 환경 레코드에 추가되있기 때문에 끌어올림 현상이 발생하는 것이다.

- var 문과 함수 선언문으로 선언한 전역 변수는 [[Configuable]] 속성이 false로 설정되어 있어 delete 연산자로 삭제할 수 없다.

- var 문을 사용하지 않고 변수를 선언해서 값을 할당하면(앞서 언급했던 선언 없는 값 대입)  프로그램의 실행 도중에 디스 바인딩 컴포넌트가 가리키는 객체의 프로퍼티로 추가된다. 위의 상황에선 디스 바인딩 컴포넌트가 전역 객체를 가리키므로 전역 객체에 추가된다. 이 경우 [[Configuable]] 속성이 true로 설정되어 delete 연산자를 통해 삭제할 수 있다.



### 8.5.7 프로그램 실행과 실행 문맥

- 실행 문맥은 **스택**의 구조로 관리된다.
- 실행 문맥은 프로그램 실행 중에 스택에 push되어 실행된다.
- 중첩 함수는 중첩 함수를 포함하는 함수의 실행 문맥에 포함되지 않고 따로 실행 문맥이 생성되어 push된다. 이 방식은 함수를 재귀적으로 호출한 경우에도 똑같이 적용한다.
- 재귀 호출한 함수는 호출한 함수와 같은 함수이지만 전혀 다른 함수로서 push된다.
- 실행 문맥 스택을 **호출 스택**이라고도 한다.



### 8.5.8 자바스크립트는 싱글 스레드

- 프로그램의 실행 방식에는 **싱글 스레드**와 **멀티스레드** 방식이 있다.
- **스레드**: 프로그램의 처리 흐름
- **싱글 스레드**: 프로그램 한 개의 처리 흐름. 프로그램을 순차적으로 실행
- **멀티 스레드**: 프로그램 여러 개의 처리 흐름. 동시에 작업을 여러 개 병렬로 실행
- 자바스크립트는 싱글 스레드 방식으로 작업을 처리한다. (예: 호출 스택에 쌓인 실행 문맥을 위에서부터 아래로 차례차례 실행)
- 이벤트 처리와 비동기 처리도 똑같은 방식으로 실행한다.
- **비동기 처리**: 특정 코드의 연산이 끝날 때까지 기다리지 않고 다음 코드를 진행하는 처리 방식. (예: 코드의 중간 부분에 지연 시간이 입력되어 있는 코드가 있을 때 그 지연 시간이 끝날 때까지 코드 진행을 멈추는 것이 아니라 바로 다음 코드로 넘어가는 것)

- 이벤트 처리와 비동기 처리는 실행하기에 앞서 이벤트 큐에 대기 행렬을 만든다. 그리고 현재 실행 중인 함수의 작업이 끝나면 대기 행렬에서 차례대로 호출 스택에 push된다.



### 8.5.9 환경 레코드와 지역 변수

- 환경 레코드는 함수 안팎의 환경을 기록한다. 이는 사용자로부터 읽거나 쓸 수 없으며 다음과 같은 정보를 기록하는 용도로 사용된다.
  - 함수의 인자
  - 함수 안에서 선언된 중첩 함수의 참조
  - 함수 안에서 var로 선언한 지역 변수
  - arguments
- 함수 선언문으로 생성한 함수 안의 지역 변수에는 그 함수의 함수 객체의 참조가 설정된다. 단, var로 선언한 지역 변수에는 undefined가 설정된다.
- 함수의 실행 문맥, 렉시컬 환경, 환경 레코드가 생성되면 실행 문맥의 디스 바인딩 컴포넌트에 그 함수를 호출한 객체의 참조를 저장하며, 이것으로 this 값을 결정한다. 이 this는 동적인 값이다.
- 함수가 종료되어 함수를 호출한 코드로 제어권이 돌아가면 일반적으로 실행 문맥과 그 안의 렉시컬 환경 컴포넌트가 메모리에서 지워진다. 허나 그 함수 밖의 함수의 참조가 환경 레코드에 유지되는 경우에는 렉시컬 환경 컴포넌트가 메모리에서 지워지지 않는다.



### 8.5.10 this 값

- this 값은 함수가 호출되어 실행되는 시점에 결정된다. 이 this 값은 함수가 호출되었을 때 그 함수가 속해 있던 객체의 참조이다.

  ```js
  var tom = {
  	name: "Tom",
  	sayHello: function() {
  		console.log("Hello!" + this.name);
          }
  };
  ```

  위 예제에서의 this는 tom 객체의 참조이다.

- 위의 특성을 이용해 다음과 같이 사용할 수도 있다.

  ```js
  var huck = { name: "Huck"};
  huck.sayHello = tom.sayHello;
  ```

  위 예제에서 huck.sayHello를 호출하면 this 값이 huck 객체가 된다.

아래는 다양한 상황에서의 this 값을 정리한 것이다.

1. ##### 최상위 레벨 코드의 this

   - 전역 객체를 가리킨다.

2. ##### 이벤트 처리기 안에 있는 this

   - 이벤트가 발생한 요소 객체를 가리킨다.

3. ##### 생성자 함수 안의 this

   - 생성자로 생성한 객체를 가리킨다.

4. ##### 생성자의 prototype 메서드 안의 this

   - 생성자로 생성한 객체를 가리킨다.

5. ##### 직접 호출한 함수 안의 this

   - 최상위 레벨에서의 함수 선언문의 this는 전역 객체를 가리킨다.



### 8.5.11 식별자 결정 : 유효 범위 체인

- 유효 범위가 겹치면서 이름이 같은 변수를 사용한다면 충돌이 발생한다. 이때 겹치는 변수가 어디에서 선언된 변수인지를 결정하는 작업을 **식별자 결정**이라고 한다.

- JS의 식별자 결정 규칙은 **더 안쪽 코드에 선언된 변수를 사용한다**이다.

- **속박 변수**: 함수의 인수와 지역 변수를 가리키는 말

- **자유 변수**: 속박 변수에 해당하지 않는 변수

- **닫힌 함수**: 속박 변수만을 가지고 있는 함수

- **열린 함수**: 자유 변수를 지니고 있는 함수

- ```js
  var a="A";
  function f() {
  	var b = "B";
  	function g() {
  		var c="C";
  		console.log(a+b+C);
  	}
  	g();
  }
  f(); // ->ABC
  ```

1. **속박 변수 c**
   - 변수 c는 함수 g 안에서 선언된 속박 변수이다. 이는 함수 g의 선언적 환경 레코드에 저장된다.
2. **자유 변수 b**
   - 변수 b는 함수 g의 바깥에서 선언된  자유 변수이다. 이는 함수 f의 선언적 환경 레코드에 저장된다.
   - 변수 b가 함수 f의 환경 레코드에 프로퍼티로 추가된 후 함수 g의 선언문이 평가되므로 함수 g의 외부 렉시컬 환경 참조에 저장된 f의 참조를 통해 변수 b를 함수 g에서 사용할 수 있게 된다.
3. **자유 변수 a**
   - a 또한 함수 g의 바깥에서 선언된 자유 변수이다.
   - a는 함수 f의 외부 렉시컬 환경 참조를 타고 올라가 전역 실행 환경의 렉시컬 환경 컴포넌트의 객체 환경 레코드에서 찾을 수 있다.

- 위의 과정처럼 식별자 결정은 외부 렉시컬 환경 참조를 타고 유효 범위 안에 존재하지 않는 식별자를 찾는다.
- 이러한 논리적인 연결고리를 **스코프 체인(ECMAScript3)** 또는 **외부 렉시컬 환경 체인** 또는 **유효 범위 체인**이라고 한다.



### 8.5.12 가비지 컬렉션

- 프로그램에서 객체를 사용하면 메모리 공간이 동적으로 확보된다. 반대로 사용하지 않는 객체의 메모리 영역은 **가비지 컬렉터**가 자동으로 해제한다. 이 매커니즘을 가리켜 가비지 컬렉션이라고 한다.

- 사용하지 않는 객체란 다른 객체의 프로퍼티와 변수가 참조하지 않는 객체를 말한다.

  ```js
  var p = {x:1, y:2};
  console.log(p);
  p = null;
  ```

  위 코드에서 변수 p가 null이 되면서 객체 {x:1, y:2}를 참조하는 변수가 없게 되므로 메모리에서 해제된다.

- 최근의 주요 웹 브라우저는 **마크 앤 스윕** 알고리즘을 사용한다. 전역 객체가 참조할 수 없는 객체를 찾아 해당 객체를 메모리에서 해제하는 방식으로 작동한다.





## 8.6 클로저

### 8.6.1 클로저

- **클로저**: 자기 자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행하는 함수 또는 그 기능을 구현한 자료 구조
- JS의 클로저는 함수 객체와 렉시컬 환경 컴포넌트의 집합이다.
- 8.5.11의 예제로 설명하자면 함수 g에서의 자유 변수 a, b의 식별자 결정을 실행한 함수 객체 g와 g가 참조하는 전역 실행 환경의 렉시컬 환경 컴포넌트(변수 a)과 함수 f의 렉시컬 환경 컴포넌트(변수 b)를 자유 변수의 식별자 결정을 위한 자료 구조라고 할 수 있다.
- 즉 함수 g의 함수 객체와 그 객체가 참조하는 함수 f의 렉시컬 환경 컴포넌트와 전역 실행 환경의 렉시컬 환경 컴포넌트가 클로저에 해당한다.
- 따라서 자바스크립트의 클로저는 **함수 객체와 렉시컬 환경 컴포넌트의 집합**이라고 할 수 있다.



### 8.6.2 클로저의 성질

- ```js
  function makeCounter(){
  	var count = 0;
  	return f;
  	function f() {
  		return count++;
  	}
  }
  var counter = makeCounter();
  //위 코드는 호출할 때마다 값이 1씩 증가한다.
  ```

  위 코드에서 주목해야 할 점은 2가지가 있다. 첫째는 외부 함수가 중첩 함수의 참조를 반환하고 있다는 사실이고 둘째는 중첩 함수가 외부 함수의 지역 변수를 참조한다는 사실이다. 

- 겉으로만 보면 위의 함수는 호출될 때마다 초기화되므로 호출할 때마다 1을 출력해야만 한다. 하지만 실제 결과는 카운터처럼 동작한다. 이 까닭은 전역 변수 counter가 makeCounter를 통해서 함수 f를 참조하고, 이 f는 자유 변수 count를 통해 makeCounter 함수의 렉시컬 환경 컴포넌트를 참조해 결국 전역 환경의 counter 변수가 makeCounter를 간접적으로 참조하고 있기 때문이다.

- 만약 클로저가 작동하지 않는다면 makeCounter 함수의 렉시컬 환경 컴포넌트는 가비지 컬렉터에 의해 메모리에서 해제된다.

- 클로저는 '캡슐화(프로퍼티를 쓸 수 있지만 겉으로는 은폐하는 행위)된 객체'에 빗댈 수 있다.

- ```js
  var counter1 = makeCounter();
  var counter2 = makeCounter();
  ```

  위의 코드를 호출하면 서로 다른 클로저가 생성된다. 마치 생성자와 비슷하다. 이처럼 클로저는 객체로 간주할 수도 있다.



### 8.6.3 클로저를 응용한 예제

1. ##### 여러 개의 내부 상태와 메서드를 가진 클로저

2. ##### 함수 팩토리

3. ##### 초기화 기능이 추가된 함수 생성하기

4. ##### 잘못된 예:  반복문 안에서 클로저 만들기



## 8.7 이름 공간

### 8.7.1 전역 이름 공간의 오염

- 전역 변수와 전역 함수를 전역 객체에 선언하는 행위를 '전역 유효 범위를 오염시킨다'라고한다.
- 전역 유효 범위가 오염되면 변수 이름이나 함수 이름이 겹칠 수 있다.
- 따라서 전역 유효 범위의 오염을 최소화해야 한다.



### 8.7.2 객체를 이름 공간으로 활용하기

- **이름 공간**: 변수 이름과 함수 이름을 한곳에 모아 이름 충돌을 미리 방지하는 공간
- JS에서는 객체를 이름 공간으로 활용할 수 있다.
- 객체를 값으로 가지는 전역 변수를 생성하여 그 객체에 프로그램 전체에서 사용하는 모든 변수와 함수를 프로퍼티로 정의하면 된다.



### 8.7.3 함수를 이름 공간으로 활용하기

- 함수는 변수를 은닉할 수 있기 때문에 이름 공간으로 활용할 수 있다.

- 즉시 실행 함수에 프로그램 전체를 작성하면 라이브러리의 전역 변수와 충돌하지 않을 수 있다.

- ##### 모듈 패턴

  - **모듈**: 기능(함수) 여러 개를 하나로 묶은 것
  - 즉시 실행 함수에 모듈을 작성하면 클로저에 의해 모듈의 내부 변수 이름 도는 함수 이름이 숨겨진다.



## 8.8 객체로서의 함수

### 8.8.1 함수는 객체

- JS의 함수는 Function 객체이자 **일급 객체**이다.
- **일급 객체**: 다음과 같은 특징을 가진 객체
  - 변수나 프로퍼티나 배열 요소에 대입할 수 있음
  - 함수의 인수로 사용할 수 있음
  - 함수의 반환값으로 사용할 수 있음
  - 프로퍼티와 메서드를 가질 수 있음
  - 익명 리터럴로 표현할 수 있음
  - 동적으로 생성 가능



### 8.8.2 함수의 프로퍼티

- | 프로퍼티 이름 | 설명                              |
  | ------------- | --------------------------------- |
  | caller        | 현재 실행 중인 함수를 호출한 함수 |
  | length        | 함수의 인자 개수                  |
  | name          | 함수를 표시할 때 사용하는 이름    |
  | prototype     | 프로토타입 객체의 참조            |



### 8.8.3 apply와 call 메서드

- Function 객체의 메서드에는 apply와 call이 있다.
- 두 메서드 모두 this 값의 호출과 함수의 인수를 사용하여 함수를 실행하는 메서드이다.
- apply는 함수의 인수를 배열의 형태로 넘기고 call은 쉼표로 값을 구분하여 넘긴다.



### 8.8.4 bind 메서드

- Function 객체의 bind 메서드는 객체에 함수를 바인드한다.

  ```js
  function say(greetings, honorifics){
  	console.log(greetings+" "+honorifics+this.name);
  }
  var tom = {name: "Tom Sawyer"};
  var sayToTom = say.bind(tom);
  sayToTom("Hello", "Mr."); // -> Hello! Mr.Tom Sawyer
  ```

- 위 코드에서 bind 메서드를 통해 sayToTom 변수에다가 변수 Tom의 값을 say 함수의 this 값으로 바인드(속박, 고정)시킨 것이다.



### 8.8.5 함수에 프로퍼티 추가하기

- 함수도 객체이므로 프로퍼티를 추가할 수 있다.

  ```js
  function f(x) {...}
  f.p = a;
  f.g = function() {...};
  ```

- Fucntion 객체에 추가된 프로퍼티는 그 함수를 실행하지 않고도 사용할 수 있다.

- **메모이제이션**: 함수 호출 시 함수의 인수와 그 반환값을 한 쌍으로 만들어 저장해 두는 기법. 함수에 한 번 실행한 적 있는 인숫값을 받으면 추가적인 계산은 생략할 수 있다.

- 메모이제이션을 저장하는 공간은 매우 다양하다. 그중에는 함수의 프로퍼티로 저장하는 방법도 있다.



## 8.9 고차 함수

### 8.9.1 고차 함수

- **고차 함수**: 함수를 인수로 받는 함수 또는 함수를 반환하는 함수



### 8.9.2 간단한 예

- 똑같은 작업을 하는 부분을 고차 함수로 만들어 주면 중복 코드를 줄일 수 있다.

- 수열 출력과 랜덤 알파벳 문자열 출력은 모두 지정 횟수만큼 반복문을 실행하여 그 실행값을 문자열로 만들어 준다는 공통점이 있다. 때문에 반복하는 부분과 문자열로 만드는 부분을 고차 함수로 만들면 코드를 최소화할 수 있다.

  ```js
  function joinStrings(n,f){
  	var s = "";
  	for(var = i=0; i<n; i++){
  		s+=f(i);
  	}
  	return s;
  }
  var digits = joinString(10, function(i) {return i; });
  var randomChars = joinStrings(8, function(i) {return String.fromCharCode(Math.floor(Math.random()*26) + "a".charCodeAt(0));
  });
  ```



### 8.9.3 메모이제이션

- ```js
  function memorize(f){
  	var cache = {};
  	return function(x) {
  		if(cache[x] == undefined) cache[x] = f(x);
  		return cache[x];
  	};
  }
  ```

- 위 예제는 함수를 인수로 받아 메모이제이션 기법을 적용하는 함수이다.





### 8.9.4 함수의 합성

- 함수 f(x)와 g(x)가 있을 때 함수 f(g(x))를 f와 g의 합성 함수라고 한다.

  ```js
  function compose(f, g) {
  	return function(x) {
  		return f(g(x));
  	};
  }
  ```



### 8.9.5 부분 적용

- 인수가 여러 개인 함수의 몇몇 인수를 상수로 지정해서 새로운 함수를 생성하는 기법을 **부분 적용**이라고 한다.

- ```js
  function product(x, y) {return x*y;}
  ```

  아래는 위 함수의 인수를 부분 적용한 함수이다.

  ```js
  product2 = function(y) { return product(2, y);};
  product2(3); // -> 6
  ```

- bind 메서드를 사용하면 다음과 같이 쓸 수 있다.

  ```js
  product2 = product.bind(null, 2);
  ```




### 8.9.6 커링

- **커링**: 인수를 2개 이상 받는 함수를 분해하여 인수가 하나인 중첩 함수로 변환하는 작업

- 아래의 두 함수는 원본 함수와 그 함수를 커링한 중첩 함수이다.

  ```js
  Math.pow(base, exponent) = pow(exponent)(base)
  ```

  ```js
  var pow = function(exponent) {
  	return function(base) {
  		return Math.pow(base, exponent);
  	};
  }
  ```

- 커링된 함수의 가장 큰 장점은 원본 함수를 부분 적용하기 쉽다는 것이다.

  ```js
  var square = pow(2);
  ```

  위 코드에서 square는 2라는 값이 부분 적용된 함수이다.





## 8.10 콜백 함수

### 8.10.1 콜백 함수

- **콜백 함수**: 다른 함수에 인수로 넘겨지는 함수

  ```js
  f(g);	// 함수 g가 콜백 함수에 해당
  function f(callback){
  	callback();
  }
  ```

- 콜백 함수는 함수를 호출했을 때 무언가 새로운 일이 생기거나 그 함수의 실행이 끝나고 지정한 콜백 함수를 실행해 주어야 하는 함수를 요청할 때 사용한다.

- 이 때 콜백 함수의 주체는 함수를 호출한 호출자(f)이다. 호출된 함수(g)는 콜백 함수를 실행할 뿐 작업 내용에는 관여하지 않는다.



### 8.10.2 이벤트 처리기

- 이벤트 처리기는 특정 이벤트 발생 시 실행하도록 등록된 함수이다. 이는 함수 호출 시 무언가 사건이 발생하면 콜백 함수가 실행되는 것과 닮았다.



### 8.10.3 타이머

- 타이머 메서드(setTimeout, setInterval)에 첫 번째 인수로 넘기는 함수가 바로 콜백 함수이다.



## 8.11 ECMAScript 6부터 추가된 함수의 기능

### 8.11.1 화살표 함수 표현식으로 함수 정의하기

- 화살표 함수 표현식의 함수 리터럴의 단축 표현이다.

##### 화살표 함수 표현식의 작성법

- 아래는 같은 함수를 각각 함수 리터럴과 화살표 함수 표현식으로 정의한 것이다.

  ```js
  var square = function(x) {return x*x; };
  ```

  ```js
  var square = (x) => {return x*x;};
  ```

- 인수가 여러 개일 경우 인수와 인수를 쉼표로 구분한다.

- 인수가 하나일 경우 인수를 묶는 괄호를 생략할 수도 있다.

  ```js
  var square = x => {return x*x;};
  ```

  단, 인수가 없는 함수는 괄호를 생략할 수 없다.

- 함수 몸통 안의 문장이 return뿐이라면 중괄호와 return 키워드를 생략할 수 있다.

  ```js
  var square = x => x*x;
  ```

- 함수 몸통 안의 문장이 return뿐이더라도 함수의 반환값이 객체 리터럴이라면 객체 리터럴을 그룹 연산자로 묶어야한다.

  ```js
  var f = (a, b) => ({x: a, y: b});
  ```

- 화살표 함수도 즉시 실행 함수로 사용할 수 있다.

  ```js
  (x => x*x)(3);
  ```

##### 함수 리터럴과 화살표 함수의 차이점

1. ###### this 값이 함수를 정의할 때 결정된다

   - 함수 리터럴을 함수가 호출될 때 this 값이 정해지는 반면 화살표 함수의 this 값은 정의할 때 결정된다. 즉, 화살표 함수 바깥 환경의 this 값이 화살표 함수의 this 값이 된다.
   - 화살표 함수는 call이나 apply 메서드를 사용하여 this를 바꾸어 호출해도 값이 바뀌지 않는다.

2. ###### arguments 변수가 없다

   - arguments 변수가 정의되지 않는다.

3. ###### 생성자로 사용할 수 없다

   - new 연산자를 사용할 수 없다.

4. ###### yield 키워드를 사용할 수 없다.

   - 이 때문에 제너레이터로 사용할 수 없다.



### 8.11.2 인수에 추가된 기능

##### 나머지 매개변수

- 함수의 인자가 들어가는 부분에 ...을 입력하면 입력받은 인수를 배열로 받는다. 이렇게 표현한 인자를 나머지 매개변수라고 한다.

  ```js
  function f(a, b, ...args) {
  	console.log(a, b, args);
  }
  f(1,2,3,4,5,6); // -> 1, 2, [3,4,5,6]
  ```



##### 인수의 기본값

- 함수의 인자에 대입 연산자를 사용하여 기본값을 설정할 수 있다. 이 때의 대입값에 다른 인자의 값도 사용할 수 있다.

  ```js
  function f(a, b=1){
  	return a*b;
  }
  f(3); // -> 3
  f(3, 2); // -> 6
  ```



### 8.11.3 이터레이터와 for/of 문

##### 이터레이션

- **이터레이션**: 반복 처리. 데이터 안의 요소를 연속적으로 꺼내는 행위



##### 이터레이터

- **이터레이터**: 반복 처리가 가능한 객체

- 배열의 이터레이터를 살펴보자. 배열은 Symbol.iterator 메서드를 가지고 있다. 이 메서드는 이터레이터를 반환한다.

  ```js
  var a[5,4,3];
  var iter = a[Symbol.iterator]();
  console.log(iter.next()); // -> Object {value: 5, done: false};
  console.log(iter.next()); // -> Object {value: 4, done: false};
  console.log(iter.next()); // -> Object {value: 3, done: false};
  console.log(iter.next()); // -> Object {value: undefined, done: true};
  ```

  iter의 next 메서드를 호출할 때마다 **이터레이터 리절트**라는 객체가 반환된다. 이 객체가 갖는 value와 done 프로퍼티는 각각 꺼내진 배열 요소의 값과 요소의 열거가 끝났는지를 뜻하는 논리값이 저장된다.

- 이터레이터는 일반적으로 두 가지 항목을 만족하는 객체이다.

  - next 메서드를 가진다.
  - next 메서드의 반환값이 value, done 프로퍼티를 가진 객체이다. 저장 값은 위의 예제와 같아야 한다.



##### 반복 가능한 객체와 for/of 문

- 이터레이터를 사용해서 이터레이션을 하려면 개발자가 적절한 처리를 직접 작성해야 한다.

- for/of 문을 사용하면 이러한 반복 처리를 자동으로 하도록 만들 수 있다.

  ```js
  //원 코드
  var a = [5, 4, 3];
  var iter = a[Symbol.iterator]();
  while(true){
  	var iteratorResult = iter.next();
  	if(iteratorResult.done == true) break;
  	var v = iteratorResult.value;
  	console.log(v);
  }
  
  //for/of 문
  var a = [5,4,3];
  for(var v of a) console.log(v);
  ```

  for/of 문은 이터레이터의 next 메서드를 순회할 때마다 매번 문장을 호출한다. done 프로퍼티의 값이 true가 아닌 동안은 value 프로퍼티의 값을 변수 v에 대입한다.

- 일반적으로 for/of 문은 2 조건을 만족하는 객체를 반복 처리한다.

  - Symbol.iterator 메서드를 가지고 있다.
  - Symbol.iterator 메서드는 반환값으로 이터레이터를 반환한다.

- Symbol.iterator 메서드를 가진 객체를 **반복 가능**한 객체라고 한다.

- Array, String(문자열), TypedArray, Map, Set의 생성자로 생성한 내장 객체는 모두 Symbol.iterator 메서드를 내장하고 있다.

  ```js
  for(var v of "ABC") console.log(b) // -> "A"
  "B"
  "C"
  ```



### 8.11.4 제너레이터

##### 제너레이터

- 다음과 같은 성질을 지닌 함수이다.
  - 반복 가능한 이터레이터를 값으로 반환한다.
  - 작업의 일시 정지와 재시작을 가능케하며 자신의 상태를 관리한다.



##### 제너레이터의 정의와 실행

```js
function* gen(){
	yield 1; // 포인트 1
	yield 2; // 포인트 2
	yield 3; // 포인트 3
}
var iter = gen();
console.log(iter.next()); // -> Object {value: 1, done: false}
console.log(iter.next()); // -> Object {value: 2, done: false}
console.log(iter.next()); // -> Object {value: 3, done: false}
console.log(iter.next()); // -> Object {value: undefined, done: true}
```

1. 위 코드에서 gen 함수는 제너레이터 함수이다. 이 함수는 호출되어도 바로 실행되지 않고 이터레이터를 반환한다.
2. next 메서드가 호출되면 함수의 첫 번째 yield 연산자의 위치까지 실행하며 이터레이터 리절트를 반환한다. 이 때 value 값으로 yield 표현식에 지정된 값을 저장하고 done 값으로 제너레이터 함수가 끝까지 실행됬는지를 저장한다. 그 후 제너레이터 함수는 포인트 1에서 일시 정지 상태가 된다.
3. 일시 정지된 위치에서 처리를 재개한다. 다음 포인트까지 진행한 후 위와 똑같은 처리를 한 후 일시정지된다.
4. 동일
5. 제너레이터 함수가 끝났으므로 마지막 출력값처럼 이터레이터 리절트를 반환한다.

- 위의 예시로 알 수 있듯이 yield는 제너레이터 함수에서 프로그램이 일시적으로 정지하는 위치이다.

- 제너레이터로 생성한 이터레이터의 next 메서드는 제너레이터 함수의 상태를 실행 상태로 바꾸는 역할을 한다. 반환값은 yield에 지정한 값이다.

- yield 표현식은 yield에 지정한 표현식을 값으로 가지며 이 자체를 변수에 대입할 수 있다.

  ```js
  //다음과 같이 사용가능
  yield;
  yield 표현식;
  
  var a = yield 2;
  ```



##### 제너레이터에 값 넘기기

- 제너레이터로 생성한 이터레이터의 next 메서드에 값을 대입하면 제너레이터에 값을 넘길 수 있다. 이 넘긴 값은 제너레이터가 일시적으로 정지하기 직전의 yield 표현식의 값으로 사용된다.



##### 제너레이터 종료하기 : return 메서드

- 제너레이터로 생성한 이터레이터의 return 메서드를 실행하면 인수 값을 반환한 후 제너레이터를 종료한다

  ```js
  function* g(){
  	yield 1;
  	yield 2;
  }
  var iter = g();
  iter.next();	// 1출력, done 값 false
  iter.return(10); // 10출력, done 값 true
  iter.next(); // undefined 출력, done 값 true
  ```



##### 제너레이터에 예외 던지기 : throw 메서드

- 제너레이터로 생성한 이터레이터의 throw 메서드를 실행하면 제너레이터에 예외를 던질 수 있다.

- 이 예외는 try/catch 문으로 받아서 처리한다.

  ```js
  function* idMaker() {
  	var count = 0;
  	while(true) {
  		try{
  			yield count++;
  		} catch(e) {
  			console.log("오류가 발생하였습니다.");
  		}
  	}
  }
  var iter = idMaker();
  console.log(iter.next()); // 0출력
  console.log(iter.next()); // 1출력
  iter.throw(new Error("오류")); // 오류가 발생하였습니다.
  // 2출력
  ```



##### 반복 가능한 객체에 위임하기 : yield*

- yield*에는 반복 가능한(이터러블) 객체를 지정한다. 지정된 객체에서 순차적으로 값을 꺼내 각각의 값에 yield를 적용한다.

  ```js
  function* f() {
  	yield "X";
  	yield "Y";
  }
  function* g() {
  	yield 0;
  	yield* [2,4];
  	yield* "AB";
  	yield* f();
  }
  var iter = g();
  for(var v of iter) console.log(v); // 0, 2, 4, A, B, X, Y를 순서대로 출력
  ```



### 8.11.5 템플릿 리터럴의 태그 함수

##### 태그가 지정된 템플릿 리터럴

- 템플릿 리터럴의 앞에 함수 이름을 적으면 템플릿 리터럴 안의 내용을 인수로 받는 함수를 호출할 수 있다.

  ```js
  func`${a} + ${b} = ${a+b}`
  ```

  이렇게 호출한 함수를 태그 함수라고 한다.

- 태그 함수의 첫 번째 인수는 문자열을 요소로 담은 배열이다. 이 배열의 요소는 템플릿 리터럴 안의 문자열을 ${...}를 기준으로 분할한 문자열이다. 두 번째 이후의 인수는 ${...} 안에 지정된 표현식을 평가한 값이 각각 순서대로 들어간다.

  ```js
  function list() {return arguments;}
  var t = list`a${1}b${2}c${3}`;
  console.log(t); // [["a", "b", "c"], 1, 2, 3]
  ```

- 템플릿 리터럴의 시작 부분이 문자열이 아닌 ${...}이라면 첫 번째 인수인 배열의 첫 요소가 빈 문자열로 들어온다. 이는 끝 부분도 마찬가지이다.



##### 태그 함수의 첫 번째 인수

- 태그 함수의 첫 번째 인수는 callSite 객체라고 하며 다음과 같은 특징이 있다.

1. **동결되어 있다**
   - 동결된 객체로 읽기만 할 수 있다. 즉, 프로퍼티의 추가, 삭제, 변경은 모두 불가능하다.
2. **callSite 객체는 캐시된다**
   - 처리한 적 있는 템플릿 리터럴 문자열을 만나면(플레이스 홀더는 제외) 캐시된 callSite 객체를 첫 번째 인수로 넘긴다.
3. **raw 프로퍼티가 있다**
   - raw 프로퍼티는 배열이며 요소는 첫 번째 인수의 배열과 같다. 단, 이스케이프되지 않은 문자열로 들어온다.

