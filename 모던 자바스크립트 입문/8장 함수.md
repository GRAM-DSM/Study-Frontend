# 8장 함수

## 8.1 함수 정의하기

### 8.1.1 함수를 정의하는 방법

1. ##### 함수 선언문으로 정의하는 방법

   ```js
   function square(x) { return x*x; }
   ```

2. ##### 함수 리터럴로 정의하는 방법

   ```js
   var square = function(x) { return x*x; };
   ```

3. ##### Function 생성자로 정의하는 방법

   ```js
   var square = new Function("x", "return x*x");
   ```

4. **화살표 함수 표현식으로 정의하는 방법**

   ```js
   var square = x => x*x;
   ```

   8.11절에서 설명

위 방법 중 1번을 제외한 나머지 방법으로 정의한 함수는 변수에 그 함수의 참조를 할당해야 비로소 사용할 수 있는 상태가 되므로 함수 끌어올림의 대상이 되지 않고 때문에 함수를 호출하는 코드보다 앞에 위치해야 한다.



### 8.1.2 중첩 함수

- **중첩 함수**: 특정 함수의 내부에 선언된 함수
- 중첩 함수는 if 문이나 while 문 등의 문장 블록 안에는 작성할 수 없다 => 외부 함수의 최상위 레벨에만 중첩 함수를 작성할 수 있다.
- 중첩 함수의 참조는 중첩 함수의 외부 함수의 지역 변수에 저장되므로 외부 함수의 바깥에서는 사용할 수 없다.
- 중첩 함수는 자신의 외부 함수의 인수나 지역 변수에 접근할 수 있다.



## 8.2 함수 호출하기

## 8.2.1 함수를 호출하는 방법

1. ##### 함수 호출

   - 함수의 참조가 저장된 변수 뒤에 그룹 연산자인 ()를 붙여서 호출한다.

     ```js
     square(5);
     ```

2. ##### 메서드 호출

   - 메서드가 들어있는 프로퍼티를 호출하면서 그룹 연산자를 사용한다. 본질적으로 1과 같은 방법이다.

     ```js
     obj.m = function() {...};
     obj.m();
     ```

3. ##### 생성자 호출

   - 생성자의 참조를 저장한 변수 앞에 new 키워드를 추가한다.

     ```js
     var obj = new Object();
     ```

4. ##### call, apply를 사용한 간접 호출

   - 함수의 call, apply 메서드를 사용하여 함수를 간접적으로 호출할 수 있다. 9장에서 설명



### 8.2.2 즉시 실행 함수

- 일반적으로 익명 함수를 실행할 때는 익명 함수의 참조를 변수에 할당한 후 그룹 연산자 ()를 붙여서 실행한다.

  ```js
  var f = function() {...};
  f();
  ```

  하지만 JS에는 익명 함수를 정의하고 곧바로 실행하는 **즉시 실행 함수**라는 구문이 있다.

  ```js
  (function() {...})();
  (function() {...}());
  ```

  위의 두 가지 방법을 이용하면 익명 함수를 정의하는 동시에 실행할 수 있다.

- 즉시 실행 함수의 구문에서는 함수 정의식을 그룹 연산자 ()로 묶는다. 이는 괄호 안의 함수 정의식을 평가하여 함수 객체의 참조 값(함수 값)으로 바꾼다. 아래의 방법으로도 함수 정의식을 함수 값으로 만들 수 있다.

  ```js
  +function() {...}()
  ```

  가장 먼저 소개한 익명 함수를 변수에 할당하는 방법도 함수 정의식을 함수 값으로 변환하여 변수에 할당한 것이다.

- 즉시 실행 함수에도 인수를 넘길 수 있다.

  ```js
  (function(a, b){...})(1, 2);
  ```

- 즉시 실행 함수에도 이름을 붙일 수 있지만 함수 내부에서만 유효하다.(사용 예: 재귀 함수)

- 함수 실행 결과를 변수에 할당할 수 있으며 표현식 안에서 사용할 수 있다.

  ```js
  var x = (function(){...})();
  ```



## 8.3 함수의 인수

### 8.3.1 인수의 생략

- 함수 정의식에 작성된 인자 개수보다 인수를 적게 전달해서 함수를 실행하면 생략된 인자는 undefined가 된다.

  ```js
  function f(x, y){
  	console.log(x, y);
  }
  f(2);	// -> x undefined
  ```

- 위의 성질을 활용하면 인수를 생략할 수 있는 함수를 정의할 수 있다. 단, 인수를 생략했을 시의 초깃값을 설정해야 한다.

  ```js
  function multiply(a, b){
  	b = b || 1;
  	return a*b;
  }
  multiply(2); // -> 2
  ```



### 8.3.2 가변 길이 인수 목록(Arguments 객체)

- 모든 함수에는 arguments라는 지역 변수가 있다. 이 변수의 값은 Arguments 객체로 함수의 인수 값을 유사 배열 객체(10.3절 참조)의 형태로 저장한다.

- Arguments 객체는 프로퍼티로 length(인수의 개수)와 callee(현재 실행되고 있는 함수의 참조)를 갖고 있다.

- arguments[i]의 값을 바꾸면 이에 해당하는 인자의 값도 바뀐다.

  ```js
  function f(x, y){
  	arguments[1] = 3;
  	console.log(x, y);
  }
  f(1, 2)	// -> 1 3
  ```

  일반적인 배열에는 이러한 특징이 없다.

- arguments 변수를 활용하면 인수의 개수가 일정하지 않은 가변 인수 함수를 정의할 수 있다.

  ```js
  function myConcat(separator){
  	var s = "";
  	for(var i=1; i<arguments.length; i++){
  		s += arguments[i];
  		if( i < arguments.length-1 ) s += separator;
  	}
  	return s;
  }
  console.log(myConcat("/", "apple", "orange", "peach")); // -> apple/orange/peach
  ```

  위의 코드에서 apple, orange, peach는 인자로서 받아들여지진 않았지만 arguments 변수에는 저장되어 있었기에 위와 같은 코드를 만들 수 있었다. 이처럼 JS의 함수에서는 작성된 인자 개수보다 더 많은 개수의 인수를 넘겨서 함수를 실행할 수 있다.

- arguments[]는 앞서 말했듯이 유사 배열 객체이지만 다음의 방법을 사용하면 배열 객체로 변환할 수 있다.

  ```js
  var params = [].slice.call(arguments);
  ```

  slice는 배열의 메서드로 10.1.3절에서 설명을, call 메서드를 사용한 메서드의 호출 방법은 8.8.3절에서 설명할 것이다.