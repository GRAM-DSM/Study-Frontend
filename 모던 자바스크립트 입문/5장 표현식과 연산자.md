# 5장 표현식과 연산자

## 5.1 연산자

### 5.1.1 표현식과 연산자

- **표현식**: 결과적으로 *어떤 값*으로 평가되는 것. 이 평가한다는 말은 표현식의 값과 변수, 함수 등의 값을 바탕으로 식의 값을 계산하는 행위를 뜻한다. 표현식은 가장 간단한 원시 값부터 객체 값까지 모두 표현식이다.

  ```js
  3.14, "hello", true, false, null // 원시 값
  sum, circle.radius, a[3], square(5), card.getSum() // 객체 값
  ```

- **연산자**를 이용하면 표현식을 조합할 수 있다.

  ```js
  a+b
  ```

- 위 예시에서 +는 연산자, a와 b는 연산 대상이 되는 표현식이며, 이를 **피연산자**라고 한다.

- +연산자처럼 좌우에 피연산자 두 개를 가진 연산자를 이항 연산자라고 한다. 이처럼 연산자는 피연산자의 개수에 따라 단항, 이항, 삼항으로 구분한다. -부호는 단항에 속한다.

- 삼항 연산자는 **?:** 뿐이다.

- 표현식은 왼쪽 피연산자 값부터 순서대로 평가되고, 연산자로 계산이 시작된다.(단, 일부 연산자(||, &&, ?:)에는 예외가 적용된다. 이 연산자들은 먼저 평가된 후 피연산자들을 평가한다.)

- 위의 예시에서 a, b 값이 각각 2, 3이라면 예시의 표현식은 2 + 3으로 평가된 후 계산된다.



### 5.1.2 연산자의 우선순위

- 연산자에는 우선 순위가 있다. 우선 순위가 가장 높은 연산자는 **그룹 연산자 (괄호)**이다.



### 5.1.3 연산자 결합 법칙

- 우선순위가 같은 연산자가 나열되어 있으면 좌우 중 어느 연산자와 결합하느냐에 따라 결고가 달라진다.

  ```js
  24/6*2
  ```

- 연산자에는 위와 같은 상황에서 좌우 중 어느 연산자와 연산할지를 결정하는 결합 법칙이 정해져 있다. 이에 대해서는 아래 표에서 서술할 것이다.

- 우선순위가 같을 때에는 좌->우 방향으로 결합한다.



### 5.1.4 연산자의 부수 효과

- +연산자처럼 변수 값을 바꾸지 않는 연산자도 있지만 x = y처럼 대입하는 표현식은 변수의 값을 바꾼다. 이러한 표현식은 **부수 효과가 있는 표현식**이라고 한다. 대입 연산자(=), 증감 연산자(++, --), delete 연산자가 이에 해당한다.

- 아래의 표는 연산자의 우선순위와 각 연산자의 결합 볍칙을 정리한 표이다.

  | 우선순위 | 연산자                                                       | 결합 법칙    |
  | -------- | ------------------------------------------------------------ | ------------ |
  | 1        | ()(그룹 연산자)                                              | 없음         |
  | 2        | . []                                                         | 왼쪽->오른쪽 |
  |          | new(인수 있음)                                               | 오른쪽->왼쪽 |
  | 3        | ()(함수 호출)                                                | 왼쪽->오른쪽 |
  |          | new(인수 없음)                                               | 오른쪽->왼쪽 |
  | 4        | ++(후위), --(후위)                                           | 없음         |
  | 5        | !, ~, +(단항), -(부호 반전), typeof, voidm delete, ++(전위), --(전위) | 오른쪽->왼쪽 |
  | 6        | *, /, %                                                      | 왼쪽->오른쪽 |
  | 7        | +, -, +(문자열 결합)                                         | 왼쪽->오른쪽 |
  | 8        | <<, >>, >>>                                                  | 왼쪽->오른쪽 |
  | 9        | <, <=, >, >=, in instanceof                                  | 왼쪽->오른쪽 |
  | 10       | ==, !=, ===, !==                                             | 왼쪽->오른쪽 |
  | 11       | &                                                            | 왼쪽->오른쪽 |
  | 12       | ^                                                            | 왼쪽->오른쪽 |
  | 13       | \|                                                           | 왼쪽->오른쪽 |
  | 14       | &&                                                           | 왼쪽->오른쪽 |
  | 15       | \|\|                                                         | 왼쪽->오른쪽 |
  | 16       | ?:                                                           | 오른쪽->왼쪽 |
  | 17       | yield, yield*                                                | 오른쪽->왼쪽 |
  | 18       | =, +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=, \|=           | 오른쪽->왼쪽 |
  | 19       | ...                                                          | 없음         |
  | 20       | ,                                                            | 왼쪽->오른쪽 |

  

## 5.2 산술 연산

### 5.2.1 산술 연산자

- 피연산자가 숫자인 연산자이다.
- 피연산자가 숫자가 아니면 연산자가 피연산자 타입을 숫자 타입으로 바꾸어 연산한다. 이 때 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때는 NaN이 나온다.

#### 산술 이항 연산자

- +, -, *, /, %가 있다.

  - 아래는 산술 이항 연산자를 쓸 때 몇 가지 주의 사항이다.

    1. **정수끼리 나누어도 결과가 부동소수점이 된다**

    2. **나머지 연산자의 피연산자는 부동소주점이다.**

    3. **+ 연산자는 피연산자 중 하나가 문자열이면 나머지 피연산자도 문자열로 만든다**

    4. ```js
       0/0 // -> NaN : 계산할 수 없음
       "one" * 1 // -> NaN : 계산할 수 없음
       true + true // -> 2 : 논리값의 타입을 숫자로 바꾸어 더함
       1 + null // -> 1 : null을 0으로 바꾸어 더함
       1 + undefined // -> NaN : undifined를 NaN으로 바꾸어 더함
       ```



#### 산술 단항 연산자

- 전후위 ++, -- 연산자와 +(아무것도 처리하지 않음), -(부호 반전) 연산자가 있다.



#### 산술 대입 연산자

- 대입 연산자와 산술 이항 연산자를 조합한 연산자



### 5.2.2 Math 객체의 프로퍼티

- JS는 복잡한 수학적 연산을 Math 객체로 지원한다.(sin, cos 등)



### 5.2.3 부동소수점과 정확도 문제

- JS에서 사용하는 64비트 부동소수점의 규격은 부호 1비트, 지수 11비트, 가수 52비트이다. 즉, 2진수 53자리(10진수 약 16자리)만큼의 가수 부분의 표현할 수 있다.
- **정확도 문제**: 숫자를 자릿수가 정해진 부동소수점으로 표현하여 계산하면 발생하는 오류
- **정밀도 손실**: 값이 가까운 두 수를 뺄셈할 때 발생하는 정확도 문제
- 10진수로 딱 떨어지는 값도 산술 연산을 내부적으로 2진수로 연산한다는 점 때문에 계산 결과가 어긋날 수 있다.



## 5.3 문자열 제어하기

### 5.3.1 문자열 연결

- +연산자는 피연산자가 모두 문자열이면 문자열로, 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 후 연결한다.

  ```js
  10 + "little indiangs"	//	-> "10 little indians"
  1 + {}	// ->"1[object Object]"
  true + (new Date())	// -> "trueTue Sat Aug ..."
  ```

  위에 해당하지 않는 경우 피연산자를 상황에 따라 숫자 또는 NaN 타입으로 바꾸어 더한다.



### 5.3.2 문자열을 조작하는 메서드

- String 객체는 문자열을 객체로 변환할 수 있다.
- 이처럼 원시 값을 객체로 변환하는 행위를 **래핑**이라고 한다.

