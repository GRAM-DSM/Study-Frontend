# 5장 표현식과 연산자

## 5.1 연산자

### 5.1.1 표현식과 연산자

- **표현식**: 결과적으로 *어떤 값*으로 평가되는 것. 이 평가한다는 말은 표현식의 값과 변수, 함수 등의 값을 바탕으로 식의 값을 계산하는 행위를 뜻한다. 표현식은 가장 간단한 원시 값부터 객체 값까지 모두 표현식이다.

  ```js
  3.14, "hello", true, false, null // 원시 값
  sum, circle.radius, a[3], square(5), card.getSum() // 객체 값
  ```

- **연산자**를 이용하면 표현식을 조합할 수 있다.

  ```js
  a+b
  ```

- 위 예시에서 +는 연산자, a와 b는 연산 대상이 되는 표현식이며, 이를 **피연산자**라고 한다.

- +연산자처럼 좌우에 피연산자 두 개를 가진 연산자를 이항 연산자라고 한다. 이처럼 연산자는 피연산자의 개수에 따라 단항, 이항, 삼항으로 구분한다. -부호는 단항에 속한다.

- 삼항 연산자는 **?:** 뿐이다.

- 표현식은 왼쪽 피연산자 값부터 순서대로 평가되고, 연산자로 계산이 시작된다.(단, 일부 연산자(||, &&, ?:)에는 예외가 적용된다. 이 연산자들은 먼저 평가된 후 피연산자들을 평가한다.)

- 위의 예시에서 a, b 값이 각각 2, 3이라면 예시의 표현식은 2 + 3으로 평가된 후 계산된다.



### 5.1.2 연산자의 우선순위

- 연산자에는 우선 순위가 있다. 우선 순위가 가장 높은 연산자는 **그룹 연산자 (괄호)**이다.



### 5.1.3 연산자 결합 법칙

- 우선순위가 같은 연산자가 나열되어 있으면 좌우 중 어느 연산자와 결합하느냐에 따라 결고가 달라진다.

  ```js
  24/6*2
  ```

- 연산자에는 위와 같은 상황에서 좌우 중 어느 연산자와 연산할지를 결정하는 결합 법칙이 정해져 있다. 이에 대해서는 아래 표에서 서술할 것이다.

- 우선순위가 같을 때에는 좌->우 방향으로 결합한다.



### 5.1.4 연산자의 부수 효과

- +연산자처럼 변수 값을 바꾸지 않는 연산자도 있지만 x = y처럼 대입하는 표현식은 변수의 값을 바꾼다. 이러한 표현식은 **부수 효과가 있는 표현식**이라고 한다. 대입 연산자(=), 증감 연산자(++, --), delete 연산자가 이에 해당한다.

- 아래의 표는 연산자의 우선순위와 각 연산자의 결합 볍칙을 정리한 표이다.

  | 우선순위 | 연산자                                                       | 결합 법칙    |
  | -------- | ------------------------------------------------------------ | ------------ |
  | 1        | ()(그룹 연산자)                                              | 없음         |
  | 2        | . []                                                         | 왼쪽->오른쪽 |
  |          | new(인수 있음)                                               | 오른쪽->왼쪽 |
  | 3        | ()(함수 호출)                                                | 왼쪽->오른쪽 |
  |          | new(인수 없음)                                               | 오른쪽->왼쪽 |
  | 4        | ++(후위), --(후위)                                           | 없음         |
  | 5        | !, ~, +(단항), -(부호 반전), typeof, voidm delete, ++(전위), --(전위) | 오른쪽->왼쪽 |
  | 6        | *, /, %                                                      | 왼쪽->오른쪽 |
  | 7        | +, -, +(문자열 결합)                                         | 왼쪽->오른쪽 |
  | 8        | <<, >>, >>>                                                  | 왼쪽->오른쪽 |
  | 9        | <, <=, >, >=, in instanceof                                  | 왼쪽->오른쪽 |
  | 10       | ==, !=, ===, !==                                             | 왼쪽->오른쪽 |
  | 11       | &                                                            | 왼쪽->오른쪽 |
  | 12       | ^                                                            | 왼쪽->오른쪽 |
  | 13       | \|                                                           | 왼쪽->오른쪽 |
  | 14       | &&                                                           | 왼쪽->오른쪽 |
  | 15       | \|\|                                                         | 왼쪽->오른쪽 |
  | 16       | ?:                                                           | 오른쪽->왼쪽 |
  | 17       | yield, yield*                                                | 오른쪽->왼쪽 |
  | 18       | =, +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=, \|=           | 오른쪽->왼쪽 |
  | 19       | ...                                                          | 없음         |
  | 20       | ,                                                            | 왼쪽->오른쪽 |

  

## 5.2 산술 연산

### 5.2.1 산술 연산자

- 피연산자가 숫자인 연산자이다.
- 피연산자가 숫자가 아니면 연산자가 피연산자 타입을 숫자 타입으로 바꾸어 연산한다. 이 때 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때는 NaN이 나온다.

#### 산술 이항 연산자

- +, -, *, /, %가 있다.

  - 아래는 산술 이항 연산자를 쓸 때 몇 가지 주의 사항이다.

    1. **정수끼리 나누어도 결과가 부동소수점이 된다**

    2. **나머지 연산자의 피연산자는 부동소주점이다.**

    3. **+ 연산자는 피연산자 중 하나가 문자열이면 나머지 피연산자도 문자열로 만든다**

    4. ```js
       0/0 // -> NaN : 계산할 수 없음
       "one" * 1 // -> NaN : 계산할 수 없음
       true + true // -> 2 : 논리값의 타입을 숫자로 바꾸어 더함
       1 + null // -> 1 : null을 0으로 바꾸어 더함
       1 + undefined // -> NaN : undifined를 NaN으로 바꾸어 더함
       ```



#### 산술 단항 연산자

- 전후위 ++, -- 연산자와 +(아무것도 처리하지 않음), -(부호 반전) 연산자가 있다.



#### 산술 대입 연산자

- 대입 연산자와 산술 이항 연산자를 조합한 연산자



### 5.2.2 Math 객체의 프로퍼티

- JS는 복잡한 수학적 연산을 Math 객체로 지원한다.(sin, cos 등)



### 5.2.3 부동소수점과 정확도 문제

- JS에서 사용하는 64비트 부동소수점의 규격은 부호 1비트, 지수 11비트, 가수 52비트이다. 즉, 2진수 53자리(10진수 약 16자리)만큼의 가수 부분의 표현할 수 있다.
- **정확도 문제**: 숫자를 자릿수가 정해진 부동소수점으로 표현하여 계산하면 발생하는 오류
- **정밀도 손실**: 값이 가까운 두 수를 뺄셈할 때 발생하는 정확도 문제
- 10진수로 딱 떨어지는 값도 산술 연산을 내부적으로 2진수로 연산한다는 점 때문에 계산 결과가 어긋날 수 있다.



## 5.3 문자열 제어하기

### 5.3.1 문자열 연결

- +연산자는 피연산자가 모두 문자열이면 문자열로, 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 후 연결한다.

  ```js
  10 + "little indians"	//	-> "10 little indians"
  1 + {}	// ->"1[object Object]"
  true + (new Date())	// -> "trueTue Sat Aug ..."
  ```

  위에 해당하지 않는 경우 피연산자를 상황에 따라 숫자 또는 NaN 타입으로 바꾸어 더한다.



### 5.3.2 문자열을 조작하는 메서드

- JS에서는 문자열을 다루는 데 사용하는 **String 객체**를 내장하고 있다. 사용법은 생성자와 같다.

  ```js
  var msgObj = new String("Everything is practice");
  ```

- String은 문자열을 객체로 변환해준다. 이와 같이 원시 값을 객체로 변환하는 행위를 **래핑**한다고 한다.

- String을 통해 객체로 변환한 문자열에는 배열처럼 인덱스 번호가 지정되어 있다.

- String 객체는 다양한 프로퍼티와 메서드를 지니고 있다. 예시로 charAt() 메서드는 문자열의 인덱스 번호를 인자로 받아 그 인덱스 번호에 해당하는 문자를 구하는 기능을 가지고 있다.

- 문자열은 객체가 아니므로 프로퍼티를 지니고 있지 않다.  그럼에도 String 생성자가 동작 가능한 이유는 문자열이 자동으로 String 객체로 변환되기 때문이다.

  ```js
  var c = 'msg'.charAt(2);
  
  //내부적으로 실행되는 작업
  var msgObj = new String('msg'); // 문자열을 String 객체로 변환
  var c = msgObj.charAt(2);
  ```

  위에서 msgObj 객체는 일시적으로 생성되고 작업이 끝나면 사라진다. 이러한 객체를 **래퍼 객체**라고 한다.

- 위 예제에서 문자열을 String 객체로 변환하지 않고 바로 메서드를 호출하는 이유는 String 객체부터가 원시 값이 들어올 것으로 가정하고 작성한 코드이기 때문이다. 때문에 바로 메서드를 호출해 원하는 작업이 처리 가능하다.



### 5.3.3 String 생성자의 메서드

- String 생성자는 JS의 타 함수처럼 프로퍼티를 지니고 있다.



### 5.3.4 문자열을 배열로 읽고 쓰기

- 문자열을 읽을 때는 charAt() 메서드 대신 대괄호 연산자를 사용할 수 있다.

  ```js
  a= 'mag'
  a[2]	// -> g
  a[a.length-1]	// -> g
  ```

- 다만 배열과는 다르게 값을 대입해서 수정할 수는 없다. 만약 값을 대입하려고 시도할 경우 무시한다.



## 5.4 논리 연산자와 관계 연산자

### 5.4.1 관계 연산자

- 관계 연산자는 두 개의 피연산자의 비교 결과를 논리값(t/f)로 반환한다. ==, !=, ===(값과 타입이 같음), !==(값과 타입이 다름), <, >, <=, >= 이 관계 연산자에 해당한다.

##### 동일 연산자

- 동일(==) 연산자는 두 피연산자가 같은지를 판별한다. 피연산자의 타입에 따라 작동 방식이 다르다.
  - **좌우 피연산자의 타입이 같을 때**: 값이 같으면 true, 다르면 false이다. 타입이 원시 타입일 때는 단순히 값을 비교하지만 객체 타입인 경우 참조가 같은지를 판별한다.
  - **좌우 피연산자의 타입이 다를 때**: 같은 타입이 되도록 타입을 변환한 후 아래 규칙에 따라 동일 여부를 판별한다.
    - undefined와 null은 같은 것으로 친다.
    - 한쪽이 숫자, 다른 쪽이 문자열이면 문자열을 숫자로 변환하여 비교한다.
    - 둘 중 한쪽이 논리값이면 true는 1, false는 0으로 변환하여 비교한다.
    - 한쪽이 객체, 다른 쪽이 숫자 또는 문자열이면 객체를 toString이나 valseOf 메서드를 사용하여 원시 타입으로 변환한 다음에 비교한다.

##### 일치 연산자

- 일치(===) 연산자는 두 피연산자의 타입과 값의 동일 여부를 판별해준다.
- NaN은 NaN을 포함한 모든 값과 같지 않다고 판별한다.



### 5.4.2 논리 연산자

- 논리 연산자는 더욱 복잡한 논리를 정의한다. &&(논리곱, and), ||(논리합, or), !(부정, not)이 이에 해당한다.

##### 피연산자의 평가

- 논리 연산자의 피연산자는 논리값(true, false)가 아니어도 된다. 필요에 따라 타입이 자동으로 변하기 때문이다.

##### 논리곱 연산자와 논리합 연산자의 단락 평가

- **단락 평가**: 첫 번째 피연산자 값이 표현식을 결정하면 두 번째 피연산자를 평가하지 않는다.

- &&와 ||는 논리값 대신에 마지막으로 평가한 피연산자의 값을 반환한다.

- 아래는 예시이다.

  ```js
  a && b
  ```

  논리곱은 피연산자 둘 중 하나만 거짓이여도 거짓으로 처리되기 때문에 a가 거짓일 경우 b를 평가하지 않고 표현식의 전체 값이 false 처리 된다. 이 때의 반환값은 false가 아닌 a의 값으로 처리된다. 논리 값이 필요한 경우에는 a 값이 아닌 논리값으로 변환되어 반환한다.

- ```js
  a || b
  ```

  논리합은 피연산자 둘 중 하나만 참이여도 참으로 처리되기 때문에 a가 참일 경우 b를 평가하지 않는다. 위와 같이 true 대신 a의 값 자체를 반환한다.



## 5.5 비트 연산

### 5.5.1 비트 연산

- **비트 연산**: 2진수 숫자의 자릿수 값(비트 값)을 다루는 연산. 

- 비트 연산자는 피연산자를 부호 있는 32비트 정수로 변환해서 처리한다. 

- 비트 연산자에는 비트 논리 연산자와 비트 시프트 연산자가 있다.



### 5.5.2 비트 논리 연산자

- 비트 논리 연산자는 비트 값이 0이면 false, 비트 값이 1이면 true로 평가한다. 논리곱(AND), 논리합(OR), 배타적 논리합(XOR), 논리 부정(NOT)이 있고, 각각의 비트끼리 계산한다.



### 5.5.3 비트 시프트 연산자 

- 비트 시프트 연산자는 정수를 2진수 비트 단위로 오른쪽 또는 왼쪽으로 이동시키는(시프트하는) 연산자이다. <<(왼쪽 시프트), >>(부호 있는 오른쪽 시프트), >>>(부호 없는 오른쪽 시프트)
- 왼쪽 시프트: 비트가 이동하면서 생긴 빈 자리는 0으로 채워지고 넘친 값은 버려진다.
- (부호)오른쪽 시프트: 비트가 이동하면서 생긴 좌측의 빈 자리는 부호 비트로 채워지고 넘친 우측 비트 값은 버려진다.
- 오른쪽 시프트: 비트가 이동하면서 생긴 빈 자리는 0으로 채워지고 넘친 값은 버려진다.



### 5.5.4 비트 연산의 대입 연산자

- 산술 연산자와 마찬가지로 비트 연산자와 대입 연산자를 합칠 수 있다. &=, |=, ^=, <<=, >>=, >>>=가 있다.



## 5.6 기타 연산

### 5.6.1 typeof 연산자

- 단항 연산자로 피연산자의 데이터 타입을 반환한다.

  ```js
  var s = "ABC";
  console.log(typeof s);	// -> string
  ```

- typeof 연산자는 피연산자가 함수 이외의 객체인 경우 모두 object를 반환한다. 함수는 function을 반환한다.



### 5.6.2 조건 연산자

- 조건(?:) 연산자는 주어진 조건의 참과 거짓에 따라 값을 선택한다.

  ```js
  var parity = (a % 2 == 0)? "짝수" : "홀수";
  ```

  콜론을 기준으로 조건이 참일 경우 앞의 값을 반환하고 거짓일 경우 뒤의 값을 반환한다.



### 5.6.3 쉼표 연산자

- 쉼표 연산자는 이항 연산자로 왼쪽의 피연산자부터 차례대로 평가한 후 오른쪽 끝의 피연산자의 값을 반환한다.

- ```js
  i = 0, sum = 0, product = 1;
  ```

  위 표현식의 결괏값은 마지막 피연산자를 평가한 값인 1이 된다. 단, 위 대입문들은 모두 정상적으로 실행된다.

- 쉼표 연산자의 특징(반환값은 하나이지만 대입문은 정상 실행)을 이용하여 for문에 활용할 수 있다.

  ```js
  for(var i = 1, sum = 0; i<=10; i++){
  	sum += i;
  }
  ```

  본래 for 문의 소괄호 안에는 문장을 세 개만 넣을 수 있지만 위 코드에서는 더 많은 문장을 실행하였다.



### 5.6.4 eval 함수

- eval은 함수이지만 연산자의 역할을 담당하고 있다.

  ```js
  var x = 1;
  eval("x++;");
  ```

  eval 함수는 문자열 하나를 인수로 받아 그 문자열을 자바스크립트 코드로 해석한다.

- eval 함수는 eval 함수를 호출한 환경의 유효 범위 내의 변수를 사용할 수 있다.



## 5.7 명시적 타입 변환

### 5.7.1 숫자를 문자열로 변환하기

##### 숫자 + 문자열

- 숫자와 문자열을 + 연산자로 연결하면 숫자의 타입이 문자열로 바뀌어 더해진다.

  ```js
  10 + "cookies"	// -> "10cookies"
  100 + ""	// -> "100"
  ```



##### Number 객체의 메서드를 활용하는 방법

- 문자열을 객체로 바꾸는데 String 생성자가 있듯이 숫자를 개체로 바꿀 땐 Number 생성자를 통해 Number 객체로 변환해줄 수 있다.
- 이 Number 객체의 메서드를 통해 숫자를 문자열로 변환할 수 있다.



##### 스트링 함수를 활용하는 방법

- String 생성자에 new 연산자를 붙이지 않으면 문자열을 반환하는 일반 함수가 된다.

  ```js
  String(26) // -> "26"
  ```



### 5.7.2 문자열을 숫자로 변환하기

##### 수식 안에서 묵시적으로 변환하는 방법

- ```js
  var s = "2";
  s-0	//	-> 2
  +s // -> 2
  ```



##### parseInt 와 parseFloat 함수를 사용하는 방법

- 두 함수는 문자열을 해석해서 숫자로 바꾸는 함수이다. parseInt 함수는 문자열을 정수로, parseFloat 함수는 문자열을 부동소수점으로 바꾼다.
- 두 함수 모두 맨 앞의 문자만 숫자로 바꾸어 반환한다. 그 뒤에 다른 문자들이 있다면 그 문자들은 모두 무시한다. 만약 문자열의 맨 처음 문자가 숫자로 변환할 수 없다면 NaN을 반환한다.



##### Number 함수를 활용하는 방법

- Number 생성자 앞에 new 연산자를 붙이지 않으면 반환값이 숫자인 일반 함수가 된다.
- 단, Number 함수는 10진수만 처리할 수 있다.



### 5.7.3 논리값으로 변환하기

- 모든 값을 논리값으로 바꾸는 방법은 아래 두 가지가 있다.

  ```js
  !!x
  Boolean(x)
  ```

  - 위 코드에서 !는 논리 타입이 아닌 값을 논리 타입으로 바꾸면서 논리 값을 반대로 바꾼다. 때문에 ! 연산자를 하나 더 사용하여 원래의 논리 값으로 복구하여 준다.